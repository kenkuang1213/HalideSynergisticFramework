Testing compilation unit with offset_marker at 0x4037a6
Loading ./gaussinBlur
Section: 
Section: .interp
Section: .note.ABI-tag
Section: .note.gnu.build-id
Section: .gnu.hash
Section: .dynsym
Section: .dynstr
Section: .gnu.version
Section: .gnu.version_r
Section: .rela.dyn
Section: .rela.plt
Section: .init
Section: .plt
Section: .text
Section: .fini
Section: .rodata
Section: .eh_frame_hdr
Section: .eh_frame
Section: .gcc_except_table
Section: .init_array
Section: .fini_array
Section: .jcr
Section: .dynamic
Section: .got
Section: .got.plt
Section: .data
Section: .bss
Section: .comment
Section: .shstrtab
Section: .symtab
Section: .strtab
Debugging sections not found



Input to letify input(max(min(x, (input.extent.0 - 1)), 0), max(min(y, (input.extent.1 - 1)), 0))
Canonical form without lets input(max(min(x, (input.extent.0 - 1)), 0), max(min(y, (input.extent.1 - 1)), 0))
0: x, 0
1: input.extent.0, 0
2: 1, 0
3: (input.extent.0 - 1), 0
4: min(x, (input.extent.0 - 1)), 1
5: 0, 0
6: max(min(x, (input.extent.0 - 1)), 0), 1
7: y, 0
8: input.extent.1, 0
9: (input.extent.1 - 1), 0
10: min(y, (input.extent.1 - 1)), 1
11: max(min(y, (input.extent.1 - 1)), 0), 1
12: input(max(min(x, (input.extent.0 - 1)), 0), max(min(y, (input.extent.1 - 1)), 0)), 1
With variables input(max(min(x, (input.extent.0 - 1)), 0), max(min(y, (input.extent.1 - 1)), 0))
With lets: input(max(min(x, (input.extent.0 - 1)), 0), max(min(y, (input.extent.1 - 1)), 0))



Input to letify (float32(clamped(x, y))/65535.000000f)
Canonical form without lets (float32(clamped(x, y))/65535.000000f)
0: x, 0
1: y, 0
2: clamped(x, y), 1
3: float32(clamped(x, y)), 1
4: 65535.000000f, 0
5: (float32(clamped(x, y))/65535.000000f), 0
With variables (float32(clamped(x, y))/65535.000000f)
With lets: (float32(clamped(x, y))/65535.000000f)



Input to letify (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*floating(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/float32(273)))
Canonical form without lets (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*floating(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/float32(273)))
0: x, 0
1: y, 0
2: blur(x, y), 1
3: i0.x$r, 0
4: i0.y$r, 0
5: i0(i0.x$r, i0.y$r), 1
6: float32(i0(i0.x$r, i0.y$r)), 1
7: (x + i0.x$r), 1
8: 2, 0
9: ((x + i0.x$r) - 2), 0
10: (y + i0.y$r), 1
11: ((y + i0.y$r) - 2), 0
12: floating(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)), 1
13: (float32(i0(i0.x$r, i0.y$r))*floating(((x + i0.x$r) - 2), ((y + i0.y$r) - 2))), 1
14: 273, 0
15: float32(273), 0
16: ((float32(i0(i0.x$r, i0.y$r))*floating(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/float32(273)), 0
17: (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*floating(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/float32(273))), 1
With variables (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*floating(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/float32(273)))
With lets: (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*floating(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/float32(273)))
Attempting to falsify: (((uint1(1) && ((i0.x$r != i0.x$r$_) && (x == x$_))) && ((i0.x$r != i0.x$r$_) && (y == y$_))) || ((uint1(1) && ((i0.x$r != i0.x$r$_) && (x == x$_))) && ((i0.x$r != i0.x$r$_) && (y == y$_))))
x not in scope, so leaving it as-is
x$_ not in scope, so leaving it as-is
y not in scope, so leaving it as-is
y$_ not in scope, so leaving it as-is
x not in scope, so leaving it as-is
x$_ not in scope, so leaving it as-is
y not in scope, so leaving it as-is
y$_ not in scope, so leaving it as-is
Simplified to: (((i0.x$r != i0.x$r$_) && (x == x$_)) && ((i0.x$r != i0.x$r$_) && (y == y$_)))
Attempting to falsify: (((uint1(1) && ((i0.y$r != i0.y$r$_) && (x == x$_))) && ((i0.y$r != i0.y$r$_) && (y == y$_))) || ((uint1(1) && ((i0.y$r != i0.y$r$_) && (x == x$_))) && ((i0.y$r != i0.y$r$_) && (y == y$_))))
x not in scope, so leaving it as-is
x$_ not in scope, so leaving it as-is
y not in scope, so leaving it as-is
y$_ not in scope, so leaving it as-is
x not in scope, so leaving it as-is
x$_ not in scope, so leaving it as-is
y not in scope, so leaving it as-is
y$_ not in scope, so leaving it as-is
Simplified to: (((i0.y$r != i0.y$r$_) && (x == x$_)) && ((i0.y$r != i0.y$r$_) && (y == y$_)))



Input to letify uint16((max(min(blur(x, y), 1.000000f), 0.000000f)*65535.000000f))
Canonical form without lets uint16((max(min(blur(x, y), 1.000000f), 0.000000f)*65535.000000f))
0: x, 0
1: y, 0
2: blur(x, y), 1
3: 1.000000f, 0
4: min(blur(x, y), 1.000000f), 1
5: 0.000000f, 0
6: max(min(blur(x, y), 1.000000f), 0.000000f), 1
7: 65535.000000f, 0
8: (max(min(blur(x, y), 1.000000f), 0.000000f)*65535.000000f), 0
9: uint16((max(min(blur(x, y), 1.000000f), 0.000000f)*65535.000000f)), 0
With variables uint16((max(min(blur(x, y), 1.000000f), 0.000000f)*65535.000000f))
With lets: uint16((max(min(blur(x, y), 1.000000f), 0.000000f)*65535.000000f))
Lowering before everything:
produce output {
  let output.s0.y.loop_max = output.s0.y.max
  let output.s0.y.loop_min = output.s0.y.min
  let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
  let output.s0.x.loop_max = output.s0.x.max
  let output.s0.x.loop_min = output.s0.x.min
  let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
  let output.s0.__outermost.loop_extent = 1
  let output.s0.__outermost.loop_max = 1
  let output.s0.__outermost.loop_min = 0
  let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
  let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
  let output.s0.x.x.__block_id_x.loop_min = 0
  let output.s0.s0.loop_extent = 16
  let output.s0.s0.loop_max = (16 - 1)
  let output.s0.s0.loop_min = 0
  let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
  let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
  let output.s0.x.x.__thread_id_x.loop_min = 0
  let output.s0.x.v15.loop_extent = 8
  let output.s0.x.v15.loop_max = (8 - 1)
  let output.s0.x.v15.loop_min = 0
  let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
  let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
  let output.s0.y.__block_id_y.loop_min = 0
  let output.s0.y.__thread_id_y.loop_extent = 16
  let output.s0.y.__thread_id_y.loop_max = (16 - 1)
  let output.s0.y.__thread_id_y.loop_min = 0
  for (output.s0.__outermost, output.s0.__outermost.loop_min, output.s0.__outermost.loop_extent) {
    parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
      parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
        parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
          let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
          parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
            let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
            vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
              let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
              let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
              output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
  }
}
0

Injecting realization of blur
InjectRealization of blur entering for loop over .__root
InjectRealization of blur entering for loop over output.s0.__outermost
InjectRealization of blur entering for loop over output.s0.y.__block_id_y
InjectRealization of blur entering for loop over output.s0.x.x.__block_id_x
InjectRealization of blur entering for loop over output.s0.y.__thread_id_y
InjectRealization of blur entering for loop over output.s0.x.x.__thread_id_x
InjectRealization of blur entering for loop over output.s0.x.v15
Found compute level
Update site 0 = blur.s1.x
Update site 1 = blur.s1.y
Found store level
for (.__root, 0, 1) {
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      for (blur.s0.__outermost, blur.s0.__outermost.loop_min, blur.s0.__outermost.loop_extent) {
        parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
          let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
          parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
            parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
              let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
              parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
                let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
                vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                  let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                  let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                  blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
                }
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.__outermost, blur.s1.__outermost.loop_min, blur.s1.__outermost.loop_extent) {
        for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
          for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
            for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
              for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
                blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*floating(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)))/float32(273)))
              }
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      for (output.s0.__outermost, output.s0.__outermost.loop_min, output.s0.__outermost.loop_extent) {
        parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
          let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
          parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
            parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
              let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
              parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
                let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
                vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                  let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                  let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                  output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
                }
              }
            }
          }
        }
      }
    }
    0
  }
}

Inlining floating



Input to letify (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(let floating.y = ((blur.s1.y + blur.s1.i0.y$r) - 2) in (let floating.x = ((blur.s1.x + blur.s1.i0.x$r) - 2) in (float32(clamped(floating.x, floating.y))/65535.000000f))))/float32(273)))
Canonical form without lets (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)))/65535.000000f))/float32(273)))
0: blur.s1.x, 0
1: blur.s1.y, 0
2: blur(blur.s1.x, blur.s1.y), 1
3: blur.s1.i0.x$r, 0
4: blur.s1.i0.y$r, 0
5: i0(blur.s1.i0.x$r, blur.s1.i0.y$r), 1
6: float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r)), 1
7: (blur.s1.y + blur.s1.i0.y$r), 1
8: 2, 0
9: ((blur.s1.y + blur.s1.i0.y$r) - 2), 0
10: (blur.s1.x + blur.s1.i0.x$r), 1
11: ((blur.s1.x + blur.s1.i0.x$r) - 2), 0
12: clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)), 1
13: float32(clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2))), 1
14: 65535.000000f, 0
15: (float32(clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)))/65535.000000f), 0
16: (float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)))/65535.000000f)), 1
17: 273, 0
18: float32(273), 0
19: ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)))/65535.000000f))/float32(273)), 0
20: (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)))/65535.000000f))/float32(273))), 1
With variables (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)))/65535.000000f))/float32(273)))
With lets: (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)))/65535.000000f))/float32(273)))
for (.__root, 0, 1) {
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      for (blur.s0.__outermost, blur.s0.__outermost.loop_min, blur.s0.__outermost.loop_extent) {
        parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
          let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
          parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
            parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
              let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
              parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
                let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
                vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                  let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                  let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                  blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
                }
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.__outermost, blur.s1.__outermost.loop_min, blur.s1.__outermost.loop_extent) {
        for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
          for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
            for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
              for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
                blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(clamped(((blur.s1.x + blur.s1.i0.x$r) - 2), ((blur.s1.y + blur.s1.i0.y$r) - 2)))/65535.000000f))/float32(273)))
              }
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      for (output.s0.__outermost, output.s0.__outermost.loop_min, output.s0.__outermost.loop_extent) {
        parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
          let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
          parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
            parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
              let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
              parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
                let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
                vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                  let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                  let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                  output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
                }
              }
            }
          }
        }
      }
    }
    0
  }
}

Inlining clamped



Input to letify (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32((let clamped.y = ((blur.s1.y + blur.s1.i0.y$r) - 2) in (let clamped.x = ((blur.s1.x + blur.s1.i0.x$r) - 2) in input(max(min(clamped.x, (input.extent.0 - 1)), 0), max(min(clamped.y, (input.extent.1 - 1)), 0)))))/65535.000000f))/float32(273)))
Canonical form without lets (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
0: blur.s1.x, 0
1: blur.s1.y, 0
2: blur(blur.s1.x, blur.s1.y), 1
3: blur.s1.i0.x$r, 0
4: blur.s1.i0.y$r, 0
5: i0(blur.s1.i0.x$r, blur.s1.i0.y$r), 1
6: float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r)), 1
7: (blur.s1.y + blur.s1.i0.y$r), 1
8: 2, 0
9: ((blur.s1.y + blur.s1.i0.y$r) - 2), 0
10: (blur.s1.x + blur.s1.i0.x$r), 1
11: ((blur.s1.x + blur.s1.i0.x$r) - 2), 0
12: input.extent.0, 0
13: 1, 0
14: (input.extent.0 - 1), 0
15: min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 1
16: 0, 0
17: max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), 1
18: input.extent.1, 0
19: (input.extent.1 - 1), 0
20: min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 1
21: max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0), 1
22: input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)), 1
23: float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0))), 1
24: 65535.000000f, 0
25: (float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f), 0
26: (float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f)), 1
27: 273, 0
28: float32(273), 0
29: ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)), 0
30: (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273))), 1
With variables (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
With lets: (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
for (.__root, 0, 1) {
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      for (blur.s0.__outermost, blur.s0.__outermost.loop_min, blur.s0.__outermost.loop_extent) {
        parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
          let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
          parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
            parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
              let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
              parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
                let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
                vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                  let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                  let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                  blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
                }
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.__outermost, blur.s1.__outermost.loop_min, blur.s1.__outermost.loop_extent) {
        for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
          for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
            for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
              for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
                blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
              }
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      for (output.s0.__outermost, output.s0.__outermost.loop_min, output.s0.__outermost.loop_extent) {
        parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
          let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
          parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
            parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
              let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
              parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
                let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
                vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                  let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                  let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                  output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
                }
              }
            }
          }
        }
      }
    }
    0
  }
}

Lowering after injecting realizations:
realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
  produce blur {
    let blur.s0.y.loop_max = blur.s0.y.max
    let blur.s0.y.loop_min = blur.s0.y.min
    let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
    let blur.s0.x.loop_max = blur.s0.x.max
    let blur.s0.x.loop_min = blur.s0.x.min
    let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
    let blur.s0.__outermost.loop_extent = 1
    let blur.s0.__outermost.loop_max = 1
    let blur.s0.__outermost.loop_min = 0
    let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
    let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
    let blur.s0.x.x.__block_id_x.loop_min = 0
    let blur.s0.s1.loop_extent = 128
    let blur.s0.s1.loop_max = (128 - 1)
    let blur.s0.s1.loop_min = 0
    let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
    let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
    let blur.s0.x.x.__thread_id_x.loop_min = 0
    let blur.s0.x.v14.loop_extent = 8
    let blur.s0.x.v14.loop_max = (8 - 1)
    let blur.s0.x.v14.loop_min = 0
    let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
    let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
    let blur.s0.y.__block_id_y.loop_min = 0
    let blur.s0.y.__thread_id_y.loop_extent = 8
    let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
    let blur.s0.y.__thread_id_y.loop_min = 0
    parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
      parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
        let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
        parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
          let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
          parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
            let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
            vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
              let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
              let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
              blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
            }
          }
        }
      }
    }
  } update blur {
    let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
    let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
    let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
    let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
    let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
    let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
    let blur.s1.y.loop_max = blur.s1.y.max
    let blur.s1.y.loop_min = blur.s1.y.min
    let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
    let blur.s1.x.loop_max = blur.s1.x.max
    let blur.s1.x.loop_min = blur.s1.x.min
    let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
    let blur.s1.__outermost.loop_extent = 1
    let blur.s1.__outermost.loop_max = 1
    let blur.s1.__outermost.loop_min = 0
    for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
      for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
        for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
          for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
            blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
          }
        }
      }
    }
  }
  produce output {
    let output.s0.y.loop_max = output.s0.y.max
    let output.s0.y.loop_min = output.s0.y.min
    let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
    let output.s0.x.loop_max = output.s0.x.max
    let output.s0.x.loop_min = output.s0.x.min
    let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
    let output.s0.__outermost.loop_extent = 1
    let output.s0.__outermost.loop_max = 1
    let output.s0.__outermost.loop_min = 0
    let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
    let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
    let output.s0.x.x.__block_id_x.loop_min = 0
    let output.s0.s0.loop_extent = 16
    let output.s0.s0.loop_max = (16 - 1)
    let output.s0.s0.loop_min = 0
    let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
    let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
    let output.s0.x.x.__thread_id_x.loop_min = 0
    let output.s0.x.v15.loop_extent = 8
    let output.s0.x.v15.loop_max = (8 - 1)
    let output.s0.x.v15.loop_min = 0
    let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
    let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
    let output.s0.y.__block_id_y.loop_min = 0
    let output.s0.y.__thread_id_y.loop_extent = 16
    let output.s0.y.__thread_id_y.loop_max = (16 - 1)
    let output.s0.y.__thread_id_y.loop_min = 0
    parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
      parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
        parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
          let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
          parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
            let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
            vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
              let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
              let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
              output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
  }
  0
}

Injecting memoization...
Lowering after injecting memoization:
realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
  produce blur {
    let blur.s0.y.loop_max = blur.s0.y.max
    let blur.s0.y.loop_min = blur.s0.y.min
    let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
    let blur.s0.x.loop_max = blur.s0.x.max
    let blur.s0.x.loop_min = blur.s0.x.min
    let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
    let blur.s0.__outermost.loop_extent = 1
    let blur.s0.__outermost.loop_max = 1
    let blur.s0.__outermost.loop_min = 0
    let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
    let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
    let blur.s0.x.x.__block_id_x.loop_min = 0
    let blur.s0.s1.loop_extent = 128
    let blur.s0.s1.loop_max = (128 - 1)
    let blur.s0.s1.loop_min = 0
    let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
    let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
    let blur.s0.x.x.__thread_id_x.loop_min = 0
    let blur.s0.x.v14.loop_extent = 8
    let blur.s0.x.v14.loop_max = (8 - 1)
    let blur.s0.x.v14.loop_min = 0
    let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
    let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
    let blur.s0.y.__block_id_y.loop_min = 0
    let blur.s0.y.__thread_id_y.loop_extent = 8
    let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
    let blur.s0.y.__thread_id_y.loop_min = 0
    parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
      parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
        let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
        parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
          let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
          parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
            let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
            vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
              let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
              let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
              blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
            }
          }
        }
      }
    }
  } update blur {
    let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
    let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
    let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
    let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
    let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
    let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
    let blur.s1.y.loop_max = blur.s1.y.max
    let blur.s1.y.loop_min = blur.s1.y.min
    let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
    let blur.s1.x.loop_max = blur.s1.x.max
    let blur.s1.x.loop_min = blur.s1.x.min
    let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
    let blur.s1.__outermost.loop_extent = 1
    let blur.s1.__outermost.loop_max = 1
    let blur.s1.__outermost.loop_min = 0
    for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
      for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
        for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
          for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
            blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
          }
        }
      }
    }
  }
  produce output {
    let output.s0.y.loop_max = output.s0.y.max
    let output.s0.y.loop_min = output.s0.y.min
    let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
    let output.s0.x.loop_max = output.s0.x.max
    let output.s0.x.loop_min = output.s0.x.min
    let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
    let output.s0.__outermost.loop_extent = 1
    let output.s0.__outermost.loop_max = 1
    let output.s0.__outermost.loop_min = 0
    let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
    let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
    let output.s0.x.x.__block_id_x.loop_min = 0
    let output.s0.s0.loop_extent = 16
    let output.s0.s0.loop_max = (16 - 1)
    let output.s0.s0.loop_min = 0
    let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
    let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
    let output.s0.x.x.__thread_id_x.loop_min = 0
    let output.s0.x.v15.loop_extent = 8
    let output.s0.x.v15.loop_max = (8 - 1)
    let output.s0.x.v15.loop_min = 0
    let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
    let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
    let output.s0.y.__block_id_y.loop_min = 0
    let output.s0.y.__thread_id_y.loop_extent = 16
    let output.s0.y.__thread_id_y.loop_max = (16 - 1)
    let output.s0.y.__thread_id_y.loop_min = 0
    parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
      parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
        parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
          let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
          parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
            let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
            vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
              let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
              let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
              output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
  }
  0
}

Injecting tracing...
Lowering after injecting tracing:
realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
  produce blur {
    let blur.s0.y.loop_max = blur.s0.y.max
    let blur.s0.y.loop_min = blur.s0.y.min
    let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
    let blur.s0.x.loop_max = blur.s0.x.max
    let blur.s0.x.loop_min = blur.s0.x.min
    let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
    let blur.s0.__outermost.loop_extent = 1
    let blur.s0.__outermost.loop_max = 1
    let blur.s0.__outermost.loop_min = 0
    let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
    let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
    let blur.s0.x.x.__block_id_x.loop_min = 0
    let blur.s0.s1.loop_extent = 128
    let blur.s0.s1.loop_max = (128 - 1)
    let blur.s0.s1.loop_min = 0
    let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
    let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
    let blur.s0.x.x.__thread_id_x.loop_min = 0
    let blur.s0.x.v14.loop_extent = 8
    let blur.s0.x.v14.loop_max = (8 - 1)
    let blur.s0.x.v14.loop_min = 0
    let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
    let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
    let blur.s0.y.__block_id_y.loop_min = 0
    let blur.s0.y.__thread_id_y.loop_extent = 8
    let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
    let blur.s0.y.__thread_id_y.loop_min = 0
    parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
      parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
        let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
        parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
          let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
          parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
            let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
            vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
              let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
              let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
              blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
            }
          }
        }
      }
    }
  } update blur {
    let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
    let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
    let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
    let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
    let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
    let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
    let blur.s1.y.loop_max = blur.s1.y.max
    let blur.s1.y.loop_min = blur.s1.y.min
    let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
    let blur.s1.x.loop_max = blur.s1.x.max
    let blur.s1.x.loop_min = blur.s1.x.min
    let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
    let blur.s1.__outermost.loop_extent = 1
    let blur.s1.__outermost.loop_max = 1
    let blur.s1.__outermost.loop_min = 0
    for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
      for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
        for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
          for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
            blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
          }
        }
      }
    }
  }
  produce output {
    let output.s0.y.loop_max = output.s0.y.max
    let output.s0.y.loop_min = output.s0.y.min
    let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
    let output.s0.x.loop_max = output.s0.x.max
    let output.s0.x.loop_min = output.s0.x.min
    let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
    let output.s0.__outermost.loop_extent = 1
    let output.s0.__outermost.loop_max = 1
    let output.s0.__outermost.loop_min = 0
    let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
    let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
    let output.s0.x.x.__block_id_x.loop_min = 0
    let output.s0.s0.loop_extent = 16
    let output.s0.s0.loop_max = (16 - 1)
    let output.s0.s0.loop_min = 0
    let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
    let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
    let output.s0.x.x.__thread_id_x.loop_min = 0
    let output.s0.x.v15.loop_extent = 8
    let output.s0.x.v15.loop_max = (8 - 1)
    let output.s0.x.v15.loop_min = 0
    let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
    let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
    let output.s0.y.__block_id_y.loop_min = 0
    let output.s0.y.__thread_id_y.loop_extent = 16
    let output.s0.y.__thread_id_y.loop_max = (16 - 1)
    let output.s0.y.__thread_id_y.loop_min = 0
    parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
      parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
        parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
          let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
          parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
            let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
            vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
              let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
              let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
              output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
  }
  0
}

Injecting profiling...
Lowering after injecting profiling:
realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
  produce blur {
    let blur.s0.y.loop_max = blur.s0.y.max
    let blur.s0.y.loop_min = blur.s0.y.min
    let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
    let blur.s0.x.loop_max = blur.s0.x.max
    let blur.s0.x.loop_min = blur.s0.x.min
    let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
    let blur.s0.__outermost.loop_extent = 1
    let blur.s0.__outermost.loop_max = 1
    let blur.s0.__outermost.loop_min = 0
    let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
    let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
    let blur.s0.x.x.__block_id_x.loop_min = 0
    let blur.s0.s1.loop_extent = 128
    let blur.s0.s1.loop_max = (128 - 1)
    let blur.s0.s1.loop_min = 0
    let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
    let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
    let blur.s0.x.x.__thread_id_x.loop_min = 0
    let blur.s0.x.v14.loop_extent = 8
    let blur.s0.x.v14.loop_max = (8 - 1)
    let blur.s0.x.v14.loop_min = 0
    let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
    let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
    let blur.s0.y.__block_id_y.loop_min = 0
    let blur.s0.y.__thread_id_y.loop_extent = 8
    let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
    let blur.s0.y.__thread_id_y.loop_min = 0
    parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
      parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
        let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
        parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
          let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
          parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
            let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
            vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
              let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
              let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
              blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
            }
          }
        }
      }
    }
  } update blur {
    let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
    let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
    let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
    let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
    let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
    let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
    let blur.s1.y.loop_max = blur.s1.y.max
    let blur.s1.y.loop_min = blur.s1.y.min
    let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
    let blur.s1.x.loop_max = blur.s1.x.max
    let blur.s1.x.loop_min = blur.s1.x.min
    let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
    let blur.s1.__outermost.loop_extent = 1
    let blur.s1.__outermost.loop_max = 1
    let blur.s1.__outermost.loop_min = 0
    for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
      for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
        for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
          for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
            blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
          }
        }
      }
    }
  }
  produce output {
    let output.s0.y.loop_max = output.s0.y.max
    let output.s0.y.loop_min = output.s0.y.min
    let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
    let output.s0.x.loop_max = output.s0.x.max
    let output.s0.x.loop_min = output.s0.x.min
    let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
    let output.s0.__outermost.loop_extent = 1
    let output.s0.__outermost.loop_max = 1
    let output.s0.__outermost.loop_min = 0
    let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
    let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
    let output.s0.x.x.__block_id_x.loop_min = 0
    let output.s0.s0.loop_extent = 16
    let output.s0.s0.loop_max = (16 - 1)
    let output.s0.s0.loop_min = 0
    let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
    let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
    let output.s0.x.x.__thread_id_x.loop_min = 0
    let output.s0.x.v15.loop_extent = 8
    let output.s0.x.v15.loop_max = (8 - 1)
    let output.s0.x.v15.loop_min = 0
    let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
    let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
    let output.s0.y.__block_id_y.loop_min = 0
    let output.s0.y.__thread_id_y.loop_extent = 16
    let output.s0.y.__thread_id_y.loop_max = (16 - 1)
    let output.s0.y.__thread_id_y.loop_min = 0
    parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
      parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
        parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
          let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
          parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
            let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
            vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
              let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
              let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
              output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
  }
  0
}

Adding checks for parameters
Lowering after injecting parameter checks:
realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
  produce blur {
    let blur.s0.y.loop_max = blur.s0.y.max
    let blur.s0.y.loop_min = blur.s0.y.min
    let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
    let blur.s0.x.loop_max = blur.s0.x.max
    let blur.s0.x.loop_min = blur.s0.x.min
    let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
    let blur.s0.__outermost.loop_extent = 1
    let blur.s0.__outermost.loop_max = 1
    let blur.s0.__outermost.loop_min = 0
    let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
    let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
    let blur.s0.x.x.__block_id_x.loop_min = 0
    let blur.s0.s1.loop_extent = 128
    let blur.s0.s1.loop_max = (128 - 1)
    let blur.s0.s1.loop_min = 0
    let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
    let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
    let blur.s0.x.x.__thread_id_x.loop_min = 0
    let blur.s0.x.v14.loop_extent = 8
    let blur.s0.x.v14.loop_max = (8 - 1)
    let blur.s0.x.v14.loop_min = 0
    let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
    let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
    let blur.s0.y.__block_id_y.loop_min = 0
    let blur.s0.y.__thread_id_y.loop_extent = 8
    let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
    let blur.s0.y.__thread_id_y.loop_min = 0
    parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
      parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
        let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
        parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
          let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
          parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
            let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
            vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
              let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
              let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
              blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
            }
          }
        }
      }
    }
  } update blur {
    let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
    let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
    let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
    let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
    let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
    let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
    let blur.s1.y.loop_max = blur.s1.y.max
    let blur.s1.y.loop_min = blur.s1.y.min
    let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
    let blur.s1.x.loop_max = blur.s1.x.max
    let blur.s1.x.loop_min = blur.s1.x.min
    let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
    let blur.s1.__outermost.loop_extent = 1
    let blur.s1.__outermost.loop_max = 1
    let blur.s1.__outermost.loop_min = 0
    for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
      for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
        for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
          for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
            blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
          }
        }
      }
    }
  }
  produce output {
    let output.s0.y.loop_max = output.s0.y.max
    let output.s0.y.loop_min = output.s0.y.min
    let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
    let output.s0.x.loop_max = output.s0.x.max
    let output.s0.x.loop_min = output.s0.x.min
    let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
    let output.s0.__outermost.loop_extent = 1
    let output.s0.__outermost.loop_max = 1
    let output.s0.__outermost.loop_min = 0
    let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
    let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
    let output.s0.x.x.__block_id_x.loop_min = 0
    let output.s0.s0.loop_extent = 16
    let output.s0.s0.loop_max = (16 - 1)
    let output.s0.s0.loop_min = 0
    let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
    let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
    let output.s0.x.x.__thread_id_x.loop_min = 0
    let output.s0.x.v15.loop_extent = 8
    let output.s0.x.v15.loop_max = (8 - 1)
    let output.s0.x.v15.loop_min = 0
    let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
    let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
    let output.s0.y.__block_id_y.loop_min = 0
    let output.s0.y.__thread_id_y.loop_extent = 16
    let output.s0.y.__thread_id_y.loop_max = (16 - 1)
    let output.s0.y.__thread_id_y.loop_min = 0
    parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
      parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
        parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
          let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
          parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
            let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
            vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
              let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
              let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
              output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
  }
  0
}

Computing bounds of each function's value
input.extent.0 not in scope, so leaving it as-is
Bounds of min(x, (input.extent.0 - 1))
(undefined), (input.extent.0 - 1)
Bounds of max(min(x, (input.extent.0 - 1)), 0)
0, max((input.extent.0 - 1), 0)
Bounds on value 0 for func clamped are: uint16(0), uint16(65535)
Bounds on value 0 for func floating are: 0.000000f, 1.000000f
Bounds on value 0 for func blur are: (undefined), (undefined)
Bounds of min(blur(x, y), 1.000000f)
(undefined), 1.000000f
Bounds of max(min(blur(x, y), 1.000000f), 0.000000f)
0.000000f, max(1.000000f, 0.000000f)
Bounds on value 0 for func output are: uint16(0), uint16(65535)
Adding checks for images
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
Bounds of min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
min(((0*8) + blur.s0.y.min), (blur.s0.y.max + (1 - 8))), min(((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min), (blur.s0.y.max + (1 - 8)))
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
Bounds of min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
min(((0*128) + blur.s0.x.min), (blur.s0.x.max + (1 - 128))), min(((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min), (blur.s0.x.max + (1 - 128)))
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s1.i0.y$r.max not in scope, so leaving it as-is
blur.s1.i0.y$r.min not in scope, so leaving it as-is
blur.s1.i0.y$r.max not in scope, so leaving it as-is
blur.s1.i0.y$r.min not in scope, so leaving it as-is
blur.s1.i0.x$r.max not in scope, so leaving it as-is
blur.s1.i0.x$r.min not in scope, so leaving it as-is
blur.s1.i0.x$r.max not in scope, so leaving it as-is
blur.s1.i0.x$r.min not in scope, so leaving it as-is
blur.s1.y.max not in scope, so leaving it as-is
blur.s1.y.min not in scope, so leaving it as-is
blur.s1.y.max not in scope, so leaving it as-is
blur.s1.y.min not in scope, so leaving it as-is
blur.s1.x.max not in scope, so leaving it as-is
blur.s1.x.min not in scope, so leaving it as-is
blur.s1.x.max not in scope, so leaving it as-is
blur.s1.x.min not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
Bounds of min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1))
min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1))
Bounds of max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0)
max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0)
input.extent.1 not in scope, so leaving it as-is
Bounds of min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1))
min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1))
Bounds of max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)
max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0)
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
Bounds of min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
min(((0*16) + output.s0.y.min), (output.s0.y.max + (1 - 16))), min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + (1 - 16)))
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
Bounds of min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
min(((0*16) + output.s0.x.min), (output.s0.x.max + (1 - 16))), min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + (1 - 16)))
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
In image i0 region touched is:
Injecting constraints for i0.0
Injecting constraints for i0.1
In image input region touched is:
Injecting constraints for input.0
Injecting constraints for input.1
In image output region touched is:
Injecting constraints for output.0
Injecting constraints for output.1
Lowering after injecting image checks:
let i0.extent.0.required = ((blur.s1.i0.x$r.max + 1) - blur.s1.i0.x$r.min)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max + 1) - blur.s1.i0.y$r.min)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0) + 1) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0))
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0) + 1) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0))
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = (((min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + -15)) + (8 + 7)) + 1) - (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)))
let output.min.0.required = (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0))
let output.stride.0.required = 1
let output.extent.1.required = (((min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + -15)) + 15) + 1) - (min(output.s0.y.min, (output.s0.y.max + -15)) + 0))
let output.min.1.required = (min(output.s0.y.min, (output.s0.y.max + -15)) + 0)
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && ((i0.min.0.proposed + i0.extent.0.proposed) >= (i0.min.0.required + i0.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && ((i0.min.1.proposed + i0.extent.1.proposed) >= (i0.min.1.required + i0.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && ((input.min.0.proposed + input.extent.0.proposed) >= (input.min.0.required + input.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && ((input.min.1.proposed + input.extent.1.proposed) >= (input.min.1.required + input.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && ((output.min.0.proposed + output.extent.0.proposed) >= (output.min.0.required + output.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && ((output.min.1.proposed + output.extent.1.proposed) >= (output.min.1.required + output.extent.1.required)))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!(((uint1(0) || i0.host_and_dev_are_null) || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of ", 2))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of ", 2))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of ", 2))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0 + i0.extent.0) - 1) >= ((i0.min.0.required + i0.extent.0.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) - 1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) - 1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1 + i0.extent.1) - 1) >= ((i0.min.1.required + i0.extent.1.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) - 1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) - 1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) - 1), ", which is beyond the max (", ((input.min.0 + input.extent.0) - 1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) - 1), ", which is beyond the max (", ((input.min.1 + input.extent.1) - 1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) - 1), ", which is beyond the max (", ((output.min.0 + output.extent.0) - 1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", (min(output.s0.y.min, (output.s0.y.max + -15)) + 0), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) - 1), ", which is beyond the max (", ((output.min.1 + output.extent.1) - 1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}

Performing computation bounds inference...



Input to letify (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(let floating.y = ((y + i0.y$r) - 2) in (let floating.x = ((x + i0.x$r) - 2) in (float32(clamped(floating.x, floating.y))/65535.000000f))))/float32(273)))
Canonical form without lets (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(float32(clamped(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/65535.000000f))/float32(273)))
0: x, 0
1: y, 0
2: blur(x, y), 1
3: i0.x$r, 0
4: i0.y$r, 0
5: i0(i0.x$r, i0.y$r), 1
6: float32(i0(i0.x$r, i0.y$r)), 1
7: (y + i0.y$r), 1
8: 2, 0
9: ((y + i0.y$r) - 2), 0
10: (x + i0.x$r), 1
11: ((x + i0.x$r) - 2), 0
12: clamped(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)), 1
13: float32(clamped(((x + i0.x$r) - 2), ((y + i0.y$r) - 2))), 1
14: 65535.000000f, 0
15: (float32(clamped(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/65535.000000f), 0
16: (float32(i0(i0.x$r, i0.y$r))*(float32(clamped(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/65535.000000f)), 1
17: 273, 0
18: float32(273), 0
19: ((float32(i0(i0.x$r, i0.y$r))*(float32(clamped(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/65535.000000f))/float32(273)), 0
20: (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(float32(clamped(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/65535.000000f))/float32(273))), 1
With variables (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(float32(clamped(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/65535.000000f))/float32(273)))
With lets: (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(float32(clamped(((x + i0.x$r) - 2), ((y + i0.y$r) - 2)))/65535.000000f))/float32(273)))



Input to letify (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(float32((let clamped.y = ((y + i0.y$r) - 2) in (let clamped.x = ((x + i0.x$r) - 2) in input(max(min(clamped.x, (input.extent.0 - 1)), 0), max(min(clamped.y, (input.extent.1 - 1)), 0)))))/65535.000000f))/float32(273)))
Canonical form without lets (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(float32(input(max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
0: x, 0
1: y, 0
2: blur(x, y), 1
3: i0.x$r, 0
4: i0.y$r, 0
5: i0(i0.x$r, i0.y$r), 1
6: float32(i0(i0.x$r, i0.y$r)), 1
7: (y + i0.y$r), 1
8: 2, 0
9: ((y + i0.y$r) - 2), 0
10: (x + i0.x$r), 1
11: ((x + i0.x$r) - 2), 0
12: input.extent.0, 0
13: 1, 0
14: (input.extent.0 - 1), 0
15: min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 1
16: 0, 0
17: max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), 1
18: input.extent.1, 0
19: (input.extent.1 - 1), 0
20: min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 1
21: max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0), 1
22: input(max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0)), 1
23: float32(input(max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0))), 1
24: 65535.000000f, 0
25: (float32(input(max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f), 0
26: (float32(i0(i0.x$r, i0.y$r))*(float32(input(max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f)), 1
27: 273, 0
28: float32(273), 0
29: ((float32(i0(i0.x$r, i0.y$r))*(float32(input(max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)), 0
30: (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(float32(input(max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273))), 1
With variables (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(float32(input(max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
With lets: (blur(x, y) + ((float32(i0(i0.x$r, i0.y$r))*(float32(input(max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
input.extent.0 not in scope, so leaving it as-is
Bounds of min(((x + i0.x$r) - 2), (input.extent.0 - 1))
min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1))
Bounds of max(min(((x + i0.x$r) - 2), (input.extent.0 - 1)), 0)
max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0)
input.extent.1 not in scope, so leaving it as-is
Bounds of min(((y + i0.y$r) - 2), (input.extent.1 - 1))
min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1))
Bounds of max(min(((y + i0.y$r) - 2), (input.extent.1 - 1)), 0)
max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0)
blur.s0.s1.base not in scope, so leaving it as-is
blur.s0.x.v14.base not in scope, so leaving it as-is
blur.s0.x.v14 not in scope, so leaving it as-is
blur.s0.y.__thread_id_y.base not in scope, so leaving it as-is
blur.s0.y.__thread_id_y not in scope, so leaving it as-is
blur.s1.x not in scope, so leaving it as-is
blur.s1.y not in scope, so leaving it as-is
blur.s1.i0.x$r not in scope, so leaving it as-is
blur.s1.i0.x$r not in scope, so leaving it as-is
output.s0.s0.base not in scope, so leaving it as-is
output.s0.x.v15.base not in scope, so leaving it as-is
output.s0.x.v15 not in scope, so leaving it as-is
output.s0.y.__thread_id_y.base not in scope, so leaving it as-is
output.s0.y.__thread_id_y not in scope, so leaving it as-is
Lowering after computation bounds inference:
let output.s0.y.max = ((output.min.1 + output.extent.1) - 1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) - 1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = ((5 + 0) - 1)
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = ((5 + 0) - 1)
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max + 1) - blur.s1.i0.x$r.min)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max + 1) - blur.s1.i0.y$r.min)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0) + 1) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0))
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0) + 1) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0))
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = (((min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + -15)) + (8 + 7)) + 1) - (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)))
let output.min.0.required = (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0))
let output.stride.0.required = 1
let output.extent.1.required = (((min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + -15)) + 15) + 1) - (min(output.s0.y.min, (output.s0.y.max + -15)) + 0))
let output.min.1.required = (min(output.s0.y.min, (output.s0.y.max + -15)) + 0)
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && ((i0.min.0.proposed + i0.extent.0.proposed) >= (i0.min.0.required + i0.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && ((i0.min.1.proposed + i0.extent.1.proposed) >= (i0.min.1.required + i0.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && ((input.min.0.proposed + input.extent.0.proposed) >= (input.min.0.required + input.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && ((input.min.1.proposed + input.extent.1.proposed) >= (input.min.1.required + input.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && ((output.min.0.proposed + output.extent.0.proposed) >= (output.min.0.required + output.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && ((output.min.1.proposed + output.extent.1.proposed) >= (output.min.1.required + output.extent.1.required)))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!(((uint1(0) || i0.host_and_dev_are_null) || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of ", 2))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of ", 2))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of ", 2))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0 + i0.extent.0) - 1) >= ((i0.min.0.required + i0.extent.0.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) - 1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) - 1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1 + i0.extent.1) - 1) >= ((i0.min.1.required + i0.extent.1.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) - 1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) - 1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) - 1), ", which is beyond the max (", ((input.min.0 + input.extent.0) - 1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) - 1), ", which is beyond the max (", ((input.min.1 + input.extent.1) - 1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) - 1), ", which is beyond the max (", ((output.min.0 + output.extent.0) - 1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", (min(output.s0.y.min, (output.s0.y.max + -15)) + 0), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) - 1), ", which is beyond the max (", ((output.min.1 + output.extent.1) - 1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              let blur.s1.i0.y$r.max = blur.s1.i0.y$r
              let blur.s1.i0.y$r.min = blur.s1.i0.y$r
              let blur.s1.i0.x$r.max = blur.s1.i0.x$r
              let blur.s1.i0.x$r.min = blur.s1.i0.x$r
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}

Performing sliding window optimization...
Lowering after sliding window:
let output.s0.y.max = ((output.min.1 + output.extent.1) - 1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) - 1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = ((5 + 0) - 1)
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = ((5 + 0) - 1)
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max + 1) - blur.s1.i0.x$r.min)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max + 1) - blur.s1.i0.y$r.min)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0) + 1) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0))
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0) + 1) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0))
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = (((min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + -15)) + (8 + 7)) + 1) - (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)))
let output.min.0.required = (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0))
let output.stride.0.required = 1
let output.extent.1.required = (((min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + -15)) + 15) + 1) - (min(output.s0.y.min, (output.s0.y.max + -15)) + 0))
let output.min.1.required = (min(output.s0.y.min, (output.s0.y.max + -15)) + 0)
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && ((i0.min.0.proposed + i0.extent.0.proposed) >= (i0.min.0.required + i0.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && ((i0.min.1.proposed + i0.extent.1.proposed) >= (i0.min.1.required + i0.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && ((input.min.0.proposed + input.extent.0.proposed) >= (input.min.0.required + input.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && ((input.min.1.proposed + input.extent.1.proposed) >= (input.min.1.required + input.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && ((output.min.0.proposed + output.extent.0.proposed) >= (output.min.0.required + output.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && ((output.min.1.proposed + output.extent.1.proposed) >= (output.min.1.required + output.extent.1.required)))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!(((uint1(0) || i0.host_and_dev_are_null) || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of ", 2))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of ", 2))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of ", 2))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0 + i0.extent.0) - 1) >= ((i0.min.0.required + i0.extent.0.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) - 1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) - 1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1 + i0.extent.1) - 1) >= ((i0.min.1.required + i0.extent.1.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) - 1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) - 1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) - 1), ", which is beyond the max (", ((input.min.0 + input.extent.0) - 1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) - 1), ", which is beyond the max (", ((input.min.1 + input.extent.1) - 1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) - 1), ", which is beyond the max (", ((output.min.0 + output.extent.0) - 1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", (min(output.s0.y.min, (output.s0.y.max + -15)) + 0), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) - 1), ", which is beyond the max (", ((output.min.1 + output.extent.1) - 1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              let blur.s1.i0.y$r.max = blur.s1.i0.y$r
              let blur.s1.i0.y$r.min = blur.s1.i0.y$r
              let blur.s1.i0.x$r.max = blur.s1.i0.x$r
              let blur.s1.i0.x$r.min = blur.s1.i0.x$r
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}

Performing allocation bounds inference...
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
Bounds of min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
min(((0*8) + blur.s0.y.min), (blur.s0.y.max + (1 - 8))), min(((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min), (blur.s0.y.max + (1 - 8)))
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
Bounds of min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
min(((0*128) + blur.s0.x.min), (blur.s0.x.max + (1 - 128))), min(((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min), (blur.s0.x.max + (1 - 128)))
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s1.i0.y$r.max not in scope, so leaving it as-is
blur.s1.i0.y$r.min not in scope, so leaving it as-is
blur.s1.i0.y$r.max not in scope, so leaving it as-is
blur.s1.i0.y$r.min not in scope, so leaving it as-is
blur.s1.i0.x$r.max not in scope, so leaving it as-is
blur.s1.i0.x$r.min not in scope, so leaving it as-is
blur.s1.i0.x$r.max not in scope, so leaving it as-is
blur.s1.i0.x$r.min not in scope, so leaving it as-is
blur.s1.y.max not in scope, so leaving it as-is
blur.s1.y.min not in scope, so leaving it as-is
blur.s1.y.max not in scope, so leaving it as-is
blur.s1.y.min not in scope, so leaving it as-is
blur.s1.x.max not in scope, so leaving it as-is
blur.s1.x.min not in scope, so leaving it as-is
blur.s1.x.max not in scope, so leaving it as-is
blur.s1.x.min not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
Bounds of min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1))
min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1))
Bounds of max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0)
max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0)
input.extent.1 not in scope, so leaving it as-is
Bounds of min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1))
min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1))
Bounds of max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)
max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0)
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
Bounds of min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
min(((0*16) + output.s0.y.min), (output.s0.y.max + (1 - 16))), min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + (1 - 16)))
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
Bounds of min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
min(((0*16) + output.s0.x.min), (output.s0.x.max + (1 - 16))), min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + (1 - 16)))
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
Lowering after allocation bounds inference:
let output.s0.y.max = ((output.min.1 + output.extent.1) - 1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) - 1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = ((5 + 0) - 1)
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = ((5 + 0) - 1)
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max + 1) - blur.s1.i0.x$r.min)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max + 1) - blur.s1.i0.y$r.min)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0) + 1) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0))
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0) + 1) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0))
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = (((min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + -15)) + (8 + 7)) + 1) - (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)))
let output.min.0.required = (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0))
let output.stride.0.required = 1
let output.extent.1.required = (((min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + -15)) + 15) + 1) - (min(output.s0.y.min, (output.s0.y.max + -15)) + 0))
let output.min.1.required = (min(output.s0.y.min, (output.s0.y.max + -15)) + 0)
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && ((i0.min.0.proposed + i0.extent.0.proposed) >= (i0.min.0.required + i0.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && ((i0.min.1.proposed + i0.extent.1.proposed) >= (i0.min.1.required + i0.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && ((input.min.0.proposed + input.extent.0.proposed) >= (input.min.0.required + input.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && ((input.min.1.proposed + input.extent.1.proposed) >= (input.min.1.required + input.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && ((output.min.0.proposed + output.extent.0.proposed) >= (output.min.0.required + output.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && ((output.min.1.proposed + output.extent.1.proposed) >= (output.min.1.required + output.extent.1.required)))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!(((uint1(0) || i0.host_and_dev_are_null) || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of ", 2))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of ", 2))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of ", 2))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0 + i0.extent.0) - 1) >= ((i0.min.0.required + i0.extent.0.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) - 1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) - 1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1 + i0.extent.1) - 1) >= ((i0.min.1.required + i0.extent.1.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) - 1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) - 1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) - 1), ", which is beyond the max (", ((input.min.0 + input.extent.0) - 1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) - 1), ", which is beyond the max (", ((input.min.1 + input.extent.1) - 1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) - 1), ", which is beyond the max (", ((output.min.0 + output.extent.0) - 1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", (min(output.s0.y.min, (output.s0.y.max + -15)) + 0), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) - 1), ", which is beyond the max (", ((output.min.1 + output.extent.1) - 1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              let blur.s1.i0.y$r.max = blur.s1.i0.y$r
              let blur.s1.i0.y$r.min = blur.s1.i0.y$r
              let blur.s1.i0.x$r.max = blur.s1.i0.x$r
              let blur.s1.i0.x$r.min = blur.s1.i0.x$r
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}

Removing code that depends on undef values...
Lowering after removing code that depends on undef values:
let output.s0.y.max = ((output.min.1 + output.extent.1) - 1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) - 1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = ((5 + 0) - 1)
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = ((5 + 0) - 1)
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max + 1) - blur.s1.i0.x$r.min)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max + 1) - blur.s1.i0.y$r.min)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0) + 1) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0))
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0) + 1) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0))
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = (((min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + -15)) + (8 + 7)) + 1) - (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)))
let output.min.0.required = (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0))
let output.stride.0.required = 1
let output.extent.1.required = (((min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + -15)) + 15) + 1) - (min(output.s0.y.min, (output.s0.y.max + -15)) + 0))
let output.min.1.required = (min(output.s0.y.min, (output.s0.y.max + -15)) + 0)
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && ((i0.min.0.proposed + i0.extent.0.proposed) >= (i0.min.0.required + i0.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && ((i0.min.1.proposed + i0.extent.1.proposed) >= (i0.min.1.required + i0.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && ((input.min.0.proposed + input.extent.0.proposed) >= (input.min.0.required + input.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && ((input.min.1.proposed + input.extent.1.proposed) >= (input.min.1.required + input.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && ((output.min.0.proposed + output.extent.0.proposed) >= (output.min.0.required + output.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && ((output.min.1.proposed + output.extent.1.proposed) >= (output.min.1.required + output.extent.1.required)))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!(((uint1(0) || i0.host_and_dev_are_null) || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of ", 2))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of ", 2))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of ", 2))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0 + i0.extent.0) - 1) >= ((i0.min.0.required + i0.extent.0.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) - 1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) - 1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1 + i0.extent.1) - 1) >= ((i0.min.1.required + i0.extent.1.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) - 1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) - 1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) - 1), ", which is beyond the max (", ((input.min.0 + input.extent.0) - 1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) - 1), ", which is beyond the max (", ((input.min.1 + input.extent.1) - 1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) - 1), ", which is beyond the max (", ((output.min.0 + output.extent.0) - 1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", (min(output.s0.y.min, (output.s0.y.max + -15)) + 0), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) - 1), ", which is beyond the max (", ((output.min.1 + output.extent.1) - 1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              let blur.s1.i0.y$r.max = blur.s1.i0.y$r
              let blur.s1.i0.y$r.min = blur.s1.i0.y$r
              let blur.s1.i0.x$r.max = blur.s1.i0.x$r
              let blur.s1.i0.x$r.min = blur.s1.i0.x$r
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}


Uniquifying variable names...
Lowering after uniquifying variable names:
let output.s0.y.max = ((output.min.1 + output.extent.1) - 1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) - 1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = ((5 + 0) - 1)
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = ((5 + 0) - 1)
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max + 1) - blur.s1.i0.x$r.min)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max + 1) - blur.s1.i0.y$r.min)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0) + 1) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0))
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0) + 1) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0))
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = (((min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + -15)) + (8 + 7)) + 1) - (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)))
let output.min.0.required = (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0))
let output.stride.0.required = 1
let output.extent.1.required = (((min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + -15)) + 15) + 1) - (min(output.s0.y.min, (output.s0.y.max + -15)) + 0))
let output.min.1.required = (min(output.s0.y.min, (output.s0.y.max + -15)) + 0)
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && ((i0.min.0.proposed + i0.extent.0.proposed) >= (i0.min.0.required + i0.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && ((i0.min.1.proposed + i0.extent.1.proposed) >= (i0.min.1.required + i0.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && ((input.min.0.proposed + input.extent.0.proposed) >= (input.min.0.required + input.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && ((input.min.1.proposed + input.extent.1.proposed) >= (input.min.1.required + input.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && ((output.min.0.proposed + output.extent.0.proposed) >= (output.min.0.required + output.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && ((output.min.1.proposed + output.extent.1.proposed) >= (output.min.1.required + output.extent.1.required)))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!(((uint1(0) || i0.host_and_dev_are_null) || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of ", 2))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of ", 2))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of ", 2))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0 + i0.extent.0) - 1) >= ((i0.min.0.required + i0.extent.0.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) - 1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) - 1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1 + i0.extent.1) - 1) >= ((i0.min.1.required + i0.extent.1.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) - 1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) - 1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) - 1), ", which is beyond the max (", ((input.min.0 + input.extent.0) - 1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) - 1), ", which is beyond the max (", ((input.min.1 + input.extent.1) - 1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) - 1), ", which is beyond the max (", ((output.min.0 + output.extent.0) - 1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", (min(output.s0.y.min, (output.s0.y.max + -15)) + 0), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) - 1), ", which is beyond the max (", ((output.min.1 + output.extent.1) - 1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              let blur.s1.i0.y$r.max_1 = blur.s1.i0.y$r
              let blur.s1.i0.y$r.min_1 = blur.s1.i0.y$r
              let blur.s1.i0.x$r.max_1 = blur.s1.i0.x$r
              let blur.s1.i0.x$r.min_1 = blur.s1.i0.x$r
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}


Performing storage folding optimization...
Attempting to fold blur
Lowering after storage folding:
let output.s0.y.max = ((output.min.1 + output.extent.1) - 1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) - 1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = ((5 + 0) - 1)
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = ((5 + 0) - 1)
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max + 1) - blur.s1.i0.x$r.min)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max + 1) - blur.s1.i0.y$r.min)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0) + 1) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0))
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0) + 1) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0))
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = (((min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + -15)) + (8 + 7)) + 1) - (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)))
let output.min.0.required = (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0))
let output.stride.0.required = 1
let output.extent.1.required = (((min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + -15)) + 15) + 1) - (min(output.s0.y.min, (output.s0.y.max + -15)) + 0))
let output.min.1.required = (min(output.s0.y.min, (output.s0.y.max + -15)) + 0)
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && ((i0.min.0.proposed + i0.extent.0.proposed) >= (i0.min.0.required + i0.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && ((i0.min.1.proposed + i0.extent.1.proposed) >= (i0.min.1.required + i0.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && ((input.min.0.proposed + input.extent.0.proposed) >= (input.min.0.required + input.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && ((input.min.1.proposed + input.extent.1.proposed) >= (input.min.1.required + input.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && ((output.min.0.proposed + output.extent.0.proposed) >= (output.min.0.required + output.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && ((output.min.1.proposed + output.extent.1.proposed) >= (output.min.1.required + output.extent.1.required)))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!(((uint1(0) || i0.host_and_dev_are_null) || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of ", 2))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of ", 2))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of ", 2))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0 + i0.extent.0) - 1) >= ((i0.min.0.required + i0.extent.0.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) - 1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) - 1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1 + i0.extent.1) - 1) >= ((i0.min.1.required + i0.extent.1.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) - 1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) - 1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) - 1), ", which is beyond the max (", ((input.min.0 + input.extent.0) - 1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) - 1), ", which is beyond the max (", ((input.min.1 + input.extent.1) - 1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) - 1), ", which is beyond the max (", ((output.min.0 + output.extent.0) - 1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", (min(output.s0.y.min, (output.s0.y.max + -15)) + 0), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) - 1), ", which is beyond the max (", ((output.min.1 + output.extent.1) - 1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              let blur.s1.i0.y$r.max_1 = blur.s1.i0.y$r
              let blur.s1.i0.y$r.min_1 = blur.s1.i0.y$r
              let blur.s1.i0.x$r.max_1 = blur.s1.i0.x$r
              let blur.s1.i0.x$r.min_1 = blur.s1.i0.x$r
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}

Injecting debug_to_file calls...
Lowering after injecting debug_to_file calls:
let output.s0.y.max = ((output.min.1 + output.extent.1) - 1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) - 1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = ((5 + 0) - 1)
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = ((5 + 0) - 1)
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max + 1) - blur.s1.i0.x$r.min)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max + 1) - blur.s1.i0.y$r.min)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) - 2), (input.extent.0 - 1)), 0) + 1) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0))
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) - 2), (input.extent.1 - 1)), 0) + 1) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0))
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = (((min(((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min), (output.s0.x.max + -15)) + (8 + 7)) + 1) - (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)))
let output.min.0.required = (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0))
let output.stride.0.required = 1
let output.extent.1.required = (((min(((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min), (output.s0.y.max + -15)) + 15) + 1) - (min(output.s0.y.min, (output.s0.y.max + -15)) + 0))
let output.min.1.required = (min(output.s0.y.min, (output.s0.y.max + -15)) + 0)
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && ((i0.min.0.proposed + i0.extent.0.proposed) >= (i0.min.0.required + i0.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && ((i0.min.1.proposed + i0.extent.1.proposed) >= (i0.min.1.required + i0.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && ((input.min.0.proposed + input.extent.0.proposed) >= (input.min.0.required + input.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && ((input.min.1.proposed + input.extent.1.proposed) >= (input.min.1.required + input.extent.1.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && ((output.min.0.proposed + output.extent.0.proposed) >= (output.min.0.required + output.extent.0.required)))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && ((output.min.1.proposed + output.extent.1.proposed) >= (output.min.1.required + output.extent.1.required)))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!(((uint1(0) || i0.host_and_dev_are_null) || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of ", 2))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of ", 2))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of ", 2))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0 + i0.extent.0) - 1) >= ((i0.min.0.required + i0.extent.0.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) - 1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) - 1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1 + i0.extent.1) - 1) >= ((i0.min.1.required + i0.extent.1.required) - 1)), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) - 1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) - 1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) - 2), (input.extent.0 - 1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0 + input.extent.0) - 1) >= ((input.min.0.required + input.extent.0.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) - 1), ", which is beyond the max (", ((input.min.0 + input.extent.0) - 1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) - 2), (input.extent.1 - 1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1 + input.extent.1) - 1) >= ((input.min.1.required + input.extent.1.required) - 1)), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) - 1), ", which is beyond the max (", ((input.min.1 + input.extent.1) - 1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", (min(output.s0.x.min, (output.s0.x.max + -15)) + (0 + 0)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0 + output.extent.0) - 1) >= ((output.min.0.required + output.extent.0.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) - 1), ", which is beyond the max (", ((output.min.0 + output.extent.0) - 1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", (min(output.s0.y.min, (output.s0.y.max + -15)) + 0), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1 + output.extent.1) - 1) >= ((output.min.1.required + output.extent.1.required) - 1)), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) - 1), ", which is beyond the max (", ((output.min.1 + output.extent.1) - 1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max + 1) - blur.s0.y.min)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max + 1) - blur.s0.x.min)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128) - 1)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = (128 - 1)
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8) - 1)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = (8 - 1)
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8) - 1)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = (8 - 1)
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + (1 - 8)))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + (1 - 128)))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = float32(0)
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max + 1) - blur.s1.y.min)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max + 1) - blur.s1.x.min)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              let blur.s1.i0.y$r.max_1 = blur.s1.i0.y$r
              let blur.s1.i0.y$r.min_1 = blur.s1.i0.y$r
              let blur.s1.i0.x$r.max_1 = blur.s1.i0.x$r
              let blur.s1.i0.x$r.min_1 = blur.s1.i0.x$r
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) - 2), (input.extent.0 - 1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) - 2), (input.extent.1 - 1)), 0)))/65535.000000f))/float32(273)))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max + 1) - output.s0.y.min)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max + 1) - output.s0.x.min)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16) - 1)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = (16 - 1)
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8) - 1)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = (8 - 1)
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16) - 1)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = (16 - 1)
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + (1 - 16)))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + (1 - 16)))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}

Simplifying...
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
i0.min.0.required not in scope, so leaving it as-is
i0.min.0.proposed not in scope, so leaving it as-is
i0.min.0.proposed not in scope, so leaving it as-is
i0.extent.0.proposed not in scope, so leaving it as-is
i0.min.0.required not in scope, so leaving it as-is
i0.extent.0.required not in scope, so leaving it as-is
i0.min.0.proposed not in scope, so leaving it as-is
i0.extent.0.proposed not in scope, so leaving it as-is
i0.min.0.required not in scope, so leaving it as-is
i0.extent.0.required not in scope, so leaving it as-is
i0.min.1.required not in scope, so leaving it as-is
i0.min.1.proposed not in scope, so leaving it as-is
i0.min.1.proposed not in scope, so leaving it as-is
i0.extent.1.proposed not in scope, so leaving it as-is
i0.min.1.required not in scope, so leaving it as-is
i0.extent.1.required not in scope, so leaving it as-is
i0.min.1.proposed not in scope, so leaving it as-is
i0.extent.1.proposed not in scope, so leaving it as-is
i0.min.1.required not in scope, so leaving it as-is
i0.extent.1.required not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.min.0.proposed not in scope, so leaving it as-is
input.min.0.proposed not in scope, so leaving it as-is
input.extent.0.proposed not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required not in scope, so leaving it as-is
input.min.0.proposed not in scope, so leaving it as-is
input.extent.0.proposed not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.min.1.proposed not in scope, so leaving it as-is
input.min.1.proposed not in scope, so leaving it as-is
input.extent.1.proposed not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required not in scope, so leaving it as-is
input.min.1.proposed not in scope, so leaving it as-is
input.extent.1.proposed not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.min.0.proposed not in scope, so leaving it as-is
output.min.0.proposed not in scope, so leaving it as-is
output.extent.0.proposed not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required not in scope, so leaving it as-is
output.min.0.proposed not in scope, so leaving it as-is
output.extent.0.proposed not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.min.1.proposed not in scope, so leaving it as-is
output.min.1.proposed not in scope, so leaving it as-is
output.extent.1.proposed not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required not in scope, so leaving it as-is
output.min.1.proposed not in scope, so leaving it as-is
output.extent.1.proposed not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required not in scope, so leaving it as-is
i0.elem_size not in scope, so leaving it as-is
input.elem_size not in scope, so leaving it as-is
output.elem_size not in scope, so leaving it as-is
i0.min.0.required not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.0.required not in scope, so leaving it as-is
i0.extent.0.required not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.0.required not in scope, so leaving it as-is
i0.extent.0.required not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.0.required not in scope, so leaving it as-is
i0.extent.0.required not in scope, so leaving it as-is
i0.min.1.required not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
i0.min.1.required not in scope, so leaving it as-is
i0.extent.1.required not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
i0.min.1.required not in scope, so leaving it as-is
i0.extent.1.required not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
i0.min.1.required not in scope, so leaving it as-is
i0.extent.1.required not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required not in scope, so leaving it as-is
i0.stride.0 not in scope, so leaving it as-is
i0.stride.0.constrained not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.min.0.constrained not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.extent.0.constrained not in scope, so leaving it as-is
i0.stride.1 not in scope, so leaving it as-is
i0.stride.1.constrained not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.min.1.constrained not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
i0.extent.1.constrained not in scope, so leaving it as-is
input.stride.0 not in scope, so leaving it as-is
input.stride.0.constrained not in scope, so leaving it as-is
output.stride.0 not in scope, so leaving it as-is
output.stride.0.constrained not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
blur.s0.y.max not in scope, so leaving it as-is
blur.s0.y.min not in scope, so leaving it as-is
output.s0.y.max not in scope, so leaving it as-is
output.s0.y.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
blur.s0.x.max not in scope, so leaving it as-is
blur.s0.x.min not in scope, so leaving it as-is
output.s0.x.max not in scope, so leaving it as-is
output.s0.x.min not in scope, so leaving it as-is
blur.s0.x.loop_max not in scope, so leaving it as-is
blur.s0.x.loop_min not in scope, so leaving it as-is
blur.s0.x.loop_max not in scope, so leaving it as-is
blur.s0.x.loop_min not in scope, so leaving it as-is
blur.s0.x.loop_max not in scope, so leaving it as-is
blur.s0.x.loop_min not in scope, so leaving it as-is
blur.s0.x.loop_max not in scope, so leaving it as-is
blur.s0.x.loop_min not in scope, so leaving it as-is
blur.s0.s1.loop_max not in scope, so leaving it as-is
blur.s0.s1.loop_min not in scope, so leaving it as-is
blur.s0.s1.loop_max not in scope, so leaving it as-is
blur.s0.s1.loop_min not in scope, so leaving it as-is
blur.s0.s1.loop_max not in scope, so leaving it as-is
blur.s0.s1.loop_min not in scope, so leaving it as-is
blur.s0.s1.loop_max not in scope, so leaving it as-is
blur.s0.s1.loop_min not in scope, so leaving it as-is
blur.s0.y.loop_max not in scope, so leaving it as-is
blur.s0.y.loop_min not in scope, so leaving it as-is
blur.s0.y.loop_max not in scope, so leaving it as-is
blur.s0.y.loop_min not in scope, so leaving it as-is
blur.s0.y.loop_max not in scope, so leaving it as-is
blur.s0.y.loop_min not in scope, so leaving it as-is
blur.s0.y.loop_max not in scope, so leaving it as-is
blur.s0.y.loop_min not in scope, so leaving it as-is
output.s0.x.loop_max not in scope, so leaving it as-is
output.s0.x.loop_min not in scope, so leaving it as-is
output.s0.x.loop_max not in scope, so leaving it as-is
output.s0.x.loop_min not in scope, so leaving it as-is
output.s0.x.loop_max not in scope, so leaving it as-is
output.s0.x.loop_min not in scope, so leaving it as-is
output.s0.x.loop_max not in scope, so leaving it as-is
output.s0.x.loop_min not in scope, so leaving it as-is
output.s0.s0.loop_max not in scope, so leaving it as-is
output.s0.s0.loop_min not in scope, so leaving it as-is
output.s0.s0.loop_max not in scope, so leaving it as-is
output.s0.s0.loop_min not in scope, so leaving it as-is
output.s0.s0.loop_max not in scope, so leaving it as-is
output.s0.s0.loop_min not in scope, so leaving it as-is
output.s0.s0.loop_max not in scope, so leaving it as-is
output.s0.s0.loop_min not in scope, so leaving it as-is
output.s0.y.loop_max not in scope, so leaving it as-is
output.s0.y.loop_min not in scope, so leaving it as-is
output.s0.y.loop_max not in scope, so leaving it as-is
output.s0.y.loop_min not in scope, so leaving it as-is
output.s0.y.loop_max not in scope, so leaving it as-is
output.s0.y.loop_min not in scope, so leaving it as-is
output.s0.y.loop_max not in scope, so leaving it as-is
output.s0.y.loop_min not in scope, so leaving it as-is
Lowering after first simplification:
let output.s0.y.max = ((output.min.1 + output.extent.1) + -1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) + -1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = 4
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = 4
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) + -2), (input.extent.0 + -1)), 0) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)) + 1)
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) + -2), (input.extent.1 + -1)), 0) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)) + 1)
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = ((min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max) - min(output.s0.x.min, (output.s0.x.max + -15))) + 1)
let output.min.0.required = min(output.s0.x.min, (output.s0.x.max + -15))
let output.stride.0.required = 1
let output.extent.1.required = ((min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max) - min(output.s0.y.min, (output.s0.y.max + -15))) + 1)
let output.min.1.required = min(output.s0.y.min, (output.s0.y.max + -15))
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && (((i0.min.0.required + i0.extent.0.required) - i0.extent.0.proposed) <= i0.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && (((i0.min.1.required + i0.extent.1.required) - i0.extent.1.proposed) <= i0.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.required + input.extent.0.required) - input.extent.0.proposed) <= input.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.required + input.extent.1.required) - input.extent.1.proposed) <= input.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.required + output.extent.0.required) - output.extent.0.proposed) <= output.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.required + output.extent.1.required) - output.extent.1.proposed) <= output.min.1.proposed))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0.required + i0.extent.0.required) - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) + -1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1.required + i0.extent.1.required) - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) + -1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0.required + input.extent.0.required) - input.extent.0) <= input.min.0), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) + -1), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1.required + input.extent.1.required) - input.extent.1) <= input.min.1), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) + -1), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.s0.x.min, (output.s0.x.max + -15)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0.required + output.extent.0.required) - output.extent.0) <= output.min.0), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) + -1), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.s0.y.min, (output.s0.y.max + -15)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1.required + output.extent.1.required) - output.extent.1) <= output.min.1), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) + -1), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max - blur.s0.y.min) + 1)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max - blur.s0.x.min) + 1)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((blur.s0.x.loop_max - blur.s0.x.loop_min)/128)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = 127
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((blur.s0.s1.loop_max - blur.s0.s1.loop_min)/8)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = 7
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((blur.s0.y.loop_max - blur.s0.y.loop_min)/8)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = 7
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + -7))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = 0.000000f
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max - blur.s1.y.min) + 1)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max - blur.s1.x.min) + 1)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              let blur.s1.i0.y$r.max_1 = blur.s1.i0.y$r
              let blur.s1.i0.y$r.min_1 = blur.s1.i0.y$r
              let blur.s1.i0.x$r.max_1 = blur.s1.i0.x$r
              let blur.s1.i0.x$r.min_1 = blur.s1.i0.x$r
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)))*0.000015f))*0.003663f))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max - output.s0.y.min) + 1)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max - output.s0.x.min) + 1)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((output.s0.x.loop_max - output.s0.x.loop_min)/16)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = 15
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((output.s0.s0.loop_max - output.s0.s0.loop_min)/8)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = 7
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((output.s0.y.loop_max - output.s0.y.loop_min)/16)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = 15
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + -15))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}


Dynamically skipping stages...
skip_stages checking blur
skip_stages checking floating
skip_stages checking clamped
Lowering after dynamically skipping stages:
let output.s0.y.max = ((output.min.1 + output.extent.1) + -1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) + -1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = 4
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = 4
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) + -2), (input.extent.0 + -1)), 0) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)) + 1)
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) + -2), (input.extent.1 + -1)), 0) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)) + 1)
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = ((min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max) - min(output.s0.x.min, (output.s0.x.max + -15))) + 1)
let output.min.0.required = min(output.s0.x.min, (output.s0.x.max + -15))
let output.stride.0.required = 1
let output.extent.1.required = ((min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max) - min(output.s0.y.min, (output.s0.y.max + -15))) + 1)
let output.min.1.required = min(output.s0.y.min, (output.s0.y.max + -15))
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && (((i0.min.0.required + i0.extent.0.required) - i0.extent.0.proposed) <= i0.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && (((i0.min.1.required + i0.extent.1.required) - i0.extent.1.proposed) <= i0.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.required + input.extent.0.required) - input.extent.0.proposed) <= input.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.required + input.extent.1.required) - input.extent.1.proposed) <= input.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.required + output.extent.0.required) - output.extent.0.proposed) <= output.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.required + output.extent.1.required) - output.extent.1.proposed) <= output.min.1.proposed))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0.required + i0.extent.0.required) - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) + -1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1.required + i0.extent.1.required) - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) + -1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0.required + input.extent.0.required) - input.extent.0) <= input.min.0), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) + -1), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1.required + input.extent.1.required) - input.extent.1) <= input.min.1), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) + -1), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.s0.x.min, (output.s0.x.max + -15)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0.required + output.extent.0.required) - output.extent.0) <= output.min.0), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) + -1), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.s0.y.min, (output.s0.y.max + -15)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1.required + output.extent.1.required) - output.extent.1) <= output.min.1), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) + -1), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  realize blur([blur.x.min_realized, blur.x.extent_realized], [blur.y.min_realized, blur.y.extent_realized]) {
    produce blur {
      let blur.s0.y.loop_max = blur.s0.y.max
      let blur.s0.y.loop_min = blur.s0.y.min
      let blur.s0.y.loop_extent = ((blur.s0.y.max - blur.s0.y.min) + 1)
      let blur.s0.x.loop_max = blur.s0.x.max
      let blur.s0.x.loop_min = blur.s0.x.min
      let blur.s0.x.loop_extent = ((blur.s0.x.max - blur.s0.x.min) + 1)
      let blur.s0.__outermost.loop_extent = 1
      let blur.s0.__outermost.loop_max = 1
      let blur.s0.__outermost.loop_min = 0
      let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
      let blur.s0.x.x.__block_id_x.loop_max = ((blur.s0.x.loop_max - blur.s0.x.loop_min)/128)
      let blur.s0.x.x.__block_id_x.loop_min = 0
      let blur.s0.s1.loop_extent = 128
      let blur.s0.s1.loop_max = 127
      let blur.s0.s1.loop_min = 0
      let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
      let blur.s0.x.x.__thread_id_x.loop_max = ((blur.s0.s1.loop_max - blur.s0.s1.loop_min)/8)
      let blur.s0.x.x.__thread_id_x.loop_min = 0
      let blur.s0.x.v14.loop_extent = 8
      let blur.s0.x.v14.loop_max = 7
      let blur.s0.x.v14.loop_min = 0
      let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
      let blur.s0.y.__block_id_y.loop_max = ((blur.s0.y.loop_max - blur.s0.y.loop_min)/8)
      let blur.s0.y.__block_id_y.loop_min = 0
      let blur.s0.y.__thread_id_y.loop_extent = 8
      let blur.s0.y.__thread_id_y.loop_max = 7
      let blur.s0.y.__thread_id_y.loop_min = 0
      parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
        let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + -7))
        parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
          parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
            parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
              let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
              vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
                let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
                let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
                blur((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)), (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)) = 0.000000f
              }
            }
          }
        }
      }
    } update blur {
      let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
      let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
      let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
      let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
      let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
      let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
      let blur.s1.y.loop_max = blur.s1.y.max
      let blur.s1.y.loop_min = blur.s1.y.min
      let blur.s1.y.loop_extent = ((blur.s1.y.max - blur.s1.y.min) + 1)
      let blur.s1.x.loop_max = blur.s1.x.max
      let blur.s1.x.loop_min = blur.s1.x.min
      let blur.s1.x.loop_extent = ((blur.s1.x.max - blur.s1.x.min) + 1)
      let blur.s1.__outermost.loop_extent = 1
      let blur.s1.__outermost.loop_max = 1
      let blur.s1.__outermost.loop_min = 0
      for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
        for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
          for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
            for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
              let blur.s1.i0.y$r.max_1 = blur.s1.i0.y$r
              let blur.s1.i0.y$r.min_1 = blur.s1.i0.y$r
              let blur.s1.i0.x$r.max_1 = blur.s1.i0.x$r
              let blur.s1.i0.x$r.min_1 = blur.s1.i0.x$r
              blur(blur.s1.x, blur.s1.y) = (blur(blur.s1.x, blur.s1.y) + ((float32(i0(blur.s1.i0.x$r, blur.s1.i0.y$r))*(float32(input(max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0), max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)))*0.000015f))*0.003663f))
            }
          }
        }
      }
    }
    produce output {
      let output.s0.y.loop_max = output.s0.y.max
      let output.s0.y.loop_min = output.s0.y.min
      let output.s0.y.loop_extent = ((output.s0.y.max - output.s0.y.min) + 1)
      let output.s0.x.loop_max = output.s0.x.max
      let output.s0.x.loop_min = output.s0.x.min
      let output.s0.x.loop_extent = ((output.s0.x.max - output.s0.x.min) + 1)
      let output.s0.__outermost.loop_extent = 1
      let output.s0.__outermost.loop_max = 1
      let output.s0.__outermost.loop_min = 0
      let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
      let output.s0.x.x.__block_id_x.loop_max = ((output.s0.x.loop_max - output.s0.x.loop_min)/16)
      let output.s0.x.x.__block_id_x.loop_min = 0
      let output.s0.s0.loop_extent = 16
      let output.s0.s0.loop_max = 15
      let output.s0.s0.loop_min = 0
      let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
      let output.s0.x.x.__thread_id_x.loop_max = ((output.s0.s0.loop_max - output.s0.s0.loop_min)/8)
      let output.s0.x.x.__thread_id_x.loop_min = 0
      let output.s0.x.v15.loop_extent = 8
      let output.s0.x.v15.loop_max = 7
      let output.s0.x.v15.loop_min = 0
      let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
      let output.s0.y.__block_id_y.loop_max = ((output.s0.y.loop_max - output.s0.y.loop_min)/16)
      let output.s0.y.__block_id_y.loop_min = 0
      let output.s0.y.__thread_id_y.loop_extent = 16
      let output.s0.y.__thread_id_y.loop_max = 15
      let output.s0.y.__thread_id_y.loop_min = 0
      parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
        let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + -15))
        parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
          parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
            let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
            parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
              let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
              vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
                let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
                let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
                output((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)) = uint16((max(min(blur((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)), (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)), 1.000000f), 0.000000f)*65535.000000f))
              }
            }
          }
        }
      }
    }
    0
  }
}


Performing storage flattening...
Lowering after storage flattening:
let output.s0.y.max = ((output.min.1 + output.extent.1) + -1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) + -1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = 4
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = 4
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) + -2), (input.extent.0 + -1)), 0) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)) + 1)
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) + -2), (input.extent.1 + -1)), 0) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)) + 1)
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = ((min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max) - min(output.s0.x.min, (output.s0.x.max + -15))) + 1)
let output.min.0.required = min(output.s0.x.min, (output.s0.x.max + -15))
let output.stride.0.required = 1
let output.extent.1.required = ((min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max) - min(output.s0.y.min, (output.s0.y.max + -15))) + 1)
let output.min.1.required = min(output.s0.y.min, (output.s0.y.max + -15))
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && (((i0.min.0.required + i0.extent.0.required) - i0.extent.0.proposed) <= i0.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && (((i0.min.1.required + i0.extent.1.required) - i0.extent.1.proposed) <= i0.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.required + input.extent.0.required) - input.extent.0.proposed) <= input.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.required + input.extent.1.required) - input.extent.1.proposed) <= input.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.required + output.extent.0.required) - output.extent.0.proposed) <= output.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.required + output.extent.1.required) - output.extent.1.proposed) <= output.min.1.proposed))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0.required + i0.extent.0.required) - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) + -1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1.required + i0.extent.1.required) - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) + -1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0.required + input.extent.0.required) - input.extent.0) <= input.min.0), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) + -1), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1.required + input.extent.1.required) - input.extent.1) <= input.min.1), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) + -1), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.s0.x.min, (output.s0.x.max + -15)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0.required + output.extent.0.required) - output.extent.0) <= output.min.0), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) + -1), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.s0.y.min, (output.s0.y.max + -15)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1.required + output.extent.1.required) - output.extent.1) <= output.min.1), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) + -1), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  let blur.extent.0 = blur.x.extent_realized
  let blur.min.0 = blur.x.min_realized
  let blur.extent.1 = blur.y.extent_realized
  let blur.min.1 = blur.y.min_realized
  let blur.stride.0 = 1
  let blur.stride.1 = (blur.stride.0*blur.extent.0)
  allocate blur[float32 * blur.x.extent_realized * blur.y.extent_realized]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.min.0, blur.extent.0, blur.stride.0, blur.min.1, blur.extent.1, blur.stride.1)
  produce blur {
    let blur.s0.y.loop_max = blur.s0.y.max
    let blur.s0.y.loop_min = blur.s0.y.min
    let blur.s0.y.loop_extent = ((blur.s0.y.max - blur.s0.y.min) + 1)
    let blur.s0.x.loop_max = blur.s0.x.max
    let blur.s0.x.loop_min = blur.s0.x.min
    let blur.s0.x.loop_extent = ((blur.s0.x.max - blur.s0.x.min) + 1)
    let blur.s0.__outermost.loop_extent = 1
    let blur.s0.__outermost.loop_max = 1
    let blur.s0.__outermost.loop_min = 0
    let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
    let blur.s0.x.x.__block_id_x.loop_max = ((blur.s0.x.loop_max - blur.s0.x.loop_min)/128)
    let blur.s0.x.x.__block_id_x.loop_min = 0
    let blur.s0.s1.loop_extent = 128
    let blur.s0.s1.loop_max = 127
    let blur.s0.s1.loop_min = 0
    let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
    let blur.s0.x.x.__thread_id_x.loop_max = ((blur.s0.s1.loop_max - blur.s0.s1.loop_min)/8)
    let blur.s0.x.x.__thread_id_x.loop_min = 0
    let blur.s0.x.v14.loop_extent = 8
    let blur.s0.x.v14.loop_max = 7
    let blur.s0.x.v14.loop_min = 0
    let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
    let blur.s0.y.__block_id_y.loop_max = ((blur.s0.y.loop_max - blur.s0.y.loop_min)/8)
    let blur.s0.y.__block_id_y.loop_min = 0
    let blur.s0.y.__thread_id_y.loop_extent = 8
    let blur.s0.y.__thread_id_y.loop_max = 7
    let blur.s0.y.__thread_id_y.loop_min = 0
    parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + -7))
      parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
        let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
        parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
          let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
          parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
            let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
            vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
              let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
              let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
              blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y) - blur.min.1)*blur.stride.1))] = 0.000000f
            }
          }
        }
      }
    }
  } update blur {
    let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
    let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
    let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
    let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
    let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
    let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
    let blur.s1.y.loop_max = blur.s1.y.max
    let blur.s1.y.loop_min = blur.s1.y.min
    let blur.s1.y.loop_extent = ((blur.s1.y.max - blur.s1.y.min) + 1)
    let blur.s1.x.loop_max = blur.s1.x.max
    let blur.s1.x.loop_min = blur.s1.x.min
    let blur.s1.x.loop_extent = ((blur.s1.x.max - blur.s1.x.min) + 1)
    let blur.s1.__outermost.loop_extent = 1
    let blur.s1.__outermost.loop_max = 1
    let blur.s1.__outermost.loop_min = 0
    for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
      for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
        for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
          for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
            let blur.s1.i0.y$r.max_1 = blur.s1.i0.y$r
            let blur.s1.i0.y$r.min_1 = blur.s1.i0.y$r
            let blur.s1.i0.x$r.max_1 = blur.s1.i0.x$r
            let blur.s1.i0.x$r.min_1 = blur.s1.i0.x$r
            blur[((0 + ((blur.s1.x - blur.min.0)*blur.stride.0)) + ((blur.s1.y - blur.min.1)*blur.stride.1))] = (blur[((0 + ((blur.s1.x - blur.min.0)*blur.stride.0)) + ((blur.s1.y - blur.min.1)*blur.stride.1))] + ((float32(i0[(((0 + (blur.s1.i0.x$r*i0.stride.0.constrained)) + (blur.s1.i0.y$r*i0.stride.1.constrained)) - ((0 + (i0.min.0.constrained*i0.stride.0.constrained)) + (i0.min.1.constrained*i0.stride.1.constrained)))])*(float32(input[(((0 + (max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0)*input.stride.0.constrained)) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - ((0 + (input.min.0*input.stride.0.constrained)) + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
  }
  produce output {
    let output.s0.y.loop_max = output.s0.y.max
    let output.s0.y.loop_min = output.s0.y.min
    let output.s0.y.loop_extent = ((output.s0.y.max - output.s0.y.min) + 1)
    let output.s0.x.loop_max = output.s0.x.max
    let output.s0.x.loop_min = output.s0.x.min
    let output.s0.x.loop_extent = ((output.s0.x.max - output.s0.x.min) + 1)
    let output.s0.__outermost.loop_extent = 1
    let output.s0.__outermost.loop_max = 1
    let output.s0.__outermost.loop_min = 0
    let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
    let output.s0.x.x.__block_id_x.loop_max = ((output.s0.x.loop_max - output.s0.x.loop_min)/16)
    let output.s0.x.x.__block_id_x.loop_min = 0
    let output.s0.s0.loop_extent = 16
    let output.s0.s0.loop_max = 15
    let output.s0.s0.loop_min = 0
    let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
    let output.s0.x.x.__thread_id_x.loop_max = ((output.s0.s0.loop_max - output.s0.s0.loop_min)/8)
    let output.s0.x.x.__thread_id_x.loop_min = 0
    let output.s0.x.v15.loop_extent = 8
    let output.s0.x.v15.loop_max = 7
    let output.s0.x.v15.loop_min = 0
    let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
    let output.s0.y.__block_id_y.loop_max = ((output.s0.y.loop_max - output.s0.y.loop_min)/16)
    let output.s0.y.__block_id_y.loop_min = 0
    let output.s0.y.__thread_id_y.loop_extent = 16
    let output.s0.y.__thread_id_y.loop_max = 15
    let output.s0.y.__thread_id_y.loop_min = 0
    parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + -15))
      parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
        parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
          let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
          parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
            let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
            vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
              let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
              let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
              output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
  }
  0
}


Injecting host <-> dev buffer copies...
Tracking host <-> dev copies for the following buffers:
blur
i0
input
output
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
At loop level 
do_copies for blur
0, 0
0, 0
0, 1
0, 0
1
At loop level 
do_copies for blur
0, 0
1, 0
1, 0
0, 1
1
Needs copy to host
do_copies for i0
0, 0
1, 0
0, 0
0, 0
0
Needs copy to host
do_copies for input
0, 0
1, 0
0, 0
0, 0
0
Needs copy to host
At loop level 
do_copies for blur
1, 0
0, 1
0, 0
1, 1
1
Needs copy to dev
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 1
0, 0
0
Needs copy to dev
At loop level 
do_copies for blur
1, 1
0, 0
0, 0
1, 1
1
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for blur
1, 1
0, 0
0, 0
1, 1
1
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
1, 0
0, 0
0, 0
1, 0
0
do_copies for input
1, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 1
0, 0
0, 0
0, 1
0
At loop level 
At loop level 
do_copies for i0
0, 0
0, 0
0, 0
1, 0
0
do_copies for input
0, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
0, 0
0, 0
0, 0
1, 0
0
do_copies for input
0, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
0, 0
0, 0
0, 0
1, 0
0
do_copies for input
0, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
0, 0
0, 0
0, 0
1, 0
0
do_copies for input
0, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
0, 0
0, 0
0, 0
1, 0
0
do_copies for input
0, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
0, 0
0, 0
0, 0
1, 0
0
do_copies for input
0, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
0, 0
0, 0
0, 0
1, 0
0
do_copies for input
0, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
0, 0
0, 0
0, 0
1, 0
0
do_copies for input
0, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 0
0, 1
0
At loop level 
do_copies for i0
0, 0
0, 0
0, 0
1, 0
0
do_copies for input
0, 0
0, 0
0, 0
1, 0
0
do_copies for output
0, 0
0, 0
0, 0
0, 1
0
Lowering after injecting host <-> dev buffer copies:
let output.s0.y.max = ((output.min.1 + output.extent.1) + -1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) + -1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = 4
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = 4
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) + -2), (input.extent.0 + -1)), 0) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)) + 1)
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) + -2), (input.extent.1 + -1)), 0) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)) + 1)
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = ((min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max) - min(output.s0.x.min, (output.s0.x.max + -15))) + 1)
let output.min.0.required = min(output.s0.x.min, (output.s0.x.max + -15))
let output.stride.0.required = 1
let output.extent.1.required = ((min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max) - min(output.s0.y.min, (output.s0.y.max + -15))) + 1)
let output.min.1.required = min(output.s0.y.min, (output.s0.y.max + -15))
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && (((i0.min.0.required + i0.extent.0.required) - i0.extent.0.proposed) <= i0.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && (((i0.min.1.required + i0.extent.1.required) - i0.extent.1.proposed) <= i0.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.required + input.extent.0.required) - input.extent.0.proposed) <= input.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.required + input.extent.1.required) - input.extent.1.proposed) <= input.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.required + output.extent.0.required) - output.extent.0.proposed) <= output.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.required + output.extent.1.required) - output.extent.1.proposed) <= output.min.1.proposed))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0.required + i0.extent.0.required) - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) + -1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1.required + i0.extent.1.required) - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) + -1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0.required + input.extent.0.required) - input.extent.0) <= input.min.0), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) + -1), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1.required + input.extent.1.required) - input.extent.1) <= input.min.1), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) + -1), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.s0.x.min, (output.s0.x.max + -15)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0.required + output.extent.0.required) - output.extent.0) <= output.min.0), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) + -1), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.s0.y.min, (output.s0.y.max + -15)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1.required + output.extent.1.required) - output.extent.1) <= output.min.1), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) + -1), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  let blur.extent.0 = blur.x.extent_realized
  let blur.min.0 = blur.x.min_realized
  let blur.extent.1 = blur.y.extent_realized
  let blur.min.1 = blur.y.min_realized
  let blur.stride.0 = 1
  let blur.stride.1 = (blur.stride.0*blur.extent.0)
  allocate blur[float32 * blur.x.extent_realized * blur.y.extent_realized]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.min.0, blur.extent.0, blur.stride.0, blur.min.1, blur.extent.1, blur.stride.1)
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    let blur.s0.y.loop_max = blur.s0.y.max
    let blur.s0.y.loop_min = blur.s0.y.min
    let blur.s0.y.loop_extent = ((blur.s0.y.max - blur.s0.y.min) + 1)
    let blur.s0.x.loop_max = blur.s0.x.max
    let blur.s0.x.loop_min = blur.s0.x.min
    let blur.s0.x.loop_extent = ((blur.s0.x.max - blur.s0.x.min) + 1)
    let blur.s0.__outermost.loop_extent = 1
    let blur.s0.__outermost.loop_max = 1
    let blur.s0.__outermost.loop_min = 0
    let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
    let blur.s0.x.x.__block_id_x.loop_max = ((blur.s0.x.loop_max - blur.s0.x.loop_min)/128)
    let blur.s0.x.x.__block_id_x.loop_min = 0
    let blur.s0.s1.loop_extent = 128
    let blur.s0.s1.loop_max = 127
    let blur.s0.s1.loop_min = 0
    let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
    let blur.s0.x.x.__thread_id_x.loop_max = ((blur.s0.s1.loop_max - blur.s0.s1.loop_min)/8)
    let blur.s0.x.x.__thread_id_x.loop_min = 0
    let blur.s0.x.v14.loop_extent = 8
    let blur.s0.x.v14.loop_max = 7
    let blur.s0.x.v14.loop_min = 0
    let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
    let blur.s0.y.__block_id_y.loop_max = ((blur.s0.y.loop_max - blur.s0.y.loop_min)/8)
    let blur.s0.y.__block_id_y.loop_min = 0
    let blur.s0.y.__thread_id_y.loop_extent = 8
    let blur.s0.y.__thread_id_y.loop_max = 7
    let blur.s0.y.__thread_id_y.loop_min = 0
    parallel (blur.s0.y.__block_id_y, blur.s0.y.__block_id_y.loop_min, blur.s0.y.__block_id_y.loop_extent) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + -7))
      parallel (blur.s0.x.x.__block_id_x, blur.s0.x.x.__block_id_x.loop_min, blur.s0.x.x.__block_id_x.loop_extent) {
        let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
        parallel (blur.s0.y.__thread_id_y, blur.s0.y.__thread_id_y.loop_min, blur.s0.y.__thread_id_y.loop_extent) {
          let blur.s0.y = (blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y)
          parallel (blur.s0.x.x.__thread_id_x, blur.s0.x.x.__thread_id_x.loop_min, blur.s0.x.x.__thread_id_x.loop_extent) {
            let blur.s0.x.v14.base = ((blur.s0.x.x.__thread_id_x*8) + blur.s0.s1.loop_min)
            vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
              let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
              let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
              blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + blur.s0.y.__thread_id_y) - blur.min.1)*blur.stride.1))] = 0.000000f
            }
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
    let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
    let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
    let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
    let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
    let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
    let blur.s1.y.loop_max = blur.s1.y.max
    let blur.s1.y.loop_min = blur.s1.y.min
    let blur.s1.y.loop_extent = ((blur.s1.y.max - blur.s1.y.min) + 1)
    let blur.s1.x.loop_max = blur.s1.x.max
    let blur.s1.x.loop_min = blur.s1.x.min
    let blur.s1.x.loop_extent = ((blur.s1.x.max - blur.s1.x.min) + 1)
    let blur.s1.__outermost.loop_extent = 1
    let blur.s1.__outermost.loop_max = 1
    let blur.s1.__outermost.loop_min = 0
    for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
      for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
        for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
          for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
            let blur.s1.i0.y$r.max_1 = blur.s1.i0.y$r
            let blur.s1.i0.y$r.min_1 = blur.s1.i0.y$r
            let blur.s1.i0.x$r.max_1 = blur.s1.i0.x$r
            let blur.s1.i0.x$r.min_1 = blur.s1.i0.x$r
            blur[((0 + ((blur.s1.x - blur.min.0)*blur.stride.0)) + ((blur.s1.y - blur.min.1)*blur.stride.1))] = (blur[((0 + ((blur.s1.x - blur.min.0)*blur.stride.0)) + ((blur.s1.y - blur.min.1)*blur.stride.1))] + ((float32(i0[(((0 + (blur.s1.i0.x$r*i0.stride.0.constrained)) + (blur.s1.i0.y$r*i0.stride.1.constrained)) - ((0 + (i0.min.0.constrained*i0.stride.0.constrained)) + (i0.min.1.constrained*i0.stride.1.constrained)))])*(float32(input[(((0 + (max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0)*input.stride.0.constrained)) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - ((0 + (input.min.0*input.stride.0.constrained)) + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    let output.s0.y.loop_max = output.s0.y.max
    let output.s0.y.loop_min = output.s0.y.min
    let output.s0.y.loop_extent = ((output.s0.y.max - output.s0.y.min) + 1)
    let output.s0.x.loop_max = output.s0.x.max
    let output.s0.x.loop_min = output.s0.x.min
    let output.s0.x.loop_extent = ((output.s0.x.max - output.s0.x.min) + 1)
    let output.s0.__outermost.loop_extent = 1
    let output.s0.__outermost.loop_max = 1
    let output.s0.__outermost.loop_min = 0
    let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
    let output.s0.x.x.__block_id_x.loop_max = ((output.s0.x.loop_max - output.s0.x.loop_min)/16)
    let output.s0.x.x.__block_id_x.loop_min = 0
    let output.s0.s0.loop_extent = 16
    let output.s0.s0.loop_max = 15
    let output.s0.s0.loop_min = 0
    let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
    let output.s0.x.x.__thread_id_x.loop_max = ((output.s0.s0.loop_max - output.s0.s0.loop_min)/8)
    let output.s0.x.x.__thread_id_x.loop_min = 0
    let output.s0.x.v15.loop_extent = 8
    let output.s0.x.v15.loop_max = 7
    let output.s0.x.v15.loop_min = 0
    let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
    let output.s0.y.__block_id_y.loop_max = ((output.s0.y.loop_max - output.s0.y.loop_min)/16)
    let output.s0.y.__block_id_y.loop_min = 0
    let output.s0.y.__thread_id_y.loop_extent = 16
    let output.s0.y.__thread_id_y.loop_max = 15
    let output.s0.y.__thread_id_y.loop_min = 0
    parallel (output.s0.y.__block_id_y, output.s0.y.__block_id_y.loop_min, output.s0.y.__block_id_y.loop_extent) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.s0.y.loop_min), (output.s0.y.loop_max + -15))
      parallel (output.s0.x.x.__block_id_x, output.s0.x.x.__block_id_x.loop_min, output.s0.x.x.__block_id_x.loop_extent) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
        parallel (output.s0.y.__thread_id_y, output.s0.y.__thread_id_y.loop_min, output.s0.y.__thread_id_y.loop_extent) {
          let output.s0.y = (output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)
          parallel (output.s0.x.x.__thread_id_x, output.s0.x.x.__thread_id_x.loop_min, output.s0.x.x.__thread_id_x.loop_extent) {
            let output.s0.x.v15.base = ((output.s0.x.x.__thread_id_x*8) + output.s0.s0.loop_min)
            vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
              let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
              let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
              output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y)*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + output.s0.y.__thread_id_y) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Injecting per-block gpu synchronization...
blur.s0.y.__block_id_y.loop_extent not in scope, so leaving it as-is
blur.s0.x.x.__block_id_x.loop_extent not in scope, so leaving it as-is
blur.s0.x.x.__block_id_x not in scope, so leaving it as-is
blur.s0.x.x.__block_id_x.loop_min not in scope, so leaving it as-is
blur.s0.x.loop_min not in scope, so leaving it as-is
blur.s0.x.loop_max not in scope, so leaving it as-is
Bounds of min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
blur.s0.y.__thread_id_y.loop_extent not in scope, so leaving it as-is
blur.s0.y.__thread_id_y.base not in scope, so leaving it as-is
blur.s0.y.__thread_id_y.loop_min not in scope, so leaving it as-is
blur.s0.x.x.__thread_id_x.loop_extent not in scope, so leaving it as-is
blur.s0.x.x.__thread_id_x.loop_min not in scope, so leaving it as-is
blur.s0.s1.loop_min not in scope, so leaving it as-is
blur.s0.x.v14.loop_extent not in scope, so leaving it as-is
blur.s0.x.v14.loop_min not in scope, so leaving it as-is
blur.s0.x.x.__thread_id_x.loop_extent not in scope, so leaving it as-is
blur.s0.y.__thread_id_y.loop_extent not in scope, so leaving it as-is
Fusing thread block:
let blur.s0.s1.base = min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
parallel (blur.s0.y.__thread_id_y, 0, blur.s0.y.__thread_id_y.loop_extent) {
  let blur.s0.y = (blur.s0.y.__thread_id_y.base + (blur.s0.y.__thread_id_y + blur.s0.y.__thread_id_y.loop_min))
  parallel (blur.s0.x.x.__thread_id_x, 0, blur.s0.x.x.__thread_id_x.loop_extent) {
    let blur.s0.x.v14.base = (((blur.s0.x.x.__thread_id_x + blur.s0.x.x.__thread_id_x.loop_min)*8) + blur.s0.s1.loop_min)
    vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
      let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
      let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
      blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + (blur.s0.y.__thread_id_y + blur.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))] = 0.000000f
    }
  }
}


Normalized dimensionality:
let blur.s0.s1.base = min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
parallel (blur.s0.y.__thread_id_y, 0, blur.s0.y.__thread_id_y.loop_extent) {
  let blur.s0.y = (blur.s0.y.__thread_id_y.base + (blur.s0.y.__thread_id_y + blur.s0.y.__thread_id_y.loop_min))
  parallel (blur.s0.x.x.__thread_id_x, 0, blur.s0.x.x.__thread_id_x.loop_extent) {
    let blur.s0.x.v14.base = (((blur.s0.x.x.__thread_id_x + blur.s0.x.x.__thread_id_x.loop_min)*8) + blur.s0.s1.loop_min)
    vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
      let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
      let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
      blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + (blur.s0.y.__thread_id_y + blur.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))] = 0.000000f
    }
  }
}


blur.s0.x.x.__block_id_x not in scope, so leaving it as-is
blur.s0.x.x.__block_id_x.loop_min not in scope, so leaving it as-is
blur.s0.x.loop_min not in scope, so leaving it as-is
blur.s0.x.loop_max not in scope, so leaving it as-is
Bounds of min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
blur.s0.x.v14.loop_min not in scope, so leaving it as-is
blur.s0.x.v14.loop_extent not in scope, so leaving it as-is
Pulled out shared allocations:
let blur.s0.s1.base = min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
parallel (blur.s0.y.__thread_id_y, 0, blur.s0.y.__thread_id_y.loop_extent) {
  let blur.s0.y = (blur.s0.y.__thread_id_y.base + (blur.s0.y.__thread_id_y + blur.s0.y.__thread_id_y.loop_min))
  parallel (blur.s0.x.x.__thread_id_x, 0, blur.s0.x.x.__thread_id_x.loop_extent) {
    let blur.s0.x.v14.base = (((blur.s0.x.x.__thread_id_x + blur.s0.x.x.__thread_id_x.loop_min)*8) + blur.s0.s1.loop_min)
    vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
      let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
      let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
      blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + (blur.s0.y.__thread_id_y + blur.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))] = 0.000000f
    }
  }
}


Injected synchronization:
let blur.s0.s1.base = min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
parallel (blur.s0.y.__thread_id_y, 0, blur.s0.y.__thread_id_y.loop_extent) {
  let blur.s0.y = (blur.s0.y.__thread_id_y.base + (blur.s0.y.__thread_id_y + blur.s0.y.__thread_id_y.loop_min))
  parallel (blur.s0.x.x.__thread_id_x, 0, blur.s0.x.x.__thread_id_x.loop_extent) {
    let blur.s0.x.v14.base = (((blur.s0.x.x.__thread_id_x + blur.s0.x.x.__thread_id_x.loop_min)*8) + blur.s0.s1.loop_min)
    vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
      let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
      let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
      blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + (blur.s0.y.__thread_id_y + blur.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))] = 0.000000f
    }
  }
}


Replaced for with if:
let blur.s0.s1.base = min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
let blur.s0.y = (blur.s0.y.__thread_id_y.base + (.__thread_id_y + blur.s0.y.__thread_id_y.loop_min))
let blur.s0.x.v14.base = (((.__thread_id_x + blur.s0.x.x.__thread_id_x.loop_min)*8) + blur.s0.s1.loop_min)
vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
  let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
  let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
  blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + (.__thread_id_y + blur.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))] = 0.000000f
}


Rewrapped in for loops:
parallel (.__thread_id_y, 0, blur.s0.y.__thread_id_y.loop_extent) {
  parallel (.__thread_id_x, 0, blur.s0.x.x.__thread_id_x.loop_extent) {
    let blur.s0.s1.base = min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
    let blur.s0.y = (blur.s0.y.__thread_id_y.base + (.__thread_id_y + blur.s0.y.__thread_id_y.loop_min))
    let blur.s0.x.v14.base = (((.__thread_id_x + blur.s0.x.x.__thread_id_x.loop_min)*8) + blur.s0.s1.loop_min)
    vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
      let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
      let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
      blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + (.__thread_id_y + blur.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))] = 0.000000f
    }
  }
}


Add back in shared allocations:
let sentinel.shared_offset = 0
allocate __shared[uint8 * sentinel.shared_offset]
parallel (.__thread_id_y, 0, blur.s0.y.__thread_id_y.loop_extent) {
  parallel (.__thread_id_x, 0, blur.s0.x.x.__thread_id_x.loop_extent) {
    let blur.s0.s1.base = min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
    let blur.s0.y = (blur.s0.y.__thread_id_y.base + (.__thread_id_y + blur.s0.y.__thread_id_y.loop_min))
    let blur.s0.x.v14.base = (((.__thread_id_x + blur.s0.x.x.__thread_id_x.loop_min)*8) + blur.s0.s1.loop_min)
    vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
      let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
      let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
      blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + (.__thread_id_y + blur.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))] = 0.000000f
    }
  }
}


output.s0.y.__block_id_y.loop_extent not in scope, so leaving it as-is
output.s0.x.x.__block_id_x.loop_extent not in scope, so leaving it as-is
output.s0.x.x.__block_id_x not in scope, so leaving it as-is
output.s0.x.x.__block_id_x.loop_min not in scope, so leaving it as-is
output.s0.x.loop_min not in scope, so leaving it as-is
output.s0.x.loop_max not in scope, so leaving it as-is
Bounds of min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
output.s0.y.__thread_id_y.loop_extent not in scope, so leaving it as-is
output.s0.y.__thread_id_y.base not in scope, so leaving it as-is
output.s0.y.__thread_id_y.loop_min not in scope, so leaving it as-is
output.s0.x.x.__thread_id_x.loop_extent not in scope, so leaving it as-is
output.s0.x.x.__thread_id_x.loop_min not in scope, so leaving it as-is
output.s0.s0.loop_min not in scope, so leaving it as-is
output.s0.x.v15.loop_extent not in scope, so leaving it as-is
output.s0.x.v15.loop_min not in scope, so leaving it as-is
output.s0.x.x.__thread_id_x.loop_extent not in scope, so leaving it as-is
output.s0.y.__thread_id_y.loop_extent not in scope, so leaving it as-is
Fusing thread block:
let output.s0.s0.base = min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
parallel (output.s0.y.__thread_id_y, 0, output.s0.y.__thread_id_y.loop_extent) {
  let output.s0.y = (output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min))
  parallel (output.s0.x.x.__thread_id_x, 0, output.s0.x.x.__thread_id_x.loop_extent) {
    let output.s0.x.v15.base = (((output.s0.x.x.__thread_id_x + output.s0.x.x.__thread_id_x.loop_min)*8) + output.s0.s0.loop_min)
    vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
      let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
      let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
      output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min))*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
    }
  }
}


Normalized dimensionality:
let output.s0.s0.base = min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
parallel (output.s0.y.__thread_id_y, 0, output.s0.y.__thread_id_y.loop_extent) {
  let output.s0.y = (output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min))
  parallel (output.s0.x.x.__thread_id_x, 0, output.s0.x.x.__thread_id_x.loop_extent) {
    let output.s0.x.v15.base = (((output.s0.x.x.__thread_id_x + output.s0.x.x.__thread_id_x.loop_min)*8) + output.s0.s0.loop_min)
    vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
      let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
      let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
      output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min))*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
    }
  }
}


output.s0.x.x.__block_id_x not in scope, so leaving it as-is
output.s0.x.x.__block_id_x.loop_min not in scope, so leaving it as-is
output.s0.x.loop_min not in scope, so leaving it as-is
output.s0.x.loop_max not in scope, so leaving it as-is
Bounds of min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
output.s0.x.v15.loop_min not in scope, so leaving it as-is
output.s0.x.v15.loop_extent not in scope, so leaving it as-is
Pulled out shared allocations:
let output.s0.s0.base = min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
parallel (output.s0.y.__thread_id_y, 0, output.s0.y.__thread_id_y.loop_extent) {
  let output.s0.y = (output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min))
  parallel (output.s0.x.x.__thread_id_x, 0, output.s0.x.x.__thread_id_x.loop_extent) {
    let output.s0.x.v15.base = (((output.s0.x.x.__thread_id_x + output.s0.x.x.__thread_id_x.loop_min)*8) + output.s0.s0.loop_min)
    vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
      let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
      let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
      output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min))*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
    }
  }
}


Injected synchronization:
let output.s0.s0.base = min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
parallel (output.s0.y.__thread_id_y, 0, output.s0.y.__thread_id_y.loop_extent) {
  let output.s0.y = (output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min))
  parallel (output.s0.x.x.__thread_id_x, 0, output.s0.x.x.__thread_id_x.loop_extent) {
    let output.s0.x.v15.base = (((output.s0.x.x.__thread_id_x + output.s0.x.x.__thread_id_x.loop_min)*8) + output.s0.s0.loop_min)
    vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
      let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
      let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
      output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min))*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + (output.s0.y.__thread_id_y + output.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
    }
  }
}


Replaced for with if:
let output.s0.s0.base = min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
let output.s0.y = (output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min))
let output.s0.x.v15.base = (((.__thread_id_x + output.s0.x.x.__thread_id_x.loop_min)*8) + output.s0.s0.loop_min)
vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
  let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
  let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
  output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min))*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
}


Rewrapped in for loops:
parallel (.__thread_id_y, 0, output.s0.y.__thread_id_y.loop_extent) {
  parallel (.__thread_id_x, 0, output.s0.x.x.__thread_id_x.loop_extent) {
    let output.s0.s0.base = min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
    let output.s0.y = (output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min))
    let output.s0.x.v15.base = (((.__thread_id_x + output.s0.x.x.__thread_id_x.loop_min)*8) + output.s0.s0.loop_min)
    vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
      let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
      let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
      output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min))*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
    }
  }
}


Add back in shared allocations:
let sentinel.shared_offset = 0
allocate __shared[uint8 * sentinel.shared_offset]
parallel (.__thread_id_y, 0, output.s0.y.__thread_id_y.loop_extent) {
  parallel (.__thread_id_x, 0, output.s0.x.x.__thread_id_x.loop_extent) {
    let output.s0.s0.base = min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
    let output.s0.y = (output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min))
    let output.s0.x.v15.base = (((.__thread_id_x + output.s0.x.x.__thread_id_x.loop_min)*8) + output.s0.s0.loop_min)
    vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
      let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
      let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
      output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min))*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
    }
  }
}


Lowering after injecting per-block gpu synchronization:
let output.s0.y.max = ((output.min.1 + output.extent.1) + -1)
let output.s0.y.min = output.min.1
let output.s0.x.max = ((output.min.0 + output.extent.0) + -1)
let output.s0.x.min = output.min.0
let blur.s1.i0.y$r.max = 4
let blur.s1.i0.y$r.min = 0
let blur.s1.i0.x$r.max = 4
let blur.s1.i0.x$r.min = 0
let blur.s1.y.max = output.s0.y.max
let blur.s1.y.min = output.s0.y.min
let blur.s1.x.max = output.s0.x.max
let blur.s1.x.min = output.s0.x.min
let blur.s0.y.max = blur.s1.y.max
let blur.s0.y.min = blur.s1.y.min
let blur.s0.x.max = blur.s1.x.max
let blur.s0.x.min = blur.s1.x.min
let i0.extent.0.required = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
let i0.min.0.required = blur.s1.i0.x$r.min
let i0.stride.0.required = 1
let i0.extent.1.required = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
let i0.min.1.required = blur.s1.i0.y$r.min
let i0.stride.1.required = (i0.stride.0.required*i0.extent.0.required)
let input.extent.0.required = ((max(min(((blur.s1.x.max + blur.s1.i0.x$r.max) + -2), (input.extent.0 + -1)), 0) - max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)) + 1)
let input.min.0.required = max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0)
let input.stride.0.required = 1
let input.extent.1.required = ((max(min(((blur.s1.y.max + blur.s1.i0.y$r.max) + -2), (input.extent.1 + -1)), 0) - max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)) + 1)
let input.min.1.required = max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0)
let input.stride.1.required = (input.stride.0.required*input.extent.0.required)
let output.extent.0.required = ((min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max) - min(output.s0.x.min, (output.s0.x.max + -15))) + 1)
let output.min.0.required = min(output.s0.x.min, (output.s0.x.max + -15))
let output.stride.0.required = 1
let output.extent.1.required = ((min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max) - min(output.s0.y.min, (output.s0.y.max + -15))) + 1)
let output.min.1.required = min(output.s0.y.min, (output.s0.y.max + -15))
let output.stride.1.required = (output.stride.0.required*output.extent.0.required)
let i0.stride.0.constrained = 1
let i0.min.0.constrained = 0
let i0.extent.0.constrained = 5
let i0.stride.1.constrained = 5
let i0.min.1.constrained = 0
let i0.extent.1.constrained = 5
let input.stride.0.constrained = 1
let output.stride.0.constrained = 1
let i0.stride.0.proposed = 1
let i0.min.0.proposed = 0
let i0.extent.0.proposed = 5
let i0.stride.1.proposed = 5
let i0.min.1.proposed = 0
let i0.extent.1.proposed = 5
let input.stride.0.proposed = 1
let input.min.0.proposed = input.min.0.required
let input.extent.0.proposed = input.extent.0.required
let input.stride.1.proposed = input.stride.1.required
let input.min.1.proposed = input.min.1.required
let input.extent.1.proposed = input.extent.1.required
let output.stride.0.proposed = 1
let output.min.0.proposed = output.min.0.required
let output.extent.0.proposed = output.extent.0.required
let output.stride.1.proposed = output.stride.1.required
let output.min.1.proposed = output.min.1.required
let output.extent.1.proposed = output.extent.1.required
assert((!i0.host_and_dev_are_null || ((i0.min.0.proposed <= i0.min.0.required) && (((i0.min.0.required + i0.extent.0.required) - i0.extent.0.proposed) <= i0.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!i0.host_and_dev_are_null || ((i0.min.1.proposed <= i0.min.1.required) && (((i0.min.1.required + i0.extent.1.required) - i0.extent.1.proposed) <= i0.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.0.proposed <= input.min.0.required) && (((input.min.0.required + input.extent.0.required) - input.extent.0.proposed) <= input.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!input.host_and_dev_are_null || ((input.min.1.proposed <= input.min.1.required) && (((input.min.1.required + input.extent.1.required) - input.extent.1.proposed) <= input.min.1.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.0.proposed <= output.min.0.required) && (((output.min.0.required + output.extent.0.required) - output.extent.0.proposed) <= output.min.0.proposed))), "Applying the constraints to the required region made it smaller")
assert((!output.host_and_dev_are_null || ((output.min.1.proposed <= output.min.1.required) && (((output.min.1.required + output.extent.1.required) - output.extent.1.proposed) <= output.min.1.proposed))), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, i0.min.0.proposed, i0.extent.0.proposed, i0.stride.0.proposed, i0.min.1.proposed, i0.extent.1.proposed, i0.stride.1.proposed)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.proposed, input.extent.0.proposed, input.stride.0.proposed, input.min.1.proposed, input.extent.1.proposed, input.stride.1.proposed)
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.proposed, output.extent.0.proposed, output.stride.0.proposed, output.min.1.proposed, output.extent.1.proposed, output.stride.1.proposed)
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= i0.min.0.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.x$r.min, ", which is before the min (", i0.min.0, ") in dimension 0"))
  assert((((i0.min.0.required + i0.extent.0.required) - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at ", ((i0.min.0.required + i0.extent.0.required) + -1), ", which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= i0.min.1.required), stringify("Input buffer i0 is accessed at ", blur.s1.i0.y$r.min, ", which is before the min (", i0.min.1, ") in dimension 1"))
  assert((((i0.min.1.required + i0.extent.1.required) - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at ", ((i0.min.1.required + i0.extent.1.required) + -1), ", which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.x.min + blur.s1.i0.x$r.min) + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert((((input.min.0.required + input.extent.0.required) - input.extent.0) <= input.min.0), stringify("Input buffer input is accessed at ", ((input.min.0.required + input.extent.0.required) + -1), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min(((blur.s1.y.min + blur.s1.i0.y$r.min) + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert((((input.min.1.required + input.extent.1.required) - input.extent.1) <= input.min.1), stringify("Input buffer input is accessed at ", ((input.min.1.required + input.extent.1.required) + -1), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.s0.x.min, (output.s0.x.max + -15)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert((((output.min.0.required + output.extent.0.required) - output.extent.0) <= output.min.0), stringify("Output buffer output is accessed at ", ((output.min.0.required + output.extent.0.required) + -1), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.s0.y.min, (output.s0.y.max + -15)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert((((output.min.1.required + output.extent.1.required) - output.extent.1) <= output.min.1), stringify("Output buffer output is accessed at ", ((output.min.1.required + output.extent.1.required) + -1), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == i0.stride.0.constrained), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == i0.min.0.constrained), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == i0.extent.0.constrained), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == i0.stride.1.constrained), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == i0.min.1.constrained), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == i0.extent.1.constrained), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == input.stride.0.constrained), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == output.stride.0.constrained), "Static constraint violated: output.stride.0 == 1")
  let i0.total_extent.0 = int64(i0.extent.0.constrained)
  let i0.total_extent.1 = (int64(i0.extent.1.constrained)*i0.total_extent.0)
  let input.total_extent.0 = int64(input.extent.0)
  let input.total_extent.1 = (int64(input.extent.1)*input.total_extent.0)
  let output.total_extent.0 = int64(output.extent.0)
  let output.total_extent.1 = (int64(output.extent.1)*output.total_extent.0)
  assert(((int64(i0.extent.0.constrained)*int64(i0.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(i0.extent.1.constrained)*int64(i0.stride.1.constrained)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert((i0.total_extent.1 <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert(((int64(input.extent.0)*int64(input.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert(((int64(output.extent.0)*int64(output.stride.0.constrained)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.max_realized = max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max))
  let blur.y.min_realized = min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))
  let blur.y.extent_realized = ((max(max(min((((((blur.s0.y.max - blur.s0.y.min)/8)*8) + blur.s0.y.min) + 7), blur.s0.y.max), blur.s1.y.max), min((((((output.s0.y.max - output.s0.y.min)/16)*16) + output.s0.y.min) + 15), output.s0.y.max)) - min(min(min(blur.s0.y.min, (blur.s0.y.max + -7)), blur.s1.y.min), min(output.s0.y.min, (output.s0.y.max + -15)))) + 1)
  let blur.x.max_realized = max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max))
  let blur.x.min_realized = min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))
  let blur.x.extent_realized = ((max(max(min((((((blur.s0.x.max - blur.s0.x.min)/128)*128) + blur.s0.x.min) + 127), blur.s0.x.max), blur.s1.x.max), min((((((output.s0.x.max - output.s0.x.min)/16)*16) + output.s0.x.min) + 15), output.s0.x.max)) - min(min(min(blur.s0.x.min, (blur.s0.x.max + -127)), blur.s1.x.min), min(output.s0.x.min, (output.s0.x.max + -15)))) + 1)
  let blur.extent.0 = blur.x.extent_realized
  let blur.min.0 = blur.x.min_realized
  let blur.extent.1 = blur.y.extent_realized
  let blur.min.1 = blur.y.min_realized
  let blur.stride.0 = 1
  let blur.stride.1 = (blur.stride.0*blur.extent.0)
  allocate blur[float32 * blur.x.extent_realized * blur.y.extent_realized]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.min.0, blur.extent.0, blur.stride.0, blur.min.1, blur.extent.1, blur.stride.1)
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    let blur.s0.y.loop_max = blur.s0.y.max
    let blur.s0.y.loop_min = blur.s0.y.min
    let blur.s0.y.loop_extent = ((blur.s0.y.max - blur.s0.y.min) + 1)
    let blur.s0.x.loop_max = blur.s0.x.max
    let blur.s0.x.loop_min = blur.s0.x.min
    let blur.s0.x.loop_extent = ((blur.s0.x.max - blur.s0.x.min) + 1)
    let blur.s0.__outermost.loop_extent = 1
    let blur.s0.__outermost.loop_max = 1
    let blur.s0.__outermost.loop_min = 0
    let blur.s0.x.x.__block_id_x.loop_extent = (((blur.s0.x.loop_max - blur.s0.x.loop_min) + 128)/128)
    let blur.s0.x.x.__block_id_x.loop_max = ((blur.s0.x.loop_max - blur.s0.x.loop_min)/128)
    let blur.s0.x.x.__block_id_x.loop_min = 0
    let blur.s0.s1.loop_extent = 128
    let blur.s0.s1.loop_max = 127
    let blur.s0.s1.loop_min = 0
    let blur.s0.x.x.__thread_id_x.loop_extent = (((blur.s0.s1.loop_max - blur.s0.s1.loop_min) + 8)/8)
    let blur.s0.x.x.__thread_id_x.loop_max = ((blur.s0.s1.loop_max - blur.s0.s1.loop_min)/8)
    let blur.s0.x.x.__thread_id_x.loop_min = 0
    let blur.s0.x.v14.loop_extent = 8
    let blur.s0.x.v14.loop_max = 7
    let blur.s0.x.v14.loop_min = 0
    let blur.s0.y.__block_id_y.loop_extent = (((blur.s0.y.loop_max - blur.s0.y.loop_min) + 8)/8)
    let blur.s0.y.__block_id_y.loop_max = ((blur.s0.y.loop_max - blur.s0.y.loop_min)/8)
    let blur.s0.y.__block_id_y.loop_min = 0
    let blur.s0.y.__thread_id_y.loop_extent = 8
    let blur.s0.y.__thread_id_y.loop_max = 7
    let blur.s0.y.__thread_id_y.loop_min = 0
    parallel (blur.s0.y.__block_id_y, 0, blur.s0.y.__block_id_y.loop_extent) {
      let blur.s0.y.__thread_id_y.base = min((((blur.s0.y.__block_id_y + blur.s0.y.__block_id_y.loop_min)*8) + blur.s0.y.loop_min), (blur.s0.y.loop_max + -7))
      parallel (blur.s0.x.x.__block_id_x, 0, blur.s0.x.x.__block_id_x.loop_extent) {
        let sentinel.shared_offset = 0
        allocate __shared[uint8 * sentinel.shared_offset]
        parallel (.__thread_id_y, 0, blur.s0.y.__thread_id_y.loop_extent) {
          parallel (.__thread_id_x, 0, blur.s0.x.x.__thread_id_x.loop_extent) {
            let blur.s0.s1.base = min((((blur.s0.x.x.__block_id_x + blur.s0.x.x.__block_id_x.loop_min)*128) + blur.s0.x.loop_min), (blur.s0.x.loop_max + -127))
            let blur.s0.y = (blur.s0.y.__thread_id_y.base + (.__thread_id_y + blur.s0.y.__thread_id_y.loop_min))
            let blur.s0.x.v14.base = (((.__thread_id_x + blur.s0.x.x.__thread_id_x.loop_min)*8) + blur.s0.s1.loop_min)
            vectorized (blur.s0.x.v14, blur.s0.x.v14.loop_min, blur.s0.x.v14.loop_extent) {
              let blur.s0.x = (blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14))
              let blur.s0.s1 = (blur.s0.x.v14.base + blur.s0.x.v14)
              blur[((0 + (((blur.s0.s1.base + (blur.s0.x.v14.base + blur.s0.x.v14)) - blur.min.0)*blur.stride.0)) + (((blur.s0.y.__thread_id_y.base + (.__thread_id_y + blur.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))] = 0.000000f
            }
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    let blur.s1.i0.y$r.loop_extent = ((blur.s1.i0.y$r.max - blur.s1.i0.y$r.min) + 1)
    let blur.s1.i0.y$r.loop_max = blur.s1.i0.y$r.max
    let blur.s1.i0.y$r.loop_min = blur.s1.i0.y$r.min
    let blur.s1.i0.x$r.loop_extent = ((blur.s1.i0.x$r.max - blur.s1.i0.x$r.min) + 1)
    let blur.s1.i0.x$r.loop_max = blur.s1.i0.x$r.max
    let blur.s1.i0.x$r.loop_min = blur.s1.i0.x$r.min
    let blur.s1.y.loop_max = blur.s1.y.max
    let blur.s1.y.loop_min = blur.s1.y.min
    let blur.s1.y.loop_extent = ((blur.s1.y.max - blur.s1.y.min) + 1)
    let blur.s1.x.loop_max = blur.s1.x.max
    let blur.s1.x.loop_min = blur.s1.x.min
    let blur.s1.x.loop_extent = ((blur.s1.x.max - blur.s1.x.min) + 1)
    let blur.s1.__outermost.loop_extent = 1
    let blur.s1.__outermost.loop_max = 1
    let blur.s1.__outermost.loop_min = 0
    for (blur.s1.y, blur.s1.y.loop_min, blur.s1.y.loop_extent) {
      for (blur.s1.x, blur.s1.x.loop_min, blur.s1.x.loop_extent) {
        for (blur.s1.i0.y$r, blur.s1.i0.y$r.loop_min, blur.s1.i0.y$r.loop_extent) {
          for (blur.s1.i0.x$r, blur.s1.i0.x$r.loop_min, blur.s1.i0.x$r.loop_extent) {
            let blur.s1.i0.y$r.max_1 = blur.s1.i0.y$r
            let blur.s1.i0.y$r.min_1 = blur.s1.i0.y$r
            let blur.s1.i0.x$r.max_1 = blur.s1.i0.x$r
            let blur.s1.i0.x$r.min_1 = blur.s1.i0.x$r
            blur[((0 + ((blur.s1.x - blur.min.0)*blur.stride.0)) + ((blur.s1.y - blur.min.1)*blur.stride.1))] = (blur[((0 + ((blur.s1.x - blur.min.0)*blur.stride.0)) + ((blur.s1.y - blur.min.1)*blur.stride.1))] + ((float32(i0[(((0 + (blur.s1.i0.x$r*i0.stride.0.constrained)) + (blur.s1.i0.y$r*i0.stride.1.constrained)) - ((0 + (i0.min.0.constrained*i0.stride.0.constrained)) + (i0.min.1.constrained*i0.stride.1.constrained)))])*(float32(input[(((0 + (max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0)*input.stride.0.constrained)) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - ((0 + (input.min.0*input.stride.0.constrained)) + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    let output.s0.y.loop_max = output.s0.y.max
    let output.s0.y.loop_min = output.s0.y.min
    let output.s0.y.loop_extent = ((output.s0.y.max - output.s0.y.min) + 1)
    let output.s0.x.loop_max = output.s0.x.max
    let output.s0.x.loop_min = output.s0.x.min
    let output.s0.x.loop_extent = ((output.s0.x.max - output.s0.x.min) + 1)
    let output.s0.__outermost.loop_extent = 1
    let output.s0.__outermost.loop_max = 1
    let output.s0.__outermost.loop_min = 0
    let output.s0.x.x.__block_id_x.loop_extent = (((output.s0.x.loop_max - output.s0.x.loop_min) + 16)/16)
    let output.s0.x.x.__block_id_x.loop_max = ((output.s0.x.loop_max - output.s0.x.loop_min)/16)
    let output.s0.x.x.__block_id_x.loop_min = 0
    let output.s0.s0.loop_extent = 16
    let output.s0.s0.loop_max = 15
    let output.s0.s0.loop_min = 0
    let output.s0.x.x.__thread_id_x.loop_extent = (((output.s0.s0.loop_max - output.s0.s0.loop_min) + 8)/8)
    let output.s0.x.x.__thread_id_x.loop_max = ((output.s0.s0.loop_max - output.s0.s0.loop_min)/8)
    let output.s0.x.x.__thread_id_x.loop_min = 0
    let output.s0.x.v15.loop_extent = 8
    let output.s0.x.v15.loop_max = 7
    let output.s0.x.v15.loop_min = 0
    let output.s0.y.__block_id_y.loop_extent = (((output.s0.y.loop_max - output.s0.y.loop_min) + 16)/16)
    let output.s0.y.__block_id_y.loop_max = ((output.s0.y.loop_max - output.s0.y.loop_min)/16)
    let output.s0.y.__block_id_y.loop_min = 0
    let output.s0.y.__thread_id_y.loop_extent = 16
    let output.s0.y.__thread_id_y.loop_max = 15
    let output.s0.y.__thread_id_y.loop_min = 0
    parallel (output.s0.y.__block_id_y, 0, output.s0.y.__block_id_y.loop_extent) {
      let output.s0.y.__thread_id_y.base = min((((output.s0.y.__block_id_y + output.s0.y.__block_id_y.loop_min)*16) + output.s0.y.loop_min), (output.s0.y.loop_max + -15))
      parallel (output.s0.x.x.__block_id_x, 0, output.s0.x.x.__block_id_x.loop_extent) {
        let sentinel.shared_offset = 0
        allocate __shared[uint8 * sentinel.shared_offset]
        parallel (.__thread_id_y, 0, output.s0.y.__thread_id_y.loop_extent) {
          parallel (.__thread_id_x, 0, output.s0.x.x.__thread_id_x.loop_extent) {
            let output.s0.s0.base = min((((output.s0.x.x.__block_id_x + output.s0.x.x.__block_id_x.loop_min)*16) + output.s0.x.loop_min), (output.s0.x.loop_max + -15))
            let output.s0.y = (output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min))
            let output.s0.x.v15.base = (((.__thread_id_x + output.s0.x.x.__thread_id_x.loop_min)*8) + output.s0.s0.loop_min)
            vectorized (output.s0.x.v15, output.s0.x.v15.loop_min, output.s0.x.v15.loop_extent) {
              let output.s0.x = (output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))
              let output.s0.s0 = (output.s0.x.v15.base + output.s0.x.v15)
              output[(((0 + ((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15))*output.stride.0.constrained)) + ((output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min))*output.stride.1)) - ((0 + (output.min.0*output.stride.0.constrained)) + (output.min.1*output.stride.1)))] = uint16((max(min(blur[((0 + (((output.s0.s0.base + (output.s0.x.v15.base + output.s0.x.v15)) - blur.min.0)*blur.stride.0)) + (((output.s0.y.__thread_id_y.base + (.__thread_id_y + output.s0.y.__thread_id_y.loop_min)) - blur.min.1)*blur.stride.1))], 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Simplifying...
simplify let output.s0.y.max = ((output.min.1 + output.extent.1) + -1) in ... output.s0.y.max ...
new let output.s0.y.max.s = (undefined) in ... ((output.min.1 + output.extent.1) + -1) ...
simplify let output.s0.y.min = output.min.1 in ... output.s0.y.min ...
new let output.s0.y.min.s = (undefined) in ... output.min.1 ...
simplify let output.s0.x.max = ((output.min.0 + output.extent.0) + -1) in ... output.s0.x.max ...
new let output.s0.x.max.s = (undefined) in ... ((output.min.0 + output.extent.0) + -1) ...
simplify let output.s0.x.min = output.min.0 in ... output.s0.x.min ...
new let output.s0.x.min.s = (undefined) in ... output.min.0 ...
simplify let blur.s1.i0.y$r.max = 4 in ... blur.s1.i0.y$r.max ...
new let blur.s1.i0.y$r.max.s = (undefined) in ... 4 ...
simplify let blur.s1.i0.y$r.min = 0 in ... blur.s1.i0.y$r.min ...
new let blur.s1.i0.y$r.min.s = (undefined) in ... 0 ...
simplify let blur.s1.i0.x$r.max = 4 in ... blur.s1.i0.x$r.max ...
new let blur.s1.i0.x$r.max.s = (undefined) in ... 4 ...
simplify let blur.s1.i0.x$r.min = 0 in ... blur.s1.i0.x$r.min ...
new let blur.s1.i0.x$r.min.s = (undefined) in ... 0 ...
simplify let blur.s1.y.max = ((output.min.1 + output.extent.1) + -1) in ... blur.s1.y.max ...
new let blur.s1.y.max.s = (undefined) in ... ((output.min.1 + output.extent.1) + -1) ...
simplify let blur.s1.y.min = output.min.1 in ... blur.s1.y.min ...
new let blur.s1.y.min.s = (undefined) in ... output.min.1 ...
simplify let blur.s1.x.max = ((output.min.0 + output.extent.0) + -1) in ... blur.s1.x.max ...
new let blur.s1.x.max.s = (undefined) in ... ((output.min.0 + output.extent.0) + -1) ...
simplify let blur.s1.x.min = output.min.0 in ... blur.s1.x.min ...
new let blur.s1.x.min.s = (undefined) in ... output.min.0 ...
simplify let blur.s0.y.max = ((output.min.1 + output.extent.1) + -1) in ... blur.s0.y.max ...
new let blur.s0.y.max.s = (undefined) in ... ((output.min.1 + output.extent.1) + -1) ...
simplify let blur.s0.y.min = output.min.1 in ... blur.s0.y.min ...
new let blur.s0.y.min.s = (undefined) in ... output.min.1 ...
simplify let blur.s0.x.max = ((output.min.0 + output.extent.0) + -1) in ... blur.s0.x.max ...
new let blur.s0.x.max.s = (undefined) in ... ((output.min.0 + output.extent.0) + -1) ...
simplify let blur.s0.x.min = output.min.0 in ... blur.s0.x.min ...
new let blur.s0.x.min.s = (undefined) in ... output.min.0 ...
simplify let i0.extent.0.required = 5 in ... i0.extent.0.required ...
new let i0.extent.0.required.s = (undefined) in ... 5 ...
simplify let i0.min.0.required = 0 in ... i0.min.0.required ...
new let i0.min.0.required.s = (undefined) in ... 0 ...
simplify let i0.stride.0.required = 1 in ... i0.stride.0.required ...
new let i0.stride.0.required.s = (undefined) in ... 1 ...
simplify let i0.extent.1.required = 5 in ... i0.extent.1.required ...
new let i0.extent.1.required.s = (undefined) in ... 5 ...
simplify let i0.min.1.required = 0 in ... i0.min.1.required ...
new let i0.min.1.required.s = (undefined) in ... 0 ...
simplify let i0.stride.1.required = 5 in ... i0.stride.1.required ...
new let i0.stride.1.required.s = (undefined) in ... 5 ...
simplify let input.extent.0.required = ((max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)) + 1) in ... input.extent.0.required ...
new let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)) in ... (input.extent.0.required.s + 1) ...
simplify let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0) in ... input.min.0.required ...
simplify let input.stride.0.required = 1 in ... input.stride.0.required ...
new let input.stride.0.required.s = (undefined) in ... 1 ...
simplify let input.extent.1.required = ((max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)) + 1) in ... input.extent.1.required ...
new let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)) in ... (input.extent.1.required.s + 1) ...
simplify let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0) in ... input.min.1.required ...
simplify let input.stride.1.required = (input.extent.0.required.s + 1) in ... input.stride.1.required ...
new let input.stride.1.required.s = (undefined) in ... (input.extent.0.required.s + 1) ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.extent.0.required = ((min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16))) + 1) in ... output.extent.0.required ...
new let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16))) in ... (output.extent.0.required.s + 1) ...
simplify let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16)) in ... output.min.0.required ...
simplify let output.stride.0.required = 1 in ... output.stride.0.required ...
new let output.stride.0.required.s = (undefined) in ... 1 ...
output.extent.1 not in scope, so leaving it as-is
simplify let output.extent.1.required = ((min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16))) + 1) in ... output.extent.1.required ...
new let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16))) in ... (output.extent.1.required.s + 1) ...
simplify let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16)) in ... output.min.1.required ...
simplify let output.stride.1.required = (output.extent.0.required.s + 1) in ... output.stride.1.required ...
new let output.stride.1.required.s = (undefined) in ... (output.extent.0.required.s + 1) ...
simplify let i0.stride.0.constrained = 1 in ... i0.stride.0.constrained ...
new let i0.stride.0.constrained.s = (undefined) in ... 1 ...
simplify let i0.min.0.constrained = 0 in ... i0.min.0.constrained ...
new let i0.min.0.constrained.s = (undefined) in ... 0 ...
simplify let i0.extent.0.constrained = 5 in ... i0.extent.0.constrained ...
new let i0.extent.0.constrained.s = (undefined) in ... 5 ...
simplify let i0.stride.1.constrained = 5 in ... i0.stride.1.constrained ...
new let i0.stride.1.constrained.s = (undefined) in ... 5 ...
simplify let i0.min.1.constrained = 0 in ... i0.min.1.constrained ...
new let i0.min.1.constrained.s = (undefined) in ... 0 ...
simplify let i0.extent.1.constrained = 5 in ... i0.extent.1.constrained ...
new let i0.extent.1.constrained.s = (undefined) in ... 5 ...
simplify let input.stride.0.constrained = 1 in ... input.stride.0.constrained ...
new let input.stride.0.constrained.s = (undefined) in ... 1 ...
simplify let output.stride.0.constrained = 1 in ... output.stride.0.constrained ...
new let output.stride.0.constrained.s = (undefined) in ... 1 ...
simplify let i0.stride.0.proposed = 1 in ... i0.stride.0.proposed ...
new let i0.stride.0.proposed.s = (undefined) in ... 1 ...
simplify let i0.min.0.proposed = 0 in ... i0.min.0.proposed ...
new let i0.min.0.proposed.s = (undefined) in ... 0 ...
simplify let i0.extent.0.proposed = 5 in ... i0.extent.0.proposed ...
new let i0.extent.0.proposed.s = (undefined) in ... 5 ...
simplify let i0.stride.1.proposed = 5 in ... i0.stride.1.proposed ...
new let i0.stride.1.proposed.s = (undefined) in ... 5 ...
simplify let i0.min.1.proposed = 0 in ... i0.min.1.proposed ...
new let i0.min.1.proposed.s = (undefined) in ... 0 ...
simplify let i0.extent.1.proposed = 5 in ... i0.extent.1.proposed ...
new let i0.extent.1.proposed.s = (undefined) in ... 5 ...
simplify let input.stride.0.proposed = 1 in ... input.stride.0.proposed ...
new let input.stride.0.proposed.s = (undefined) in ... 1 ...
simplify let input.min.0.proposed = input.min.0.required in ... input.min.0.proposed ...
new let input.min.0.proposed.s = (undefined) in ... input.min.0.required ...
simplify let input.extent.0.proposed = (input.extent.0.required.s + 1) in ... input.extent.0.proposed ...
new let input.extent.0.proposed.s = (undefined) in ... (input.extent.0.required.s + 1) ...
simplify let input.stride.1.proposed = (input.extent.0.required.s + 1) in ... input.stride.1.proposed ...
new let input.stride.1.proposed.s = (undefined) in ... (input.extent.0.required.s + 1) ...
simplify let input.min.1.proposed = input.min.1.required in ... input.min.1.proposed ...
new let input.min.1.proposed.s = (undefined) in ... input.min.1.required ...
simplify let input.extent.1.proposed = (input.extent.1.required.s + 1) in ... input.extent.1.proposed ...
new let input.extent.1.proposed.s = (undefined) in ... (input.extent.1.required.s + 1) ...
simplify let output.stride.0.proposed = 1 in ... output.stride.0.proposed ...
new let output.stride.0.proposed.s = (undefined) in ... 1 ...
simplify let output.min.0.proposed = output.min.0.required in ... output.min.0.proposed ...
new let output.min.0.proposed.s = (undefined) in ... output.min.0.required ...
simplify let output.extent.0.proposed = (output.extent.0.required.s + 1) in ... output.extent.0.proposed ...
new let output.extent.0.proposed.s = (undefined) in ... (output.extent.0.required.s + 1) ...
simplify let output.stride.1.proposed = (output.extent.0.required.s + 1) in ... output.stride.1.proposed ...
new let output.stride.1.proposed.s = (undefined) in ... (output.extent.0.required.s + 1) ...
simplify let output.min.1.proposed = output.min.1.required in ... output.min.1.proposed ...
new let output.min.1.proposed.s = (undefined) in ... output.min.1.required ...
simplify let output.extent.1.proposed = (output.extent.1.required.s + 1) in ... output.extent.1.proposed ...
new let output.extent.1.proposed.s = (undefined) in ... (output.extent.1.required.s + 1) ...
i0.elem_size not in scope, so leaving it as-is
input.elem_size not in scope, so leaving it as-is
output.elem_size not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required.s not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required.s not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required.s not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required.s not in scope, so leaving it as-is
i0.stride.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.stride.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.stride.0 not in scope, so leaving it as-is
output.stride.0 not in scope, so leaving it as-is
simplify let i0.total_extent.0 = int64(5) in ... i0.total_extent.0 ...
new let i0.total_extent.0.s = (undefined) in ... int64(5) ...
simplify let i0.total_extent.1 = (int64(5)*int64(5)) in ... i0.total_extent.1 ...
new let i0.total_extent.1.s = (undefined) in ... (int64(5)*int64(5)) ...
simplify let input.total_extent.0 = int64(input.extent.0) in ... input.total_extent.0 ...
new let input.total_extent.0.s = (undefined) in ... int64(input.extent.0) ...
simplify let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0)) in ... input.total_extent.1 ...
simplify let output.total_extent.0 = int64(output.extent.0) in ... output.total_extent.0 ...
new let output.total_extent.0.s = (undefined) in ... int64(output.extent.0) ...
simplify let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0)) in ... output.total_extent.1 ...
output.extent.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let blur.y.max_realized = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) in ... blur.y.max_realized ...
simplify let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1) in ... blur.y.min_realized ...
output.extent.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let blur.y.extent_realized = ((max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) - min(((output.min.1 + output.extent.1) + -16), output.min.1)) + 1) in ... blur.y.extent_realized ...
new let blur.y.extent_realized.s = (max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) - min(((output.min.1 + output.extent.1) + -16), output.min.1)) in ... (blur.y.extent_realized.s + 1) ...
output.extent.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
simplify let blur.x.max_realized = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) in ... blur.x.max_realized ...
simplify let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0) in ... blur.x.min_realized ...
output.extent.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
simplify let blur.x.extent_realized = ((max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) - min(((output.min.0 + output.extent.0) + -128), output.min.0)) + 1) in ... blur.x.extent_realized ...
new let blur.x.extent_realized.s = (max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) - min(((output.min.0 + output.extent.0) + -128), output.min.0)) in ... (blur.x.extent_realized.s + 1) ...
simplify let blur.extent.0 = (blur.x.extent_realized.s + 1) in ... blur.extent.0 ...
new let blur.extent.0.s = (undefined) in ... (blur.x.extent_realized.s + 1) ...
simplify let blur.min.0 = blur.x.min_realized in ... blur.min.0 ...
new let blur.min.0.s = (undefined) in ... blur.x.min_realized ...
simplify let blur.extent.1 = (blur.y.extent_realized.s + 1) in ... blur.extent.1 ...
new let blur.extent.1.s = (undefined) in ... (blur.y.extent_realized.s + 1) ...
simplify let blur.min.1 = blur.y.min_realized in ... blur.min.1 ...
new let blur.min.1.s = (undefined) in ... blur.y.min_realized ...
simplify let blur.stride.0 = 1 in ... blur.stride.0 ...
new let blur.stride.0.s = (undefined) in ... 1 ...
simplify let blur.stride.1 = (blur.x.extent_realized.s + 1) in ... blur.stride.1 ...
new let blur.stride.1.s = (undefined) in ... (blur.x.extent_realized.s + 1) ...
simplify let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, (blur.x.extent_realized.s + 1), 1, blur.y.min_realized, (blur.y.extent_realized.s + 1), (blur.x.extent_realized.s + 1)) in ... blur.buffer ...
blur.buffer not in scope, so leaving it as-is
simplify let blur.s0.y.loop_max = ((output.min.1 + output.extent.1) + -1) in ... blur.s0.y.loop_max ...
new let blur.s0.y.loop_max.s = (undefined) in ... ((output.min.1 + output.extent.1) + -1) ...
simplify let blur.s0.y.loop_min = output.min.1 in ... blur.s0.y.loop_min ...
new let blur.s0.y.loop_min.s = (undefined) in ... output.min.1 ...
simplify let blur.s0.y.loop_extent = output.extent.1 in ... blur.s0.y.loop_extent ...
new let blur.s0.y.loop_extent.s = (undefined) in ... output.extent.1 ...
simplify let blur.s0.x.loop_max = ((output.min.0 + output.extent.0) + -1) in ... blur.s0.x.loop_max ...
new let blur.s0.x.loop_max.s = (undefined) in ... ((output.min.0 + output.extent.0) + -1) ...
simplify let blur.s0.x.loop_min = output.min.0 in ... blur.s0.x.loop_min ...
new let blur.s0.x.loop_min.s = (undefined) in ... output.min.0 ...
simplify let blur.s0.x.loop_extent = output.extent.0 in ... blur.s0.x.loop_extent ...
new let blur.s0.x.loop_extent.s = (undefined) in ... output.extent.0 ...
simplify let blur.s0.__outermost.loop_extent = 1 in ... blur.s0.__outermost.loop_extent ...
new let blur.s0.__outermost.loop_extent.s = (undefined) in ... 1 ...
simplify let blur.s0.__outermost.loop_max = 1 in ... blur.s0.__outermost.loop_max ...
new let blur.s0.__outermost.loop_max.s = (undefined) in ... 1 ...
simplify let blur.s0.__outermost.loop_min = 0 in ... blur.s0.__outermost.loop_min ...
new let blur.s0.__outermost.loop_min.s = (undefined) in ... 0 ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.s0.x.x.__block_id_x.loop_extent = ((output.extent.0 + 127)/128) in ... blur.s0.x.x.__block_id_x.loop_extent ...
new let blur.s0.x.x.__block_id_x.loop_extent.s = (undefined) in ... ((output.extent.0 + 127)/128) ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.s0.x.x.__block_id_x.loop_max = ((output.extent.0 + -1)/128) in ... blur.s0.x.x.__block_id_x.loop_max ...
new let blur.s0.x.x.__block_id_x.loop_max.s = (undefined) in ... ((output.extent.0 + -1)/128) ...
simplify let blur.s0.x.x.__block_id_x.loop_min = 0 in ... blur.s0.x.x.__block_id_x.loop_min ...
new let blur.s0.x.x.__block_id_x.loop_min.s = (undefined) in ... 0 ...
simplify let blur.s0.s1.loop_extent = 128 in ... blur.s0.s1.loop_extent ...
new let blur.s0.s1.loop_extent.s = (undefined) in ... 128 ...
simplify let blur.s0.s1.loop_max = 127 in ... blur.s0.s1.loop_max ...
new let blur.s0.s1.loop_max.s = (undefined) in ... 127 ...
simplify let blur.s0.s1.loop_min = 0 in ... blur.s0.s1.loop_min ...
new let blur.s0.s1.loop_min.s = (undefined) in ... 0 ...
simplify let blur.s0.x.x.__thread_id_x.loop_extent = 16 in ... blur.s0.x.x.__thread_id_x.loop_extent ...
new let blur.s0.x.x.__thread_id_x.loop_extent.s = (undefined) in ... 16 ...
simplify let blur.s0.x.x.__thread_id_x.loop_max = 15 in ... blur.s0.x.x.__thread_id_x.loop_max ...
new let blur.s0.x.x.__thread_id_x.loop_max.s = (undefined) in ... 15 ...
simplify let blur.s0.x.x.__thread_id_x.loop_min = 0 in ... blur.s0.x.x.__thread_id_x.loop_min ...
new let blur.s0.x.x.__thread_id_x.loop_min.s = (undefined) in ... 0 ...
simplify let blur.s0.x.v14.loop_extent = 8 in ... blur.s0.x.v14.loop_extent ...
new let blur.s0.x.v14.loop_extent.s = (undefined) in ... 8 ...
simplify let blur.s0.x.v14.loop_max = 7 in ... blur.s0.x.v14.loop_max ...
new let blur.s0.x.v14.loop_max.s = (undefined) in ... 7 ...
simplify let blur.s0.x.v14.loop_min = 0 in ... blur.s0.x.v14.loop_min ...
new let blur.s0.x.v14.loop_min.s = (undefined) in ... 0 ...
output.extent.1 not in scope, so leaving it as-is
simplify let blur.s0.y.__block_id_y.loop_extent = ((output.extent.1 + 7)/8) in ... blur.s0.y.__block_id_y.loop_extent ...
new let blur.s0.y.__block_id_y.loop_extent.s = (undefined) in ... ((output.extent.1 + 7)/8) ...
output.extent.1 not in scope, so leaving it as-is
simplify let blur.s0.y.__block_id_y.loop_max = ((output.extent.1 + -1)/8) in ... blur.s0.y.__block_id_y.loop_max ...
new let blur.s0.y.__block_id_y.loop_max.s = (undefined) in ... ((output.extent.1 + -1)/8) ...
simplify let blur.s0.y.__block_id_y.loop_min = 0 in ... blur.s0.y.__block_id_y.loop_min ...
new let blur.s0.y.__block_id_y.loop_min.s = (undefined) in ... 0 ...
simplify let blur.s0.y.__thread_id_y.loop_extent = 8 in ... blur.s0.y.__thread_id_y.loop_extent ...
new let blur.s0.y.__thread_id_y.loop_extent.s = (undefined) in ... 8 ...
simplify let blur.s0.y.__thread_id_y.loop_max = 7 in ... blur.s0.y.__thread_id_y.loop_max ...
new let blur.s0.y.__thread_id_y.loop_max.s = (undefined) in ... 7 ...
simplify let blur.s0.y.__thread_id_y.loop_min = 0 in ... blur.s0.y.__thread_id_y.loop_min ...
new let blur.s0.y.__thread_id_y.loop_min.s = (undefined) in ... 0 ...
simplify let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8)) in ... blur.s0.y.__thread_id_y.base ...
simplify let sentinel.shared_offset = 0 in ... sentinel.shared_offset ...
new let sentinel.shared_offset.s = (undefined) in ... 0 ...
simplify let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128)) in ... blur.s0.s1.base ...
simplify let blur.s0.y = (blur.s0.y.__thread_id_y.base + .__thread_id_y) in ... blur.s0.y ...
new let blur.s0.y.s = (undefined) in ... (blur.s0.y.__thread_id_y.base + .__thread_id_y) ...
simplify let blur.s0.x.v14.base = (.__thread_id_x*8) in ... blur.s0.x.v14.base ...
new let blur.s0.x.v14.base.s = (undefined) in ... (.__thread_id_x*8) ...
simplify let blur.s0.x = (blur.s0.s1.base + ((.__thread_id_x*8) + blur.s0.x.v14)) in ... blur.s0.x ...
simplify let blur.s0.s1 = ((.__thread_id_x*8) + blur.s0.x.v14) in ... blur.s0.s1 ...
new let blur.s0.s1.s = (undefined) in ... ((.__thread_id_x*8) + blur.s0.x.v14) ...
input.buffer not in scope, so leaving it as-is
i0.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
simplify let blur.s1.i0.y$r.loop_extent = 5 in ... blur.s1.i0.y$r.loop_extent ...
new let blur.s1.i0.y$r.loop_extent.s = (undefined) in ... 5 ...
simplify let blur.s1.i0.y$r.loop_max = 4 in ... blur.s1.i0.y$r.loop_max ...
new let blur.s1.i0.y$r.loop_max.s = (undefined) in ... 4 ...
simplify let blur.s1.i0.y$r.loop_min = 0 in ... blur.s1.i0.y$r.loop_min ...
new let blur.s1.i0.y$r.loop_min.s = (undefined) in ... 0 ...
simplify let blur.s1.i0.x$r.loop_extent = 5 in ... blur.s1.i0.x$r.loop_extent ...
new let blur.s1.i0.x$r.loop_extent.s = (undefined) in ... 5 ...
simplify let blur.s1.i0.x$r.loop_max = 4 in ... blur.s1.i0.x$r.loop_max ...
new let blur.s1.i0.x$r.loop_max.s = (undefined) in ... 4 ...
simplify let blur.s1.i0.x$r.loop_min = 0 in ... blur.s1.i0.x$r.loop_min ...
new let blur.s1.i0.x$r.loop_min.s = (undefined) in ... 0 ...
simplify let blur.s1.y.loop_max = ((output.min.1 + output.extent.1) + -1) in ... blur.s1.y.loop_max ...
new let blur.s1.y.loop_max.s = (undefined) in ... ((output.min.1 + output.extent.1) + -1) ...
simplify let blur.s1.y.loop_min = output.min.1 in ... blur.s1.y.loop_min ...
new let blur.s1.y.loop_min.s = (undefined) in ... output.min.1 ...
simplify let blur.s1.y.loop_extent = output.extent.1 in ... blur.s1.y.loop_extent ...
new let blur.s1.y.loop_extent.s = (undefined) in ... output.extent.1 ...
simplify let blur.s1.x.loop_max = ((output.min.0 + output.extent.0) + -1) in ... blur.s1.x.loop_max ...
new let blur.s1.x.loop_max.s = (undefined) in ... ((output.min.0 + output.extent.0) + -1) ...
simplify let blur.s1.x.loop_min = output.min.0 in ... blur.s1.x.loop_min ...
new let blur.s1.x.loop_min.s = (undefined) in ... output.min.0 ...
simplify let blur.s1.x.loop_extent = output.extent.0 in ... blur.s1.x.loop_extent ...
new let blur.s1.x.loop_extent.s = (undefined) in ... output.extent.0 ...
simplify let blur.s1.__outermost.loop_extent = 1 in ... blur.s1.__outermost.loop_extent ...
new let blur.s1.__outermost.loop_extent.s = (undefined) in ... 1 ...
simplify let blur.s1.__outermost.loop_max = 1 in ... blur.s1.__outermost.loop_max ...
new let blur.s1.__outermost.loop_max.s = (undefined) in ... 1 ...
simplify let blur.s1.__outermost.loop_min = 0 in ... blur.s1.__outermost.loop_min ...
new let blur.s1.__outermost.loop_min.s = (undefined) in ... 0 ...
simplify let blur.s1.i0.y$r.max_1 = blur.s1.i0.y$r in ... blur.s1.i0.y$r.max_1 ...
new let blur.s1.i0.y$r.max_1.s = (undefined) in ... blur.s1.i0.y$r ...
simplify let blur.s1.i0.y$r.min_1 = blur.s1.i0.y$r in ... blur.s1.i0.y$r.min_1 ...
new let blur.s1.i0.y$r.min_1.s = (undefined) in ... blur.s1.i0.y$r ...
simplify let blur.s1.i0.x$r.max_1 = blur.s1.i0.x$r in ... blur.s1.i0.x$r.max_1 ...
new let blur.s1.i0.x$r.max_1.s = (undefined) in ... blur.s1.i0.x$r ...
simplify let blur.s1.i0.x$r.min_1 = blur.s1.i0.x$r in ... blur.s1.i0.x$r.min_1 ...
new let blur.s1.i0.x$r.min_1.s = (undefined) in ... blur.s1.i0.x$r ...
output.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
simplify let output.s0.y.loop_max = ((output.min.1 + output.extent.1) + -1) in ... output.s0.y.loop_max ...
new let output.s0.y.loop_max.s = (undefined) in ... ((output.min.1 + output.extent.1) + -1) ...
simplify let output.s0.y.loop_min = output.min.1 in ... output.s0.y.loop_min ...
new let output.s0.y.loop_min.s = (undefined) in ... output.min.1 ...
simplify let output.s0.y.loop_extent = output.extent.1 in ... output.s0.y.loop_extent ...
new let output.s0.y.loop_extent.s = (undefined) in ... output.extent.1 ...
simplify let output.s0.x.loop_max = ((output.min.0 + output.extent.0) + -1) in ... output.s0.x.loop_max ...
new let output.s0.x.loop_max.s = (undefined) in ... ((output.min.0 + output.extent.0) + -1) ...
simplify let output.s0.x.loop_min = output.min.0 in ... output.s0.x.loop_min ...
new let output.s0.x.loop_min.s = (undefined) in ... output.min.0 ...
simplify let output.s0.x.loop_extent = output.extent.0 in ... output.s0.x.loop_extent ...
new let output.s0.x.loop_extent.s = (undefined) in ... output.extent.0 ...
simplify let output.s0.__outermost.loop_extent = 1 in ... output.s0.__outermost.loop_extent ...
new let output.s0.__outermost.loop_extent.s = (undefined) in ... 1 ...
simplify let output.s0.__outermost.loop_max = 1 in ... output.s0.__outermost.loop_max ...
new let output.s0.__outermost.loop_max.s = (undefined) in ... 1 ...
simplify let output.s0.__outermost.loop_min = 0 in ... output.s0.__outermost.loop_min ...
new let output.s0.__outermost.loop_min.s = (undefined) in ... 0 ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.s0.x.x.__block_id_x.loop_extent = ((output.extent.0 + 15)/16) in ... output.s0.x.x.__block_id_x.loop_extent ...
new let output.s0.x.x.__block_id_x.loop_extent.s = (undefined) in ... ((output.extent.0 + 15)/16) ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.s0.x.x.__block_id_x.loop_max = ((output.extent.0 + -1)/16) in ... output.s0.x.x.__block_id_x.loop_max ...
new let output.s0.x.x.__block_id_x.loop_max.s = (undefined) in ... ((output.extent.0 + -1)/16) ...
simplify let output.s0.x.x.__block_id_x.loop_min = 0 in ... output.s0.x.x.__block_id_x.loop_min ...
new let output.s0.x.x.__block_id_x.loop_min.s = (undefined) in ... 0 ...
simplify let output.s0.s0.loop_extent = 16 in ... output.s0.s0.loop_extent ...
new let output.s0.s0.loop_extent.s = (undefined) in ... 16 ...
simplify let output.s0.s0.loop_max = 15 in ... output.s0.s0.loop_max ...
new let output.s0.s0.loop_max.s = (undefined) in ... 15 ...
simplify let output.s0.s0.loop_min = 0 in ... output.s0.s0.loop_min ...
new let output.s0.s0.loop_min.s = (undefined) in ... 0 ...
simplify let output.s0.x.x.__thread_id_x.loop_extent = 2 in ... output.s0.x.x.__thread_id_x.loop_extent ...
new let output.s0.x.x.__thread_id_x.loop_extent.s = (undefined) in ... 2 ...
simplify let output.s0.x.x.__thread_id_x.loop_max = 1 in ... output.s0.x.x.__thread_id_x.loop_max ...
new let output.s0.x.x.__thread_id_x.loop_max.s = (undefined) in ... 1 ...
simplify let output.s0.x.x.__thread_id_x.loop_min = 0 in ... output.s0.x.x.__thread_id_x.loop_min ...
new let output.s0.x.x.__thread_id_x.loop_min.s = (undefined) in ... 0 ...
simplify let output.s0.x.v15.loop_extent = 8 in ... output.s0.x.v15.loop_extent ...
new let output.s0.x.v15.loop_extent.s = (undefined) in ... 8 ...
simplify let output.s0.x.v15.loop_max = 7 in ... output.s0.x.v15.loop_max ...
new let output.s0.x.v15.loop_max.s = (undefined) in ... 7 ...
simplify let output.s0.x.v15.loop_min = 0 in ... output.s0.x.v15.loop_min ...
new let output.s0.x.v15.loop_min.s = (undefined) in ... 0 ...
output.extent.1 not in scope, so leaving it as-is
simplify let output.s0.y.__block_id_y.loop_extent = ((output.extent.1 + 15)/16) in ... output.s0.y.__block_id_y.loop_extent ...
new let output.s0.y.__block_id_y.loop_extent.s = (undefined) in ... ((output.extent.1 + 15)/16) ...
output.extent.1 not in scope, so leaving it as-is
simplify let output.s0.y.__block_id_y.loop_max = ((output.extent.1 + -1)/16) in ... output.s0.y.__block_id_y.loop_max ...
new let output.s0.y.__block_id_y.loop_max.s = (undefined) in ... ((output.extent.1 + -1)/16) ...
simplify let output.s0.y.__block_id_y.loop_min = 0 in ... output.s0.y.__block_id_y.loop_min ...
new let output.s0.y.__block_id_y.loop_min.s = (undefined) in ... 0 ...
simplify let output.s0.y.__thread_id_y.loop_extent = 16 in ... output.s0.y.__thread_id_y.loop_extent ...
new let output.s0.y.__thread_id_y.loop_extent.s = (undefined) in ... 16 ...
simplify let output.s0.y.__thread_id_y.loop_max = 15 in ... output.s0.y.__thread_id_y.loop_max ...
new let output.s0.y.__thread_id_y.loop_max.s = (undefined) in ... 15 ...
simplify let output.s0.y.__thread_id_y.loop_min = 0 in ... output.s0.y.__thread_id_y.loop_min ...
new let output.s0.y.__thread_id_y.loop_min.s = (undefined) in ... 0 ...
simplify let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16)) in ... output.s0.y.__thread_id_y.base ...
simplify let sentinel.shared_offset = 0 in ... sentinel.shared_offset ...
new let sentinel.shared_offset.s = (undefined) in ... 0 ...
simplify let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16)) in ... output.s0.s0.base ...
simplify let output.s0.y = (output.s0.y.__thread_id_y.base + .__thread_id_y) in ... output.s0.y ...
new let output.s0.y.s = (undefined) in ... (output.s0.y.__thread_id_y.base + .__thread_id_y) ...
simplify let output.s0.x.v15.base = (.__thread_id_x*8) in ... output.s0.x.v15.base ...
new let output.s0.x.v15.base.s = (undefined) in ... (.__thread_id_x*8) ...
simplify let output.s0.x = (output.s0.s0.base + ((.__thread_id_x*8) + output.s0.x.v15)) in ... output.s0.x ...
simplify let output.s0.s0 = ((.__thread_id_x*8) + output.s0.x.v15) in ... output.s0.s0 ...
new let output.s0.s0.s = (undefined) in ... ((.__thread_id_x*8) + output.s0.x.v15) ...
Lowering after second simplifcation:
let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s = (max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) - blur.y.min_realized)
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s = (max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) - blur.x.min_realized)
  allocate blur[float32 * (blur.x.extent_realized.s + 1) * (blur.y.extent_realized.s + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, (blur.x.extent_realized.s + 1), 1, blur.y.min_realized, (blur.y.extent_realized.s + 1), (blur.x.extent_realized.s + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            vectorized (blur.s0.x.v14, 0, 8) {
              blur[(((blur.s0.s1.base + ((.__thread_id_x*8) + blur.s0.x.v14)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*(blur.x.extent_realized.s + 1)))] = 0.000000f
            }
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*(blur.x.extent_realized.s + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*(blur.x.extent_realized.s + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            vectorized (output.s0.x.v15, 0, 8) {
              output[(((output.s0.s0.base + ((.__thread_id_x*8) + output.s0.x.v15)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1)))] = uint16((max(min(blur[(((output.s0.s0.base + ((.__thread_id_x*8) + output.s0.x.v15)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*(blur.x.extent_realized.s + 1)))], 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Unrolling...
simplify let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)) in ... input.extent.0.required.s ...
simplify let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0) in ... input.min.0.required ...
simplify let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)) in ... input.extent.1.required.s ...
simplify let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0) in ... input.min.1.required ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16))) in ... output.extent.0.required.s ...
simplify let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16)) in ... output.min.0.required ...
output.extent.1 not in scope, so leaving it as-is
simplify let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16))) in ... output.extent.1.required.s ...
simplify let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16)) in ... output.min.1.required ...
i0.elem_size not in scope, so leaving it as-is
input.elem_size not in scope, so leaving it as-is
output.elem_size not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required.s not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required.s not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required.s not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required.s not in scope, so leaving it as-is
i0.stride.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.stride.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.stride.0 not in scope, so leaving it as-is
output.stride.0 not in scope, so leaving it as-is
simplify let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0)) in ... input.total_extent.1 ...
simplify let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0)) in ... output.total_extent.1 ...
simplify let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1) in ... blur.y.min_realized ...
output.extent.1 not in scope, so leaving it as-is
simplify let blur.y.extent_realized.s = (max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) - blur.y.min_realized) in ... blur.y.extent_realized.s ...
new let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) in ... (blur.y.extent_realized.s.s - blur.y.min_realized) ...
simplify let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0) in ... blur.x.min_realized ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.x.extent_realized.s = (max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) - blur.x.min_realized) in ... blur.x.extent_realized.s ...
new let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) in ... (blur.x.extent_realized.s.s - blur.x.min_realized) ...
simplify let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)) in ... blur.buffer ...
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8)) in ... blur.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128)) in ... blur.s0.s1.base ...
input.buffer not in scope, so leaving it as-is
i0.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16)) in ... output.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16)) in ... output.s0.s0.base ...
Lowering after unrolling:
let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            vectorized (blur.s0.x.v14, 0, 8) {
              blur[(((blur.s0.s1.base + ((.__thread_id_x*8) + blur.s0.x.v14)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = 0.000000f
            }
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            vectorized (output.s0.x.v15, 0, 8) {
              output[(((output.s0.s0.base + ((.__thread_id_x*8) + output.s0.x.v15)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1)))] = uint16((max(min(blur[(((output.s0.s0.base + ((.__thread_id_x*8) + output.s0.x.v15)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))], 1.000000f), 0.000000f)*65535.000000f))
            }
          }
        }
      }
    }
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Vectorizing...
simplify let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)) in ... input.extent.0.required.s ...
simplify let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0) in ... input.min.0.required ...
simplify let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)) in ... input.extent.1.required.s ...
simplify let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0) in ... input.min.1.required ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16))) in ... output.extent.0.required.s ...
simplify let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16)) in ... output.min.0.required ...
output.extent.1 not in scope, so leaving it as-is
simplify let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16))) in ... output.extent.1.required.s ...
simplify let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16)) in ... output.min.1.required ...
i0.elem_size not in scope, so leaving it as-is
input.elem_size not in scope, so leaving it as-is
output.elem_size not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required.s not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required.s not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required.s not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required.s not in scope, so leaving it as-is
i0.stride.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.stride.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.stride.0 not in scope, so leaving it as-is
output.stride.0 not in scope, so leaving it as-is
simplify let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0)) in ... input.total_extent.1 ...
simplify let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0)) in ... output.total_extent.1 ...
simplify let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1) in ... blur.y.min_realized ...
output.extent.1 not in scope, so leaving it as-is
simplify let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) in ... blur.y.extent_realized.s.s ...
simplify let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0) in ... blur.x.min_realized ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) in ... blur.x.extent_realized.s.s ...
simplify let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)) in ... blur.buffer ...
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8)) in ... blur.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128)) in ... blur.s0.s1.base ...
simplify let blur.s0.x.v14 = 0 in ... blur.s0.x.v14 ...
new let blur.s0.x.v14.s = (undefined) in ... 0 ...
input.buffer not in scope, so leaving it as-is
i0.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16)) in ... output.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16)) in ... output.s0.s0.base ...
simplify let output.s0.x.v15 = 0 in ... output.s0.x.v15 ...
new let output.s0.x.v15.s = (undefined) in ... 0 ...
Lowering after vectorizing:
let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Detecting vector interleavings...
simplify let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)) in ... input.extent.0.required.s ...
simplify let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0) in ... input.min.0.required ...
simplify let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)) in ... input.extent.1.required.s ...
simplify let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0) in ... input.min.1.required ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16))) in ... output.extent.0.required.s ...
simplify let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16)) in ... output.min.0.required ...
output.extent.1 not in scope, so leaving it as-is
simplify let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16))) in ... output.extent.1.required.s ...
simplify let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16)) in ... output.min.1.required ...
i0.elem_size not in scope, so leaving it as-is
input.elem_size not in scope, so leaving it as-is
output.elem_size not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required.s not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required.s not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required.s not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required.s not in scope, so leaving it as-is
i0.stride.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.stride.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.stride.0 not in scope, so leaving it as-is
output.stride.0 not in scope, so leaving it as-is
simplify let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0)) in ... input.total_extent.1 ...
simplify let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0)) in ... output.total_extent.1 ...
simplify let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1) in ... blur.y.min_realized ...
output.extent.1 not in scope, so leaving it as-is
simplify let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) in ... blur.y.extent_realized.s.s ...
simplify let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0) in ... blur.x.min_realized ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) in ... blur.x.extent_realized.s.s ...
simplify let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)) in ... blur.buffer ...
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8)) in ... blur.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128)) in ... blur.s0.s1.base ...
input.buffer not in scope, so leaving it as-is
i0.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16)) in ... output.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16)) in ... output.s0.s0.base ...
Lowering after rewriting vector interleavings:
let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Specializing clamped ramps...
output.extent.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
simplify let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)) in ... input.extent.0.required.s ...
simplify let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0) in ... input.min.0.required ...
simplify let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)) in ... input.extent.1.required.s ...
simplify let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0) in ... input.min.1.required ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16))) in ... output.extent.0.required.s ...
simplify let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16)) in ... output.min.0.required ...
output.extent.1 not in scope, so leaving it as-is
simplify let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16))) in ... output.extent.1.required.s ...
simplify let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16)) in ... output.min.1.required ...
i0.elem_size not in scope, so leaving it as-is
input.elem_size not in scope, so leaving it as-is
output.elem_size not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required.s not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required.s not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required.s not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required.s not in scope, so leaving it as-is
i0.stride.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.stride.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.stride.0 not in scope, so leaving it as-is
output.stride.0 not in scope, so leaving it as-is
simplify let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0)) in ... input.total_extent.1 ...
simplify let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0)) in ... output.total_extent.1 ...
simplify let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1) in ... blur.y.min_realized ...
output.extent.1 not in scope, so leaving it as-is
simplify let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) in ... blur.y.extent_realized.s.s ...
simplify let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0) in ... blur.x.min_realized ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) in ... blur.x.extent_realized.s.s ...
simplify let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)) in ... blur.buffer ...
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8)) in ... blur.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128)) in ... blur.s0.s1.base ...
input.buffer not in scope, so leaving it as-is
i0.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16)) in ... output.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16)) in ... output.s0.s0.base ...
Lowering after specializing clamped ramps:
let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        allocate __shared[uint8 * 0]
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Specializing branched loops...
simplify let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)) in ... input.extent.0.required.s ...
simplify let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0) in ... input.min.0.required ...
simplify let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)) in ... input.extent.1.required.s ...
simplify let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0) in ... input.min.1.required ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16))) in ... output.extent.0.required.s ...
simplify let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16)) in ... output.min.0.required ...
output.extent.1 not in scope, so leaving it as-is
simplify let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16))) in ... output.extent.1.required.s ...
simplify let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16)) in ... output.min.1.required ...
i0.elem_size not in scope, so leaving it as-is
input.elem_size not in scope, so leaving it as-is
output.elem_size not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required.s not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required.s not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required.s not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required.s not in scope, so leaving it as-is
i0.stride.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.stride.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.stride.0 not in scope, so leaving it as-is
output.stride.0 not in scope, so leaving it as-is
simplify let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0)) in ... input.total_extent.1 ...
simplify let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0)) in ... output.total_extent.1 ...
simplify let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1) in ... blur.y.min_realized ...
output.extent.1 not in scope, so leaving it as-is
simplify let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) in ... blur.y.extent_realized.s.s ...
simplify let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0) in ... blur.x.min_realized ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) in ... blur.x.extent_realized.s.s ...
simplify let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)) in ... blur.buffer ...
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8)) in ... blur.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128)) in ... blur.s0.s1.base ...
input.buffer not in scope, so leaving it as-is
i0.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16)) in ... output.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16)) in ... output.s0.s0.base ...
Lowering after specializing branched loops:
let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Injecting early frees...
Lowering after injecting early frees:
let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Injecting device frees...
Lowering after injecting device frees:
let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Simplifying...



Input to letify (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
Canonical form without lets (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
0: output.min.0, 0
1: output.extent.0, 0
2: (output.min.0 + output.extent.0), 1
3: 1, 0
4: ((output.min.0 + output.extent.0) + 1), 0
5: input.extent.0, 0
6: -1, 0
7: (input.extent.0 + -1), 0
8: min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 1
9: 0, 0
10: max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0), 1
11: -2, 0
12: (output.min.0 + -2), 0
13: min((output.min.0 + -2), (input.extent.0 + -1)), 1
14: max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), 1
15: (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)), 1
With variables (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
With lets: (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))



Input to letify max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
Canonical form without lets max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
0: output.min.0, 0
1: -2, 0
2: (output.min.0 + -2), 0
3: input.extent.0, 0
4: -1, 0
5: (input.extent.0 + -1), 0
6: min((output.min.0 + -2), (input.extent.0 + -1)), 1
7: 0, 0
8: max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), 1
With variables max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
With lets: max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)



Input to letify (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
Canonical form without lets (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
0: output.min.1, 0
1: output.extent.1, 0
2: (output.min.1 + output.extent.1), 1
3: 1, 0
4: ((output.min.1 + output.extent.1) + 1), 0
5: input.extent.1, 0
6: -1, 0
7: (input.extent.1 + -1), 0
8: min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 1
9: 0, 0
10: max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0), 1
11: -2, 0
12: (output.min.1 + -2), 0
13: min((output.min.1 + -2), (input.extent.1 + -1)), 1
14: max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), 1
15: (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)), 1
With variables (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
With lets: (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))



Input to letify max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
Canonical form without lets max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
0: output.min.1, 0
1: -2, 0
2: (output.min.1 + -2), 0
3: input.extent.1, 0
4: -1, 0
5: (input.extent.1 + -1), 0
6: min((output.min.1 + -2), (input.extent.1 + -1)), 1
7: 0, 0
8: max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), 1
With variables max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
With lets: max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)



Input to letify (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
Canonical form without lets (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
0: output.extent.0, 0
1: -1, 0
2: (output.extent.0 + -1), 0
3: 16, 0
4: ((output.extent.0 + -1)/16), 0
5: (((output.extent.0 + -1)/16)*16), 0
6: output.min.0, 0
7: ((((output.extent.0 + -1)/16)*16) + output.min.0), 1
8: 15, 0
9: (((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), 0
10: (output.min.0 + output.extent.0), 2
11: ((output.min.0 + output.extent.0) + -1), 0
12: min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)), 1
13: -16, 0
14: ((output.min.0 + output.extent.0) + -16), 0
15: min(output.min.0, ((output.min.0 + output.extent.0) + -16)), 1
16: (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16))), 1
With variables (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), (t0 + -1)) - min(output.min.0, (t0 + -16)))
With lets: (let t0 = (output.min.0 + output.extent.0) in (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), (t0 + -1)) - min(output.min.0, (t0 + -16))))



Input to letify min(output.min.0, ((output.min.0 + output.extent.0) + -16))
Canonical form without lets min(output.min.0, ((output.min.0 + output.extent.0) + -16))
0: output.min.0, 0
1: output.extent.0, 0
2: (output.min.0 + output.extent.0), 1
3: -16, 0
4: ((output.min.0 + output.extent.0) + -16), 0
5: min(output.min.0, ((output.min.0 + output.extent.0) + -16)), 1
With variables min(output.min.0, ((output.min.0 + output.extent.0) + -16))
With lets: min(output.min.0, ((output.min.0 + output.extent.0) + -16))



Input to letify (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
Canonical form without lets (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
0: output.extent.1, 0
1: -1, 0
2: (output.extent.1 + -1), 0
3: 16, 0
4: ((output.extent.1 + -1)/16), 0
5: (((output.extent.1 + -1)/16)*16), 0
6: output.min.1, 0
7: ((((output.extent.1 + -1)/16)*16) + output.min.1), 1
8: 15, 0
9: (((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), 0
10: (output.min.1 + output.extent.1), 2
11: ((output.min.1 + output.extent.1) + -1), 0
12: min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)), 1
13: -16, 0
14: ((output.min.1 + output.extent.1) + -16), 0
15: min(output.min.1, ((output.min.1 + output.extent.1) + -16)), 1
16: (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16))), 1
With variables (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), (t1 + -1)) - min(output.min.1, (t1 + -16)))
With lets: (let t1 = (output.min.1 + output.extent.1) in (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), (t1 + -1)) - min(output.min.1, (t1 + -16))))



Input to letify min(output.min.1, ((output.min.1 + output.extent.1) + -16))
Canonical form without lets min(output.min.1, ((output.min.1 + output.extent.1) + -16))
0: output.min.1, 0
1: output.extent.1, 0
2: (output.min.1 + output.extent.1), 1
3: -16, 0
4: ((output.min.1 + output.extent.1) + -16), 0
5: min(output.min.1, ((output.min.1 + output.extent.1) + -16)), 1
With variables min(output.min.1, ((output.min.1 + output.extent.1) + -16))
With lets: min(output.min.1, ((output.min.1 + output.extent.1) + -16))



Input to letify rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
Canonical form without lets rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
0: i0.buffer, 0
1: 2, 0
2: 0, 0
3: 5, 0
4: 1, 0
5: rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5), 1
With variables rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
With lets: rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)



Input to letify rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
Canonical form without lets rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
0: input.buffer, 0
1: 2, 0
2: input.min.0.required, 0
3: input.extent.0.required.s, 0
4: 1, 0
5: (input.extent.0.required.s + 1), 0
6: input.min.1.required, 0
7: input.extent.1.required.s, 0
8: (input.extent.1.required.s + 1), 0
9: rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1)), 1
With variables rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
With lets: rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))



Input to letify rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
Canonical form without lets rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
0: output.buffer, 0
1: 2, 0
2: output.min.0.required, 0
3: output.extent.0.required.s, 0
4: 1, 0
5: (output.extent.0.required.s + 1), 0
6: output.min.1.required, 0
7: output.extent.1.required.s, 0
8: (output.extent.1.required.s + 1), 0
9: rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1)), 1
With variables rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
With lets: rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))



Input to letify !((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)
Canonical form without lets !((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)
0: i0.host_and_dev_are_null, 0
1: input.host_and_dev_are_null, 0
2: (i0.host_and_dev_are_null || input.host_and_dev_are_null), 1
3: output.host_and_dev_are_null, 0
4: ((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null), 1
5: !((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null), 1
With variables !((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)
With lets: !((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)



Input to letify (i0.elem_size == 2)
Canonical form without lets (i0.elem_size == 2)
0: i0.elem_size, 0
1: 2, 0
2: (i0.elem_size == 2), 1
With variables (i0.elem_size == 2)
With lets: (i0.elem_size == 2)



Input to letify stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2")
Canonical form without lets stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2")
0: "Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", 0
1: i0.elem_size, 0
2: " instead of 2", 0
3: stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"), 1
With variables stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2")
With lets: stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2")



Input to letify (input.elem_size == 2)
Canonical form without lets (input.elem_size == 2)
0: input.elem_size, 0
1: 2, 0
2: (input.elem_size == 2), 1
With variables (input.elem_size == 2)
With lets: (input.elem_size == 2)



Input to letify stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2")
Canonical form without lets stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2")
0: "Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", 0
1: input.elem_size, 0
2: " instead of 2", 0
3: stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"), 1
With variables stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2")
With lets: stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2")



Input to letify (output.elem_size == 2)
Canonical form without lets (output.elem_size == 2)
0: output.elem_size, 0
1: 2, 0
2: (output.elem_size == 2), 1
With variables (output.elem_size == 2)
With lets: (output.elem_size == 2)



Input to letify stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2")
Canonical form without lets stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2")
0: "Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", 0
1: output.elem_size, 0
2: " instead of 2", 0
3: stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"), 1
With variables stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2")
With lets: stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2")



Input to letify (i0.min.0 <= 0)
Canonical form without lets (i0.min.0 <= 0)
0: i0.min.0, 0
1: 0, 0
2: (i0.min.0 <= 0), 1
With variables (i0.min.0 <= 0)
With lets: (i0.min.0 <= 0)



Input to letify stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0")
Canonical form without lets stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0")
0: "Input buffer i0 is accessed at 0, which is before the min (", 0
1: i0.min.0, 0
2: ") in dimension 0", 0
3: stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"), 1
With variables stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0")
With lets: stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0")



Input to letify ((5 - i0.extent.0) <= i0.min.0)
Canonical form without lets ((5 - i0.extent.0) <= i0.min.0)
0: 5, 0
1: i0.extent.0, 0
2: (5 - i0.extent.0), 0
3: i0.min.0, 0
4: ((5 - i0.extent.0) <= i0.min.0), 1
With variables ((5 - i0.extent.0) <= i0.min.0)
With lets: ((5 - i0.extent.0) <= i0.min.0)



Input to letify stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0")
Canonical form without lets stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0")
0: "Input buffer i0 is accessed at 4, which is beyond the max (", 0
1: i0.min.0, 0
2: i0.extent.0, 0
3: (i0.min.0 + i0.extent.0), 1
4: -1, 0
5: ((i0.min.0 + i0.extent.0) + -1), 0
6: ") in dimension 0", 0
7: stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"), 1
With variables stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0")
With lets: stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0")



Input to letify (i0.min.1 <= 0)
Canonical form without lets (i0.min.1 <= 0)
0: i0.min.1, 0
1: 0, 0
2: (i0.min.1 <= 0), 1
With variables (i0.min.1 <= 0)
With lets: (i0.min.1 <= 0)



Input to letify stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1")
Canonical form without lets stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1")
0: "Input buffer i0 is accessed at 0, which is before the min (", 0
1: i0.min.1, 0
2: ") in dimension 1", 0
3: stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"), 1
With variables stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1")
With lets: stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1")



Input to letify ((5 - i0.extent.1) <= i0.min.1)
Canonical form without lets ((5 - i0.extent.1) <= i0.min.1)
0: 5, 0
1: i0.extent.1, 0
2: (5 - i0.extent.1), 0
3: i0.min.1, 0
4: ((5 - i0.extent.1) <= i0.min.1), 1
With variables ((5 - i0.extent.1) <= i0.min.1)
With lets: ((5 - i0.extent.1) <= i0.min.1)



Input to letify stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1")
Canonical form without lets stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1")
0: "Input buffer i0 is accessed at 4, which is beyond the max (", 0
1: i0.min.1, 0
2: i0.extent.1, 0
3: (i0.min.1 + i0.extent.1), 1
4: -1, 0
5: ((i0.min.1 + i0.extent.1) + -1), 0
6: ") in dimension 1", 0
7: stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"), 1
With variables stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1")
With lets: stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1")



Input to letify (input.min.0 <= input.min.0.required)
Canonical form without lets (input.min.0 <= input.min.0.required)
0: input.min.0, 0
1: input.min.0.required, 0
2: (input.min.0 <= input.min.0.required), 1
With variables (input.min.0 <= input.min.0.required)
With lets: (input.min.0 <= input.min.0.required)



Input to letify stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0")
Canonical form without lets stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0")
0: "Input buffer input is accessed at ", 0
1: output.min.0, 0
2: -2, 0
3: (output.min.0 + -2), 0
4: input.extent.0, 0
5: -1, 0
6: (input.extent.0 + -1), 0
7: min((output.min.0 + -2), (input.extent.0 + -1)), 1
8: 0, 0
9: max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), 1
10: ", which is before the min (", 0
11: input.min.0, 0
12: ") in dimension 0", 0
13: stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"), 1
With variables stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0")
With lets: stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0")



Input to letify ((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0)
Canonical form without lets ((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0)
0: input.min.0.required, 0
1: input.extent.0.required.s, 0
2: (input.min.0.required + input.extent.0.required.s), 1
3: input.extent.0, 0
4: ((input.min.0.required + input.extent.0.required.s) - input.extent.0), 1
5: 1, 0
6: (((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1), 0
7: input.min.0, 0
8: ((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), 1
With variables ((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0)
With lets: ((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0)



Input to letify stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0")
Canonical form without lets stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0")
0: "Input buffer input is accessed at ", 0
1: input.min.0.required, 0
2: input.extent.0.required.s, 0
3: (input.min.0.required + input.extent.0.required.s), 1
4: ", which is beyond the max (", 0
5: input.min.0, 0
6: input.extent.0, 0
7: (input.min.0 + input.extent.0), 1
8: -1, 0
9: ((input.min.0 + input.extent.0) + -1), 0
10: ") in dimension 0", 0
11: stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"), 1
With variables stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0")
With lets: stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0")



Input to letify (input.min.1 <= input.min.1.required)
Canonical form without lets (input.min.1 <= input.min.1.required)
0: input.min.1, 0
1: input.min.1.required, 0
2: (input.min.1 <= input.min.1.required), 1
With variables (input.min.1 <= input.min.1.required)
With lets: (input.min.1 <= input.min.1.required)



Input to letify stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1")
Canonical form without lets stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1")
0: "Input buffer input is accessed at ", 0
1: output.min.1, 0
2: -2, 0
3: (output.min.1 + -2), 0
4: input.extent.1, 0
5: -1, 0
6: (input.extent.1 + -1), 0
7: min((output.min.1 + -2), (input.extent.1 + -1)), 1
8: 0, 0
9: max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), 1
10: ", which is before the min (", 0
11: input.min.1, 0
12: ") in dimension 1", 0
13: stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"), 1
With variables stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1")
With lets: stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1")



Input to letify ((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1)
Canonical form without lets ((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1)
0: input.min.1.required, 0
1: input.extent.1.required.s, 0
2: (input.min.1.required + input.extent.1.required.s), 1
3: input.extent.1, 0
4: ((input.min.1.required + input.extent.1.required.s) - input.extent.1), 1
5: 1, 0
6: (((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1), 0
7: input.min.1, 0
8: ((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), 1
With variables ((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1)
With lets: ((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1)



Input to letify stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1")
Canonical form without lets stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1")
0: "Input buffer input is accessed at ", 0
1: input.min.1.required, 0
2: input.extent.1.required.s, 0
3: (input.min.1.required + input.extent.1.required.s), 1
4: ", which is beyond the max (", 0
5: input.min.1, 0
6: input.extent.1, 0
7: (input.min.1 + input.extent.1), 1
8: -1, 0
9: ((input.min.1 + input.extent.1) + -1), 0
10: ") in dimension 1", 0
11: stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"), 1
With variables stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1")
With lets: stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1")



Input to letify (output.min.0 <= output.min.0.required)
Canonical form without lets (output.min.0 <= output.min.0.required)
0: output.min.0, 0
1: output.min.0.required, 0
2: (output.min.0 <= output.min.0.required), 1
With variables (output.min.0 <= output.min.0.required)
With lets: (output.min.0 <= output.min.0.required)



Input to letify stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0")
Canonical form without lets stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0")
0: "Output buffer output is accessed at ", 0
1: output.min.0, 0
2: output.extent.0, 0
3: (output.min.0 + output.extent.0), 1
4: -16, 0
5: ((output.min.0 + output.extent.0) + -16), 0
6: min(output.min.0, ((output.min.0 + output.extent.0) + -16)), 1
7: ", which is before the min (", 0
8: ") in dimension 0", 0
9: stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"), 1
With variables stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0")
With lets: stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0")



Input to letify ((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0)
Canonical form without lets ((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0)
0: output.min.0.required, 0
1: output.extent.0.required.s, 0
2: (output.min.0.required + output.extent.0.required.s), 1
3: output.extent.0, 0
4: ((output.min.0.required + output.extent.0.required.s) - output.extent.0), 1
5: 1, 0
6: (((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1), 0
7: output.min.0, 0
8: ((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), 1
With variables ((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0)
With lets: ((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0)



Input to letify stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0")
Canonical form without lets stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0")
0: "Output buffer output is accessed at ", 0
1: output.min.0.required, 0
2: output.extent.0.required.s, 0
3: (output.min.0.required + output.extent.0.required.s), 1
4: ", which is beyond the max (", 0
5: output.min.0, 0
6: output.extent.0, 0
7: (output.min.0 + output.extent.0), 1
8: -1, 0
9: ((output.min.0 + output.extent.0) + -1), 0
10: ") in dimension 0", 0
11: stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"), 1
With variables stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0")
With lets: stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0")



Input to letify (output.min.1 <= output.min.1.required)
Canonical form without lets (output.min.1 <= output.min.1.required)
0: output.min.1, 0
1: output.min.1.required, 0
2: (output.min.1 <= output.min.1.required), 1
With variables (output.min.1 <= output.min.1.required)
With lets: (output.min.1 <= output.min.1.required)



Input to letify stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1")
Canonical form without lets stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1")
0: "Output buffer output is accessed at ", 0
1: output.min.1, 0
2: output.extent.1, 0
3: (output.min.1 + output.extent.1), 1
4: -16, 0
5: ((output.min.1 + output.extent.1) + -16), 0
6: min(output.min.1, ((output.min.1 + output.extent.1) + -16)), 1
7: ", which is before the min (", 0
8: ") in dimension 1", 0
9: stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"), 1
With variables stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1")
With lets: stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1")



Input to letify ((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1)
Canonical form without lets ((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1)
0: output.min.1.required, 0
1: output.extent.1.required.s, 0
2: (output.min.1.required + output.extent.1.required.s), 1
3: output.extent.1, 0
4: ((output.min.1.required + output.extent.1.required.s) - output.extent.1), 1
5: 1, 0
6: (((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1), 0
7: output.min.1, 0
8: ((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), 1
With variables ((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1)
With lets: ((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1)



Input to letify stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1")
Canonical form without lets stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1")
0: "Output buffer output is accessed at ", 0
1: output.min.1.required, 0
2: output.extent.1.required.s, 0
3: (output.min.1.required + output.extent.1.required.s), 1
4: ", which is beyond the max (", 0
5: output.min.1, 0
6: output.extent.1, 0
7: (output.min.1 + output.extent.1), 1
8: -1, 0
9: ((output.min.1 + output.extent.1) + -1), 0
10: ") in dimension 1", 0
11: stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"), 1
With variables stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1")
With lets: stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1")



Input to letify (i0.stride.0 == 1)
Canonical form without lets (i0.stride.0 == 1)
0: i0.stride.0, 0
1: 1, 0
2: (i0.stride.0 == 1), 1
With variables (i0.stride.0 == 1)
With lets: (i0.stride.0 == 1)



Input to letify (i0.min.0 == 0)
Canonical form without lets (i0.min.0 == 0)
0: i0.min.0, 0
1: 0, 0
2: (i0.min.0 == 0), 1
With variables (i0.min.0 == 0)
With lets: (i0.min.0 == 0)



Input to letify (i0.extent.0 == 5)
Canonical form without lets (i0.extent.0 == 5)
0: i0.extent.0, 0
1: 5, 0
2: (i0.extent.0 == 5), 1
With variables (i0.extent.0 == 5)
With lets: (i0.extent.0 == 5)



Input to letify (i0.stride.1 == 5)
Canonical form without lets (i0.stride.1 == 5)
0: i0.stride.1, 0
1: 5, 0
2: (i0.stride.1 == 5), 1
With variables (i0.stride.1 == 5)
With lets: (i0.stride.1 == 5)



Input to letify (i0.min.1 == 0)
Canonical form without lets (i0.min.1 == 0)
0: i0.min.1, 0
1: 0, 0
2: (i0.min.1 == 0), 1
With variables (i0.min.1 == 0)
With lets: (i0.min.1 == 0)



Input to letify (i0.extent.1 == 5)
Canonical form without lets (i0.extent.1 == 5)
0: i0.extent.1, 0
1: 5, 0
2: (i0.extent.1 == 5), 1
With variables (i0.extent.1 == 5)
With lets: (i0.extent.1 == 5)



Input to letify (input.stride.0 == 1)
Canonical form without lets (input.stride.0 == 1)
0: input.stride.0, 0
1: 1, 0
2: (input.stride.0 == 1), 1
With variables (input.stride.0 == 1)
With lets: (input.stride.0 == 1)



Input to letify (output.stride.0 == 1)
Canonical form without lets (output.stride.0 == 1)
0: output.stride.0, 0
1: 1, 0
2: (output.stride.0 == 1), 1
With variables (output.stride.0 == 1)
With lets: (output.stride.0 == 1)



Input to letify (int64(input.extent.1)*int64(input.extent.0))
Canonical form without lets (int64(input.extent.1)*int64(input.extent.0))
0: input.extent.1, 0
1: int64(input.extent.1), 0
2: input.extent.0, 0
3: int64(input.extent.0), 0
4: (int64(input.extent.1)*int64(input.extent.0)), 1
With variables (int64(input.extent.1)*int64(input.extent.0))
With lets: (int64(input.extent.1)*int64(input.extent.0))



Input to letify (int64(output.extent.1)*int64(output.extent.0))
Canonical form without lets (int64(output.extent.1)*int64(output.extent.0))
0: output.extent.1, 0
1: int64(output.extent.1), 0
2: output.extent.0, 0
3: int64(output.extent.0), 0
4: (int64(output.extent.1)*int64(output.extent.0)), 1
With variables (int64(output.extent.1)*int64(output.extent.0))
With lets: (int64(output.extent.1)*int64(output.extent.0))



Input to letify (int64(5) <= int64(2147483647))
Canonical form without lets (int64(5) <= int64(2147483647))
0: 5, 0
1: int64(5), 0
2: 2147483647, 0
3: int64(2147483647), 0
4: (int64(5) <= int64(2147483647)), 1
With variables (int64(5) <= int64(2147483647))
With lets: (int64(5) <= int64(2147483647))



Input to letify ((int64(5)*int64(5)) <= int64(2147483647))
Canonical form without lets ((int64(5)*int64(5)) <= int64(2147483647))
0: 5, 0
1: int64(5), 0
2: (int64(5)*int64(5)), 0
3: 2147483647, 0
4: int64(2147483647), 0
5: ((int64(5)*int64(5)) <= int64(2147483647)), 1
With variables ((int64(5)*int64(5)) <= int64(2147483647))
With lets: ((int64(5)*int64(5)) <= int64(2147483647))



Input to letify ((int64(5)*int64(5)) <= int64(2147483647))
Canonical form without lets ((int64(5)*int64(5)) <= int64(2147483647))
0: 5, 0
1: int64(5), 0
2: (int64(5)*int64(5)), 0
3: 2147483647, 0
4: int64(2147483647), 0
5: ((int64(5)*int64(5)) <= int64(2147483647)), 1
With variables ((int64(5)*int64(5)) <= int64(2147483647))
With lets: ((int64(5)*int64(5)) <= int64(2147483647))



Input to letify (int64(input.extent.0) <= int64(2147483647))
Canonical form without lets (int64(input.extent.0) <= int64(2147483647))
0: input.extent.0, 0
1: int64(input.extent.0), 0
2: 2147483647, 0
3: int64(2147483647), 0
4: (int64(input.extent.0) <= int64(2147483647)), 1
With variables (int64(input.extent.0) <= int64(2147483647))
With lets: (int64(input.extent.0) <= int64(2147483647))



Input to letify ((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647))
Canonical form without lets ((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647))
0: input.extent.1, 0
1: int64(input.extent.1), 0
2: input.stride.1, 0
3: int64(input.stride.1), 0
4: (int64(input.extent.1)*int64(input.stride.1)), 1
5: 2147483647, 0
6: int64(2147483647), 0
7: ((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), 1
With variables ((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647))
With lets: ((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647))



Input to letify (input.total_extent.1 <= int64(2147483647))
Canonical form without lets (input.total_extent.1 <= int64(2147483647))
0: input.total_extent.1, 0
1: 2147483647, 0
2: int64(2147483647), 0
3: (input.total_extent.1 <= int64(2147483647)), 1
With variables (input.total_extent.1 <= int64(2147483647))
With lets: (input.total_extent.1 <= int64(2147483647))



Input to letify (int64(output.extent.0) <= int64(2147483647))
Canonical form without lets (int64(output.extent.0) <= int64(2147483647))
0: output.extent.0, 0
1: int64(output.extent.0), 0
2: 2147483647, 0
3: int64(2147483647), 0
4: (int64(output.extent.0) <= int64(2147483647)), 1
With variables (int64(output.extent.0) <= int64(2147483647))
With lets: (int64(output.extent.0) <= int64(2147483647))



Input to letify ((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647))
Canonical form without lets ((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647))
0: output.extent.1, 0
1: int64(output.extent.1), 0
2: output.stride.1, 0
3: int64(output.stride.1), 0
4: (int64(output.extent.1)*int64(output.stride.1)), 1
5: 2147483647, 0
6: int64(2147483647), 0
7: ((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), 1
With variables ((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647))
With lets: ((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647))



Input to letify (output.total_extent.1 <= int64(2147483647))
Canonical form without lets (output.total_extent.1 <= int64(2147483647))
0: output.total_extent.1, 0
1: 2147483647, 0
2: int64(2147483647), 0
3: (output.total_extent.1 <= int64(2147483647)), 1
With variables (output.total_extent.1 <= int64(2147483647))
With lets: (output.total_extent.1 <= int64(2147483647))



Input to letify min(((output.min.1 + output.extent.1) + -16), output.min.1)
Canonical form without lets min(((output.min.1 + output.extent.1) + -16), output.min.1)
0: output.min.1, 0
1: output.extent.1, 0
2: (output.min.1 + output.extent.1), 1
3: -16, 0
4: ((output.min.1 + output.extent.1) + -16), 0
5: min(((output.min.1 + output.extent.1) + -16), output.min.1), 1
With variables min(((output.min.1 + output.extent.1) + -16), output.min.1)
With lets: min(((output.min.1 + output.extent.1) + -16), output.min.1)



Input to letify max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
Canonical form without lets max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
0: output.min.1, 0
1: output.extent.1, 0
2: (output.min.1 + output.extent.1), 2
3: -1, 0
4: ((output.min.1 + output.extent.1) + -1), 0
5: (output.extent.1 + -1), 0
6: 16, 0
7: ((output.extent.1 + -1)/16), 0
8: (((output.extent.1 + -1)/16)*16), 0
9: ((((output.extent.1 + -1)/16)*16) + output.min.1), 1
10: 15, 0
11: (((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), 0
12: min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)), 1
13: max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))), 1
With variables max((t2 + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), (t2 + -1)))
With lets: (let t2 = (output.min.1 + output.extent.1) in max((t2 + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), (t2 + -1))))



Input to letify min(((output.min.0 + output.extent.0) + -128), output.min.0)
Canonical form without lets min(((output.min.0 + output.extent.0) + -128), output.min.0)
0: output.min.0, 0
1: output.extent.0, 0
2: (output.min.0 + output.extent.0), 1
3: -128, 0
4: ((output.min.0 + output.extent.0) + -128), 0
5: min(((output.min.0 + output.extent.0) + -128), output.min.0), 1
With variables min(((output.min.0 + output.extent.0) + -128), output.min.0)
With lets: min(((output.min.0 + output.extent.0) + -128), output.min.0)



Input to letify max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
Canonical form without lets max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
0: output.min.0, 0
1: output.extent.0, 0
2: (output.min.0 + output.extent.0), 2
3: -1, 0
4: ((output.min.0 + output.extent.0) + -1), 0
5: (output.extent.0 + -1), 0
6: 16, 0
7: ((output.extent.0 + -1)/16), 0
8: (((output.extent.0 + -1)/16)*16), 0
9: ((((output.extent.0 + -1)/16)*16) + output.min.0), 1
10: 15, 0
11: (((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), 0
12: min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)), 1
13: max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))), 1
With variables max((t3 + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), (t3 + -1)))
With lets: (let t3 = (output.min.0 + output.extent.0) in max((t3 + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), (t3 + -1))))



Input to letify ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)
Canonical form without lets ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)
0: blur.x.extent_realized.s.s, 0
1: blur.x.min_realized, 0
2: (blur.x.extent_realized.s.s - blur.x.min_realized), 1
3: 1, 0
4: ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 0
With variables ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)
With lets: ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)



Input to letify ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)
Canonical form without lets ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)
0: blur.y.extent_realized.s.s, 0
1: blur.y.min_realized, 0
2: (blur.y.extent_realized.s.s - blur.y.min_realized), 1
3: 1, 0
4: ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), 0
With variables ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)
With lets: ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)



Input to letify create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
Canonical form without lets create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
0: 0, 0
1: blur[0], 1
2: address_of(blur[0]), 1
3: 4, 0
4: blur.x.min_realized, 0
5: blur.x.extent_realized.s.s, 0
6: (blur.x.extent_realized.s.s - blur.x.min_realized), 2
7: 1, 0
8: ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 0
9: blur.y.min_realized, 0
10: blur.y.extent_realized.s.s, 0
11: (blur.y.extent_realized.s.s - blur.y.min_realized), 1
12: ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), 0
13: create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)), 1
With variables create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, (t4 + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), (t4 + 1))
With lets: (let t4 = (blur.x.extent_realized.s.s - blur.x.min_realized) in create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, (t4 + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), (t4 + 1)))



Input to letify (halide_dev_malloc(blur.buffer) == 0)
Canonical form without lets (halide_dev_malloc(blur.buffer) == 0)
0: blur.buffer, 0
1: halide_dev_malloc(blur.buffer), 1
2: 0, 0
3: (halide_dev_malloc(blur.buffer) == 0), 1
With variables (halide_dev_malloc(blur.buffer) == 0)
With lets: (halide_dev_malloc(blur.buffer) == 0)



Input to letify ((output.extent.1 + 7)/8)
Canonical form without lets ((output.extent.1 + 7)/8)
0: output.extent.1, 0
1: 7, 0
2: (output.extent.1 + 7), 0
3: 8, 0
4: ((output.extent.1 + 7)/8), 0
With variables ((output.extent.1 + 7)/8)
With lets: ((output.extent.1 + 7)/8)



Input to letify min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
Canonical form without lets min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
0: blur.s0.y.__block_id_y, 0
1: 8, 0
2: (blur.s0.y.__block_id_y*8), 0
3: output.min.1, 0
4: ((blur.s0.y.__block_id_y*8) + output.min.1), 1
5: output.extent.1, 0
6: (output.min.1 + output.extent.1), 1
7: -8, 0
8: ((output.min.1 + output.extent.1) + -8), 0
9: min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8)), 1
With variables min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
With lets: min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))



Input to letify ((output.extent.0 + 127)/128)
Canonical form without lets ((output.extent.0 + 127)/128)
0: output.extent.0, 0
1: 127, 0
2: (output.extent.0 + 127), 0
3: 128, 0
4: ((output.extent.0 + 127)/128), 0
With variables ((output.extent.0 + 127)/128)
With lets: ((output.extent.0 + 127)/128)



Input to letify min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
Canonical form without lets min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
0: blur.s0.x.x.__block_id_x, 0
1: 128, 0
2: (blur.s0.x.x.__block_id_x*128), 0
3: output.min.0, 0
4: ((blur.s0.x.x.__block_id_x*128) + output.min.0), 1
5: output.extent.0, 0
6: (output.min.0 + output.extent.0), 1
7: -128, 0
8: ((output.min.0 + output.extent.0) + -128), 0
9: min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128)), 1
With variables min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
With lets: min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))



Input to letify ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)
Canonical form without lets ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)
0: blur.s0.s1.base, 0
1: .__thread_id_x, 0
2: 8, 0
3: (.__thread_id_x*8), 0
4: (blur.s0.s1.base + (.__thread_id_x*8)), 1
5: blur.x.min_realized, 0
6: ((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized), 1
7: blur.s0.y.__thread_id_y.base, 0
8: .__thread_id_y, 0
9: (blur.s0.y.__thread_id_y.base + .__thread_id_y), 1
10: blur.y.min_realized, 0
11: ((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized), 1
12: blur.x.extent_realized.s.s, 0
13: (blur.x.extent_realized.s.s - blur.x.min_realized), 1
14: 1, 0
15: ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 0
16: (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)), 1
17: (((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1
18: ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8), 0
With variables ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)
With lets: ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)



Input to letify set_dev_dirty(blur.buffer, uint8(1))
Canonical form without lets set_dev_dirty(blur.buffer, uint8(1))
0: blur.buffer, 0
1: 1, 0
2: uint8(1), 0
3: set_dev_dirty(blur.buffer, uint8(1)), 1
With variables set_dev_dirty(blur.buffer, uint8(1))
With lets: set_dev_dirty(blur.buffer, uint8(1))



Input to letify (halide_copy_to_host(input.buffer) == 0)
Canonical form without lets (halide_copy_to_host(input.buffer) == 0)
0: input.buffer, 0
1: halide_copy_to_host(input.buffer), 1
2: 0, 0
3: (halide_copy_to_host(input.buffer) == 0), 1
With variables (halide_copy_to_host(input.buffer) == 0)
With lets: (halide_copy_to_host(input.buffer) == 0)



Input to letify (halide_copy_to_host(i0.buffer) == 0)
Canonical form without lets (halide_copy_to_host(i0.buffer) == 0)
0: i0.buffer, 0
1: halide_copy_to_host(i0.buffer), 1
2: 0, 0
3: (halide_copy_to_host(i0.buffer) == 0), 1
With variables (halide_copy_to_host(i0.buffer) == 0)
With lets: (halide_copy_to_host(i0.buffer) == 0)



Input to letify (halide_copy_to_host(blur.buffer) == 0)
Canonical form without lets (halide_copy_to_host(blur.buffer) == 0)
0: blur.buffer, 0
1: halide_copy_to_host(blur.buffer), 1
2: 0, 0
3: (halide_copy_to_host(blur.buffer) == 0), 1
With variables (halide_copy_to_host(blur.buffer) == 0)
With lets: (halide_copy_to_host(blur.buffer) == 0)



Input to letify (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
Canonical form without lets (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
0: blur.s1.x, 0
1: blur.x.min_realized, 0
2: (blur.s1.x - blur.x.min_realized), 1
3: blur.s1.y, 0
4: blur.y.min_realized, 0
5: (blur.s1.y - blur.y.min_realized), 1
6: blur.x.extent_realized.s.s, 0
7: (blur.x.extent_realized.s.s - blur.x.min_realized), 1
8: 1, 0
9: ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 0
10: ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)), 1
11: ((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1
12: blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))], 1
13: blur.s1.i0.x$r, 0
14: blur.s1.i0.y$r, 0
15: 5, 0
16: (blur.s1.i0.y$r*5), 0
17: (blur.s1.i0.x$r + (blur.s1.i0.y$r*5)), 1
18: i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))], 1
19: float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))]), 1
20: (blur.s1.x + blur.s1.i0.x$r), 1
21: -2, 0
22: ((blur.s1.x + blur.s1.i0.x$r) + -2), 0
23: input.extent.0, 0
24: -1, 0
25: (input.extent.0 + -1), 0
26: min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 1
27: 0, 0
28: max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0), 1
29: (blur.s1.y + blur.s1.i0.y$r), 1
30: ((blur.s1.y + blur.s1.i0.y$r) + -2), 0
31: input.extent.1, 0
32: (input.extent.1 + -1), 0
33: min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 1
34: max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0), 1
35: input.stride.1, 0
36: (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1), 1
37: (max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)), 1
38: input.min.0, 0
39: input.min.1, 0
40: (input.min.1*input.stride.1), 1
41: (input.min.0 + (input.min.1*input.stride.1)), 1
42: ((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1))), 1
43: input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))], 1
44: float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))]), 1
45: 0.000015f, 0
46: (float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f), 0
47: (float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f)), 1
48: 0.003663f, 0
49: ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f), 0
50: (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f)), 1
With variables (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
With lets: (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))



Input to letify ((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))
Canonical form without lets ((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))
0: blur.s1.x, 0
1: blur.x.min_realized, 0
2: (blur.s1.x - blur.x.min_realized), 1
3: blur.s1.y, 0
4: blur.y.min_realized, 0
5: (blur.s1.y - blur.y.min_realized), 1
6: blur.x.extent_realized.s.s, 0
7: (blur.x.extent_realized.s.s - blur.x.min_realized), 1
8: 1, 0
9: ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 0
10: ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)), 1
11: ((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1
With variables ((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))
With lets: ((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))



Input to letify set_host_dirty(blur.buffer, uint8(1))
Canonical form without lets set_host_dirty(blur.buffer, uint8(1))
0: blur.buffer, 0
1: 1, 0
2: uint8(1), 0
3: set_host_dirty(blur.buffer, uint8(1)), 1
With variables set_host_dirty(blur.buffer, uint8(1))
With lets: set_host_dirty(blur.buffer, uint8(1))



Input to letify (halide_dev_malloc(output.buffer) == 0)
Canonical form without lets (halide_dev_malloc(output.buffer) == 0)
0: output.buffer, 0
1: halide_dev_malloc(output.buffer), 1
2: 0, 0
3: (halide_dev_malloc(output.buffer) == 0), 1
With variables (halide_dev_malloc(output.buffer) == 0)
With lets: (halide_dev_malloc(output.buffer) == 0)



Input to letify (halide_copy_to_dev(output.buffer) == 0)
Canonical form without lets (halide_copy_to_dev(output.buffer) == 0)
0: output.buffer, 0
1: halide_copy_to_dev(output.buffer), 1
2: 0, 0
3: (halide_copy_to_dev(output.buffer) == 0), 1
With variables (halide_copy_to_dev(output.buffer) == 0)
With lets: (halide_copy_to_dev(output.buffer) == 0)



Input to letify (halide_copy_to_dev(blur.buffer) == 0)
Canonical form without lets (halide_copy_to_dev(blur.buffer) == 0)
0: blur.buffer, 0
1: halide_copy_to_dev(blur.buffer), 1
2: 0, 0
3: (halide_copy_to_dev(blur.buffer) == 0), 1
With variables (halide_copy_to_dev(blur.buffer) == 0)
With lets: (halide_copy_to_dev(blur.buffer) == 0)



Input to letify ((output.extent.1 + 15)/16)
Canonical form without lets ((output.extent.1 + 15)/16)
0: output.extent.1, 0
1: 15, 0
2: (output.extent.1 + 15), 0
3: 16, 0
4: ((output.extent.1 + 15)/16), 0
With variables ((output.extent.1 + 15)/16)
With lets: ((output.extent.1 + 15)/16)



Input to letify min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
Canonical form without lets min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
0: output.s0.y.__block_id_y, 0
1: 16, 0
2: (output.s0.y.__block_id_y*16), 0
3: output.min.1, 0
4: ((output.s0.y.__block_id_y*16) + output.min.1), 1
5: output.extent.1, 0
6: (output.min.1 + output.extent.1), 1
7: -16, 0
8: ((output.min.1 + output.extent.1) + -16), 0
9: min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16)), 1
With variables min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
With lets: min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))



Input to letify ((output.extent.0 + 15)/16)
Canonical form without lets ((output.extent.0 + 15)/16)
0: output.extent.0, 0
1: 15, 0
2: (output.extent.0 + 15), 0
3: 16, 0
4: ((output.extent.0 + 15)/16), 0
With variables ((output.extent.0 + 15)/16)
With lets: ((output.extent.0 + 15)/16)



Input to letify min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
Canonical form without lets min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
0: output.s0.x.x.__block_id_x, 0
1: 16, 0
2: (output.s0.x.x.__block_id_x*16), 0
3: output.min.0, 0
4: ((output.s0.x.x.__block_id_x*16) + output.min.0), 1
5: output.extent.0, 0
6: (output.min.0 + output.extent.0), 1
7: -16, 0
8: ((output.min.0 + output.extent.0) + -16), 0
9: min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16)), 1
With variables min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
With lets: min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))



Input to letify uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
Canonical form without lets uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
0: output.s0.s0.base, 0
1: .__thread_id_x, 0
2: 8, 0
3: (.__thread_id_x*8), 0
4: (output.s0.s0.base + (.__thread_id_x*8)), 1
5: blur.x.min_realized, 0
6: ((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized), 1
7: output.s0.y.__thread_id_y.base, 0
8: .__thread_id_y, 0
9: (output.s0.y.__thread_id_y.base + .__thread_id_y), 1
10: blur.y.min_realized, 0
11: ((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized), 1
12: blur.x.extent_realized.s.s, 0
13: (blur.x.extent_realized.s.s - blur.x.min_realized), 1
14: 1, 0
15: ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 0
16: (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)), 1
17: (((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1
18: ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8), 0
19: blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], 1
20: 1.000000f, 0
21: x8(1.000000f), 0
22: min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), 1
23: 0.000000f, 0
24: x8(0.000000f), 0
25: max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f)), 1
26: 65535.000000f, 0
27: x8(65535.000000f), 0
28: (max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)), 0
29: uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f))), 0
With variables uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
With lets: uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))



Input to letify ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)
Canonical form without lets ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)
0: output.s0.s0.base, 0
1: .__thread_id_x, 0
2: 8, 0
3: (.__thread_id_x*8), 0
4: (output.s0.s0.base + (.__thread_id_x*8)), 1
5: output.s0.y.__thread_id_y.base, 0
6: .__thread_id_y, 0
7: (output.s0.y.__thread_id_y.base + .__thread_id_y), 1
8: output.stride.1, 0
9: ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1), 1
10: ((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)), 1
11: output.min.0, 0
12: output.min.1, 0
13: (output.min.1*output.stride.1), 1
14: (output.min.0 + (output.min.1*output.stride.1)), 1
15: (((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1
16: 1, 0
17: ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8), 0
With variables ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)
With lets: ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)



Input to letify (halide_dev_free(blur.buffer) == 0)
Canonical form without lets (halide_dev_free(blur.buffer) == 0)
0: blur.buffer, 0
1: halide_dev_free(blur.buffer), 1
2: 0, 0
3: (halide_dev_free(blur.buffer) == 0), 1
With variables (halide_dev_free(blur.buffer) == 0)
With lets: (halide_dev_free(blur.buffer) == 0)



Input to letify set_dev_dirty(output.buffer, uint8(1))
Canonical form without lets set_dev_dirty(output.buffer, uint8(1))
0: output.buffer, 0
1: 1, 0
2: uint8(1), 0
3: set_dev_dirty(output.buffer, uint8(1)), 1
With variables set_dev_dirty(output.buffer, uint8(1))
With lets: set_dev_dirty(output.buffer, uint8(1))
simplify let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)) in ... input.extent.0.required.s ...
simplify let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0) in ... input.min.0.required ...
simplify let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)) in ... input.extent.1.required.s ...
simplify let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0) in ... input.min.1.required ...
simplify let t0 = (output.min.0 + output.extent.0) in ... t0 ...
new let t0.s = (undefined) in ... (output.min.0 + output.extent.0) ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16))) in ... output.extent.0.required.s ...
simplify let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16)) in ... output.min.0.required ...
simplify let t1 = (output.min.1 + output.extent.1) in ... t1 ...
new let t1.s = (undefined) in ... (output.min.1 + output.extent.1) ...
output.extent.1 not in scope, so leaving it as-is
simplify let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16))) in ... output.extent.1.required.s ...
simplify let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16)) in ... output.min.1.required ...
i0.elem_size not in scope, so leaving it as-is
input.elem_size not in scope, so leaving it as-is
output.elem_size not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.min.0 not in scope, so leaving it as-is
input.extent.0 not in scope, so leaving it as-is
input.min.0.required not in scope, so leaving it as-is
input.extent.0.required.s not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.min.1 not in scope, so leaving it as-is
input.extent.1 not in scope, so leaving it as-is
input.min.1.required not in scope, so leaving it as-is
input.extent.1.required.s not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
output.min.0.required not in scope, so leaving it as-is
output.extent.0.required.s not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
output.min.1.required not in scope, so leaving it as-is
output.extent.1.required.s not in scope, so leaving it as-is
i0.stride.0 not in scope, so leaving it as-is
i0.min.0 not in scope, so leaving it as-is
i0.extent.0 not in scope, so leaving it as-is
i0.stride.1 not in scope, so leaving it as-is
i0.min.1 not in scope, so leaving it as-is
i0.extent.1 not in scope, so leaving it as-is
input.stride.0 not in scope, so leaving it as-is
output.stride.0 not in scope, so leaving it as-is
simplify let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0)) in ... input.total_extent.1 ...
simplify let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0)) in ... output.total_extent.1 ...
simplify let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1) in ... blur.y.min_realized ...
simplify let t2 = (output.min.1 + output.extent.1) in ... t2 ...
new let t2.s = (undefined) in ... (output.min.1 + output.extent.1) ...
output.extent.1 not in scope, so leaving it as-is
simplify let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))) in ... blur.y.extent_realized.s.s ...
simplify let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0) in ... blur.x.min_realized ...
simplify let t3 = (output.min.0 + output.extent.0) in ... t3 ...
new let t3.s = (undefined) in ... (output.min.0 + output.extent.0) ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))) in ... blur.x.extent_realized.s.s ...
simplify let t4 = (blur.x.extent_realized.s.s - blur.x.min_realized) in ... t4 ...
new let t4.s = (undefined) in ... (blur.x.extent_realized.s.s - blur.x.min_realized) ...
simplify let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)) in ... blur.buffer ...
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8)) in ... blur.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128)) in ... blur.s0.s1.base ...
input.buffer not in scope, so leaving it as-is
i0.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
output.buffer not in scope, so leaving it as-is
blur.buffer not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
simplify let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16)) in ... output.s0.y.__thread_id_y.base ...
output.extent.0 not in scope, so leaving it as-is
simplify let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16)) in ... output.s0.s0.base ...
blur.buffer not in scope, so leaving it as-is
Lowering after final simplification:
let input.extent.0.required.s = (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}


Embedding image i0
Constructing OpenCL device codegen
OpenCL device codegen init_module
Target triple of initial module: x86_64-unknown-unknown-unknown
Target triple of initial module: x86_64--linux-gnu
Codegen: handle64, "buffer argument input is NULL"
Creating call to error handlers
Creating cleanup code
Codegen: handle64, "buffer argument output is NULL"
Creating call to error handlers
Creating cleanup code
Codegen: handle64, "buffer argument i0 is NULL"
Creating call to error handlers
Creating cleanup code
Generating llvm bitcode...
Codegen: int32, (max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0) - max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
Codegen: int32, max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
Codegen: int32, min((output.min.0 + -2), (input.extent.0 + -1))
Codegen: int32, (output.min.0 + -2)
Codegen: int32, -2
Codegen: int32, output.min.0
Codegen: int32, (input.extent.0 + -1)
Codegen: int32, -1
Codegen: int32, input.extent.0
Codegen: int32, 0
Codegen: int32, max(min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1)), 0)
Codegen: int32, min(((output.min.0 + output.extent.0) + 1), (input.extent.0 + -1))
Codegen: int32, ((output.min.0 + output.extent.0) + 1)
Codegen: int32, 1
Codegen: int32, (output.min.0 + output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, output.min.0
Codegen: int32, (input.extent.0 + -1)
Codegen: int32, -1
Codegen: int32, input.extent.0
Codegen: int32, 0
Codegen: let input.min.0.required = max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: int32, max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
Codegen: int32, min((output.min.0 + -2), (input.extent.0 + -1))
Codegen: int32, (output.min.0 + -2)
Codegen: int32, -2
Codegen: int32, output.min.0
Codegen: int32, (input.extent.0 + -1)
Codegen: int32, -1
Codegen: int32, input.extent.0
Codegen: int32, 0
Codegen: let input.extent.1.required.s = (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: int32, (max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0) - max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
Codegen: int32, max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
Codegen: int32, min((output.min.1 + -2), (input.extent.1 + -1))
Codegen: int32, (output.min.1 + -2)
Codegen: int32, -2
Codegen: int32, output.min.1
Codegen: int32, (input.extent.1 + -1)
Codegen: int32, -1
Codegen: int32, input.extent.1
Codegen: int32, 0
Codegen: int32, max(min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1)), 0)
Codegen: int32, min(((output.min.1 + output.extent.1) + 1), (input.extent.1 + -1))
Codegen: int32, ((output.min.1 + output.extent.1) + 1)
Codegen: int32, 1
Codegen: int32, (output.min.1 + output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, output.min.1
Codegen: int32, (input.extent.1 + -1)
Codegen: int32, -1
Codegen: int32, input.extent.1
Codegen: int32, 0
Codegen: let input.min.1.required = max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: int32, max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
Codegen: int32, min((output.min.1 + -2), (input.extent.1 + -1))
Codegen: int32, (output.min.1 + -2)
Codegen: int32, -2
Codegen: int32, output.min.1
Codegen: int32, (input.extent.1 + -1)
Codegen: int32, -1
Codegen: int32, input.extent.1
Codegen: int32, 0
Codegen: let output.extent.0.required.s = (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: int32, (min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)) - min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
Codegen: int32, min(output.min.0, ((output.min.0 + output.extent.0) + -16))
Codegen: int32, output.min.0
Codegen: int32, ((output.min.0 + output.extent.0) + -16)
Codegen: int32, -16
Codegen: int32, (output.min.0 + output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, output.min.0
Codegen: int32, min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))
Codegen: int32, (((((output.extent.0 + -1)/16)*16) + output.min.0) + 15)
Codegen: int32, 15
Codegen: int32, ((((output.extent.0 + -1)/16)*16) + output.min.0)
Codegen: int32, output.min.0
Codegen: int32, (((output.extent.0 + -1)/16)*16)
Codegen: int32, 16
Codegen: int32, ((output.extent.0 + -1)/16)
Codegen: int32, (output.extent.0 + -1)
Codegen: int32, -1
Codegen: int32, output.extent.0
Codegen: int32, ((output.min.0 + output.extent.0) + -1)
Codegen: int32, -1
Codegen: int32, (output.min.0 + output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, output.min.0
Codegen: let output.min.0.required = min(output.min.0, ((output.min.0 + output.extent.0) + -16))
let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: int32, min(output.min.0, ((output.min.0 + output.extent.0) + -16))
Codegen: int32, output.min.0
Codegen: int32, ((output.min.0 + output.extent.0) + -16)
Codegen: int32, -16
Codegen: int32, (output.min.0 + output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, output.min.0
Codegen: let output.extent.1.required.s = (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: int32, (min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)) - min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
Codegen: int32, min(output.min.1, ((output.min.1 + output.extent.1) + -16))
Codegen: int32, output.min.1
Codegen: int32, ((output.min.1 + output.extent.1) + -16)
Codegen: int32, -16
Codegen: int32, (output.min.1 + output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, output.min.1
Codegen: int32, min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))
Codegen: int32, (((((output.extent.1 + -1)/16)*16) + output.min.1) + 15)
Codegen: int32, 15
Codegen: int32, ((((output.extent.1 + -1)/16)*16) + output.min.1)
Codegen: int32, output.min.1
Codegen: int32, (((output.extent.1 + -1)/16)*16)
Codegen: int32, 16
Codegen: int32, ((output.extent.1 + -1)/16)
Codegen: int32, (output.extent.1 + -1)
Codegen: int32, -1
Codegen: int32, output.extent.1
Codegen: int32, ((output.min.1 + output.extent.1) + -1)
Codegen: int32, -1
Codegen: int32, (output.min.1 + output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, output.min.1
Codegen: let output.min.1.required = min(output.min.1, ((output.min.1 + output.extent.1) + -16))
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: int32, min(output.min.1, ((output.min.1 + output.extent.1) + -16))
Codegen: int32, output.min.1
Codegen: int32, ((output.min.1 + output.extent.1) + -16)
Codegen: int32, -16
Codegen: int32, (output.min.1 + output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, output.min.1
Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")

Codegen: uint1, uint1(1)
Codegen: int32, 1
Codegen: handle64, "Applying the constraints to the required region made it smaller"
Creating call to error handlers
Creating cleanup code
Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")

Codegen: uint1, uint1(1)
Codegen: int32, 1
Codegen: handle64, "Applying the constraints to the required region made it smaller"
Creating call to error handlers
Creating cleanup code
Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")

Codegen: uint1, uint1(1)
Codegen: int32, 1
Codegen: handle64, "Applying the constraints to the required region made it smaller"
Creating call to error handlers
Creating cleanup code
Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")

Codegen: uint1, uint1(1)
Codegen: int32, 1
Codegen: handle64, "Applying the constraints to the required region made it smaller"
Creating call to error handlers
Creating cleanup code
Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")
assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")

Codegen: uint1, uint1(1)
Codegen: int32, 1
Codegen: handle64, "Applying the constraints to the required region made it smaller"
Creating call to error handlers
Creating cleanup code
Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")
if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: assert(uint1(1), "Applying the constraints to the required region made it smaller")

Codegen: uint1, uint1(1)
Codegen: int32, 1
Codegen: handle64, "Applying the constraints to the required region made it smaller"
Creating call to error handlers
Creating cleanup code
Codegen: if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}
if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: if (i0.host_and_dev_are_null) {
  rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
}

Codegen: uint1, i0.host_and_dev_are_null
Codegen: rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)

Codegen: uint1, rewrite_buffer(i0.buffer, 2, 0, 5, 1, 0, 5, 5)
Codegen: handle64, i0.buffer
Codegen: int32, 2
Codegen: int32, 0
Codegen: int32, 5
Codegen: int32, 1
Codegen: int32, 0
Codegen: int32, 5
Codegen: int32, 5
Codegen: uint1, uint1(1)
Codegen: int32, 1
Codegen: if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}
if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: if (input.host_and_dev_are_null) {
  rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
}

Codegen: uint1, input.host_and_dev_are_null
Codegen: rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))

Codegen: uint1, rewrite_buffer(input.buffer, 2, input.min.0.required, (input.extent.0.required.s + 1), 1, input.min.1.required, (input.extent.1.required.s + 1), (input.extent.0.required.s + 1))
Codegen: handle64, input.buffer
Codegen: int32, 2
Codegen: int32, input.min.0.required
Codegen: int32, (input.extent.0.required.s + 1)
Codegen: int32, 1
Codegen: int32, input.extent.0.required.s
Codegen: int32, 1
Codegen: int32, input.min.1.required
Codegen: int32, (input.extent.1.required.s + 1)
Codegen: int32, 1
Codegen: int32, input.extent.1.required.s
Codegen: int32, (input.extent.0.required.s + 1)
Codegen: int32, 1
Codegen: int32, input.extent.0.required.s
Codegen: uint1, uint1(1)
Codegen: int32, 1
Codegen: if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}
if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: if (output.host_and_dev_are_null) {
  rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
}

Codegen: uint1, output.host_and_dev_are_null
Codegen: rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))

Codegen: uint1, rewrite_buffer(output.buffer, 2, output.min.0.required, (output.extent.0.required.s + 1), 1, output.min.1.required, (output.extent.1.required.s + 1), (output.extent.0.required.s + 1))
Codegen: handle64, output.buffer
Codegen: int32, 2
Codegen: int32, output.min.0.required
Codegen: int32, (output.extent.0.required.s + 1)
Codegen: int32, 1
Codegen: int32, output.extent.0.required.s
Codegen: int32, 1
Codegen: int32, output.min.1.required
Codegen: int32, (output.extent.1.required.s + 1)
Codegen: int32, 1
Codegen: int32, output.extent.1.required.s
Codegen: int32, (output.extent.0.required.s + 1)
Codegen: int32, 1
Codegen: int32, output.extent.0.required.s
Codegen: uint1, uint1(1)
Codegen: int32, 1
Codegen: if (!((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)) {
  assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
  assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
  assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
  assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
  assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
  assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
  assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
  assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
  assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
  assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
  assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
  assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
  assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
  assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
  assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
  assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
  assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
  assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
  assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
  assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
  assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
  assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
  assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
  let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
  let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
  assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
  assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
  assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
  assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
  assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
  assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
  let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
  let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
  let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
  let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
  allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
  let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
  assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
  produce blur {
    parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
      let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
      parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
        parallel (.__thread_id_y, 0, 8) {
          parallel (.__thread_id_x, 0, 16) {
            let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
            blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
          }
        }
      }
    }
    set_dev_dirty(blur.buffer, uint8(1))
  } update blur {
    assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
    assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
    assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
    for (blur.s1.y, output.min.1, output.extent.1) {
      for (blur.s1.x, output.min.0, output.extent.0) {
        for (blur.s1.i0.y$r, 0, 5) {
          for (blur.s1.i0.x$r, 0, 5) {
            blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
          }
        }
      }
    }
    set_host_dirty(blur.buffer, uint8(1))
  }
  assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
  produce output {
    assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
    assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
    parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
      let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
      parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
        parallel (.__thread_id_y, 0, 16) {
          parallel (.__thread_id_x, 0, 2) {
            let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
            output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
          }
        }
      }
    }
    assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
    free blur
    set_dev_dirty(output.buffer, uint8(1))
  }
  0
}

Codegen: uint1, !((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)
Codegen: uint1, ((i0.host_and_dev_are_null || input.host_and_dev_are_null) || output.host_and_dev_are_null)
Codegen: uint1, output.host_and_dev_are_null
Codegen: uint1, (i0.host_and_dev_are_null || input.host_and_dev_are_null)
Codegen: uint1, input.host_and_dev_are_null
Codegen: uint1, i0.host_and_dev_are_null
Codegen: assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))
assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((i0.elem_size == 2), stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2"))

Codegen: uint1, (i0.elem_size == 2)
Codegen: int32, i0.elem_size
Codegen: int32, 2
Codegen: handle64, stringify("Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is ", i0.elem_size, " instead of 2")
Codegen: handle64, "Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is "
Codegen: int64, int64(i0.elem_size)
Codegen: int32, i0.elem_size
Codegen: handle64, " instead of 2"
Creating call to error handlers
Creating cleanup code
Codegen: assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))
assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((input.elem_size == 2), stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2"))

Codegen: uint1, (input.elem_size == 2)
Codegen: int32, input.elem_size
Codegen: int32, 2
Codegen: handle64, stringify("Input buffer input has type uint16, but elem_size of the buffer_t passed in is ", input.elem_size, " instead of 2")
Codegen: handle64, "Input buffer input has type uint16, but elem_size of the buffer_t passed in is "
Codegen: int64, int64(input.elem_size)
Codegen: int32, input.elem_size
Codegen: handle64, " instead of 2"
Creating call to error handlers
Creating cleanup code
Codegen: assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))
assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((output.elem_size == 2), stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2"))

Codegen: uint1, (output.elem_size == 2)
Codegen: int32, output.elem_size
Codegen: int32, 2
Codegen: handle64, stringify("Output buffer output has type uint16, but elem_size of the buffer_t passed in is ", output.elem_size, " instead of 2")
Codegen: handle64, "Output buffer output has type uint16, but elem_size of the buffer_t passed in is "
Codegen: int64, int64(output.elem_size)
Codegen: int32, output.elem_size
Codegen: handle64, " instead of 2"
Creating call to error handlers
Creating cleanup code
Codegen: assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))
assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((i0.min.0 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0"))

Codegen: uint1, (i0.min.0 <= 0)
Codegen: uint1, !(i0.min.0 > 0)
Codegen: uint1, (i0.min.0 > 0)
Codegen: int32, i0.min.0
Codegen: int32, 0
Codegen: handle64, stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.0, ") in dimension 0")
Codegen: handle64, "Input buffer i0 is accessed at 0, which is before the min ("
Codegen: int64, int64(i0.min.0)
Codegen: int32, i0.min.0
Codegen: handle64, ") in dimension 0"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))
assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((5 - i0.extent.0) <= i0.min.0), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0"))

Codegen: uint1, ((5 - i0.extent.0) <= i0.min.0)
Codegen: uint1, !((5 - i0.extent.0) > i0.min.0)
Codegen: uint1, ((5 - i0.extent.0) > i0.min.0)
Codegen: int32, (5 - i0.extent.0)
Codegen: int32, i0.extent.0
Codegen: int32, 5
Codegen: int32, i0.min.0
Codegen: handle64, stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.0 + i0.extent.0) + -1), ") in dimension 0")
Codegen: handle64, "Input buffer i0 is accessed at 4, which is beyond the max ("
Codegen: int64, int64(((i0.min.0 + i0.extent.0) + -1))
Codegen: int32, ((i0.min.0 + i0.extent.0) + -1)
Codegen: int32, -1
Codegen: int32, (i0.min.0 + i0.extent.0)
Codegen: int32, i0.extent.0
Codegen: int32, i0.min.0
Codegen: handle64, ") in dimension 0"
Creating call to error handlers
Creating cleanup code
Codegen: assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))
assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((i0.min.1 <= 0), stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1"))

Codegen: uint1, (i0.min.1 <= 0)
Codegen: uint1, !(i0.min.1 > 0)
Codegen: uint1, (i0.min.1 > 0)
Codegen: int32, i0.min.1
Codegen: int32, 0
Codegen: handle64, stringify("Input buffer i0 is accessed at 0, which is before the min (", i0.min.1, ") in dimension 1")
Codegen: handle64, "Input buffer i0 is accessed at 0, which is before the min ("
Codegen: int64, int64(i0.min.1)
Codegen: int32, i0.min.1
Codegen: handle64, ") in dimension 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))
assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((5 - i0.extent.1) <= i0.min.1), stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1"))

Codegen: uint1, ((5 - i0.extent.1) <= i0.min.1)
Codegen: uint1, !((5 - i0.extent.1) > i0.min.1)
Codegen: uint1, ((5 - i0.extent.1) > i0.min.1)
Codegen: int32, (5 - i0.extent.1)
Codegen: int32, i0.extent.1
Codegen: int32, 5
Codegen: int32, i0.min.1
Codegen: handle64, stringify("Input buffer i0 is accessed at 4, which is beyond the max (", ((i0.min.1 + i0.extent.1) + -1), ") in dimension 1")
Codegen: handle64, "Input buffer i0 is accessed at 4, which is beyond the max ("
Codegen: int64, int64(((i0.min.1 + i0.extent.1) + -1))
Codegen: int32, ((i0.min.1 + i0.extent.1) + -1)
Codegen: int32, -1
Codegen: int32, (i0.min.1 + i0.extent.1)
Codegen: int32, i0.extent.1
Codegen: int32, i0.min.1
Codegen: handle64, ") in dimension 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))
assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((input.min.0 <= input.min.0.required), stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0"))

Codegen: uint1, (input.min.0 <= input.min.0.required)
Codegen: uint1, !(input.min.0 > input.min.0.required)
Codegen: uint1, (input.min.0 > input.min.0.required)
Codegen: int32, input.min.0
Codegen: int32, input.min.0.required
Codegen: handle64, stringify("Input buffer input is accessed at ", max(min((output.min.0 + -2), (input.extent.0 + -1)), 0), ", which is before the min (", input.min.0, ") in dimension 0")
Codegen: handle64, "Input buffer input is accessed at "
Codegen: int64, int64(max(min((output.min.0 + -2), (input.extent.0 + -1)), 0))
Codegen: int32, max(min((output.min.0 + -2), (input.extent.0 + -1)), 0)
Codegen: int32, min((output.min.0 + -2), (input.extent.0 + -1))
Codegen: int32, (output.min.0 + -2)
Codegen: int32, -2
Codegen: int32, output.min.0
Codegen: int32, (input.extent.0 + -1)
Codegen: int32, -1
Codegen: int32, input.extent.0
Codegen: int32, 0
Codegen: handle64, ", which is before the min ("
Codegen: int64, int64(input.min.0)
Codegen: int32, input.min.0
Codegen: handle64, ") in dimension 0"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))
assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0), stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0"))

Codegen: uint1, ((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) <= input.min.0)
Codegen: uint1, !((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) > input.min.0)
Codegen: uint1, ((((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1) > input.min.0)
Codegen: int32, (((input.min.0.required + input.extent.0.required.s) - input.extent.0) + 1)
Codegen: int32, 1
Codegen: int32, ((input.min.0.required + input.extent.0.required.s) - input.extent.0)
Codegen: int32, input.extent.0
Codegen: int32, (input.min.0.required + input.extent.0.required.s)
Codegen: int32, input.extent.0.required.s
Codegen: int32, input.min.0.required
Codegen: int32, input.min.0
Codegen: handle64, stringify("Input buffer input is accessed at ", (input.min.0.required + input.extent.0.required.s), ", which is beyond the max (", ((input.min.0 + input.extent.0) + -1), ") in dimension 0")
Codegen: handle64, "Input buffer input is accessed at "
Codegen: int64, int64((input.min.0.required + input.extent.0.required.s))
Codegen: int32, (input.min.0.required + input.extent.0.required.s)
Codegen: int32, input.extent.0.required.s
Codegen: int32, input.min.0.required
Codegen: handle64, ", which is beyond the max ("
Codegen: int64, int64(((input.min.0 + input.extent.0) + -1))
Codegen: int32, ((input.min.0 + input.extent.0) + -1)
Codegen: int32, -1
Codegen: int32, (input.min.0 + input.extent.0)
Codegen: int32, input.extent.0
Codegen: int32, input.min.0
Codegen: handle64, ") in dimension 0"
Creating call to error handlers
Creating cleanup code
Codegen: assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))
assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((input.min.1 <= input.min.1.required), stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1"))

Codegen: uint1, (input.min.1 <= input.min.1.required)
Codegen: uint1, !(input.min.1 > input.min.1.required)
Codegen: uint1, (input.min.1 > input.min.1.required)
Codegen: int32, input.min.1
Codegen: int32, input.min.1.required
Codegen: handle64, stringify("Input buffer input is accessed at ", max(min((output.min.1 + -2), (input.extent.1 + -1)), 0), ", which is before the min (", input.min.1, ") in dimension 1")
Codegen: handle64, "Input buffer input is accessed at "
Codegen: int64, int64(max(min((output.min.1 + -2), (input.extent.1 + -1)), 0))
Codegen: int32, max(min((output.min.1 + -2), (input.extent.1 + -1)), 0)
Codegen: int32, min((output.min.1 + -2), (input.extent.1 + -1))
Codegen: int32, (output.min.1 + -2)
Codegen: int32, -2
Codegen: int32, output.min.1
Codegen: int32, (input.extent.1 + -1)
Codegen: int32, -1
Codegen: int32, input.extent.1
Codegen: int32, 0
Codegen: handle64, ", which is before the min ("
Codegen: int64, int64(input.min.1)
Codegen: int32, input.min.1
Codegen: handle64, ") in dimension 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))
assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1), stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1"))

Codegen: uint1, ((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) <= input.min.1)
Codegen: uint1, !((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) > input.min.1)
Codegen: uint1, ((((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1) > input.min.1)
Codegen: int32, (((input.min.1.required + input.extent.1.required.s) - input.extent.1) + 1)
Codegen: int32, 1
Codegen: int32, ((input.min.1.required + input.extent.1.required.s) - input.extent.1)
Codegen: int32, input.extent.1
Codegen: int32, (input.min.1.required + input.extent.1.required.s)
Codegen: int32, input.extent.1.required.s
Codegen: int32, input.min.1.required
Codegen: int32, input.min.1
Codegen: handle64, stringify("Input buffer input is accessed at ", (input.min.1.required + input.extent.1.required.s), ", which is beyond the max (", ((input.min.1 + input.extent.1) + -1), ") in dimension 1")
Codegen: handle64, "Input buffer input is accessed at "
Codegen: int64, int64((input.min.1.required + input.extent.1.required.s))
Codegen: int32, (input.min.1.required + input.extent.1.required.s)
Codegen: int32, input.extent.1.required.s
Codegen: int32, input.min.1.required
Codegen: handle64, ", which is beyond the max ("
Codegen: int64, int64(((input.min.1 + input.extent.1) + -1))
Codegen: int32, ((input.min.1 + input.extent.1) + -1)
Codegen: int32, -1
Codegen: int32, (input.min.1 + input.extent.1)
Codegen: int32, input.extent.1
Codegen: int32, input.min.1
Codegen: handle64, ") in dimension 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))
assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((output.min.0 <= output.min.0.required), stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0"))

Codegen: uint1, (output.min.0 <= output.min.0.required)
Codegen: uint1, !(output.min.0 > output.min.0.required)
Codegen: uint1, (output.min.0 > output.min.0.required)
Codegen: int32, output.min.0
Codegen: int32, output.min.0.required
Codegen: handle64, stringify("Output buffer output is accessed at ", min(output.min.0, ((output.min.0 + output.extent.0) + -16)), ", which is before the min (", output.min.0, ") in dimension 0")
Codegen: handle64, "Output buffer output is accessed at "
Codegen: int64, int64(min(output.min.0, ((output.min.0 + output.extent.0) + -16)))
Codegen: int32, min(output.min.0, ((output.min.0 + output.extent.0) + -16))
Codegen: int32, output.min.0
Codegen: int32, ((output.min.0 + output.extent.0) + -16)
Codegen: int32, -16
Codegen: int32, (output.min.0 + output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, output.min.0
Codegen: handle64, ", which is before the min ("
Codegen: int64, int64(output.min.0)
Codegen: int32, output.min.0
Codegen: handle64, ") in dimension 0"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))
assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0), stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0"))

Codegen: uint1, ((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) <= output.min.0)
Codegen: uint1, !((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) > output.min.0)
Codegen: uint1, ((((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1) > output.min.0)
Codegen: int32, (((output.min.0.required + output.extent.0.required.s) - output.extent.0) + 1)
Codegen: int32, 1
Codegen: int32, ((output.min.0.required + output.extent.0.required.s) - output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, (output.min.0.required + output.extent.0.required.s)
Codegen: int32, output.extent.0.required.s
Codegen: int32, output.min.0.required
Codegen: int32, output.min.0
Codegen: handle64, stringify("Output buffer output is accessed at ", (output.min.0.required + output.extent.0.required.s), ", which is beyond the max (", ((output.min.0 + output.extent.0) + -1), ") in dimension 0")
Codegen: handle64, "Output buffer output is accessed at "
Codegen: int64, int64((output.min.0.required + output.extent.0.required.s))
Codegen: int32, (output.min.0.required + output.extent.0.required.s)
Codegen: int32, output.extent.0.required.s
Codegen: int32, output.min.0.required
Codegen: handle64, ", which is beyond the max ("
Codegen: int64, int64(((output.min.0 + output.extent.0) + -1))
Codegen: int32, ((output.min.0 + output.extent.0) + -1)
Codegen: int32, -1
Codegen: int32, (output.min.0 + output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, output.min.0
Codegen: handle64, ") in dimension 0"
Creating call to error handlers
Creating cleanup code
Codegen: assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))
assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((output.min.1 <= output.min.1.required), stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1"))

Codegen: uint1, (output.min.1 <= output.min.1.required)
Codegen: uint1, !(output.min.1 > output.min.1.required)
Codegen: uint1, (output.min.1 > output.min.1.required)
Codegen: int32, output.min.1
Codegen: int32, output.min.1.required
Codegen: handle64, stringify("Output buffer output is accessed at ", min(output.min.1, ((output.min.1 + output.extent.1) + -16)), ", which is before the min (", output.min.1, ") in dimension 1")
Codegen: handle64, "Output buffer output is accessed at "
Codegen: int64, int64(min(output.min.1, ((output.min.1 + output.extent.1) + -16)))
Codegen: int32, min(output.min.1, ((output.min.1 + output.extent.1) + -16))
Codegen: int32, output.min.1
Codegen: int32, ((output.min.1 + output.extent.1) + -16)
Codegen: int32, -16
Codegen: int32, (output.min.1 + output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, output.min.1
Codegen: handle64, ", which is before the min ("
Codegen: int64, int64(output.min.1)
Codegen: int32, output.min.1
Codegen: handle64, ") in dimension 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))
assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1), stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1"))

Codegen: uint1, ((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) <= output.min.1)
Codegen: uint1, !((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) > output.min.1)
Codegen: uint1, ((((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1) > output.min.1)
Codegen: int32, (((output.min.1.required + output.extent.1.required.s) - output.extent.1) + 1)
Codegen: int32, 1
Codegen: int32, ((output.min.1.required + output.extent.1.required.s) - output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, (output.min.1.required + output.extent.1.required.s)
Codegen: int32, output.extent.1.required.s
Codegen: int32, output.min.1.required
Codegen: int32, output.min.1
Codegen: handle64, stringify("Output buffer output is accessed at ", (output.min.1.required + output.extent.1.required.s), ", which is beyond the max (", ((output.min.1 + output.extent.1) + -1), ") in dimension 1")
Codegen: handle64, "Output buffer output is accessed at "
Codegen: int64, int64((output.min.1.required + output.extent.1.required.s))
Codegen: int32, (output.min.1.required + output.extent.1.required.s)
Codegen: int32, output.extent.1.required.s
Codegen: int32, output.min.1.required
Codegen: handle64, ", which is beyond the max ("
Codegen: int64, int64(((output.min.1 + output.extent.1) + -1))
Codegen: int32, ((output.min.1 + output.extent.1) + -1)
Codegen: int32, -1
Codegen: int32, (output.min.1 + output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, output.min.1
Codegen: handle64, ") in dimension 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")
assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((i0.stride.0 == 1), "Static constraint violated: i0.stride.0 == 1")

Codegen: uint1, (i0.stride.0 == 1)
Codegen: int32, i0.stride.0
Codegen: int32, 1
Codegen: handle64, "Static constraint violated: i0.stride.0 == 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")
assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((i0.min.0 == 0), "Static constraint violated: i0.min.0 == 0")

Codegen: uint1, (i0.min.0 == 0)
Codegen: int32, i0.min.0
Codegen: int32, 0
Codegen: handle64, "Static constraint violated: i0.min.0 == 0"
Creating call to error handlers
Creating cleanup code
Codegen: assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")
assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((i0.extent.0 == 5), "Static constraint violated: i0.extent.0 == 5")

Codegen: uint1, (i0.extent.0 == 5)
Codegen: int32, i0.extent.0
Codegen: int32, 5
Codegen: handle64, "Static constraint violated: i0.extent.0 == 5"
Creating call to error handlers
Creating cleanup code
Codegen: assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")
assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((i0.stride.1 == 5), "Static constraint violated: i0.stride.1 == 5")

Codegen: uint1, (i0.stride.1 == 5)
Codegen: int32, i0.stride.1
Codegen: int32, 5
Codegen: handle64, "Static constraint violated: i0.stride.1 == 5"
Creating call to error handlers
Creating cleanup code
Codegen: assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")
assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((i0.min.1 == 0), "Static constraint violated: i0.min.1 == 0")

Codegen: uint1, (i0.min.1 == 0)
Codegen: int32, i0.min.1
Codegen: int32, 0
Codegen: handle64, "Static constraint violated: i0.min.1 == 0"
Creating call to error handlers
Creating cleanup code
Codegen: assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")
assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((i0.extent.1 == 5), "Static constraint violated: i0.extent.1 == 5")

Codegen: uint1, (i0.extent.1 == 5)
Codegen: int32, i0.extent.1
Codegen: int32, 5
Codegen: handle64, "Static constraint violated: i0.extent.1 == 5"
Creating call to error handlers
Creating cleanup code
Codegen: assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")
assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((input.stride.0 == 1), "Static constraint violated: input.stride.0 == 1")

Codegen: uint1, (input.stride.0 == 1)
Codegen: int32, input.stride.0
Codegen: int32, 1
Codegen: handle64, "Static constraint violated: input.stride.0 == 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")
let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((output.stride.0 == 1), "Static constraint violated: output.stride.0 == 1")

Codegen: uint1, (output.stride.0 == 1)
Codegen: int32, output.stride.0
Codegen: int32, 1
Codegen: handle64, "Static constraint violated: output.stride.0 == 1"
Creating call to error handlers
Creating cleanup code
Codegen: let input.total_extent.1 = (int64(input.extent.1)*int64(input.extent.0))
let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: int64, (int64(input.extent.1)*int64(input.extent.0))
Codegen: int64, int64(input.extent.0)
Codegen: int32, input.extent.0
Codegen: int64, int64(input.extent.1)
Codegen: int32, input.extent.1
Codegen: let output.total_extent.1 = (int64(output.extent.1)*int64(output.extent.0))
assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: int64, (int64(output.extent.1)*int64(output.extent.0))
Codegen: int64, int64(output.extent.0)
Codegen: int32, output.extent.0
Codegen: int64, int64(output.extent.1)
Codegen: int32, output.extent.1
Codegen: assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((int64(5) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")

Codegen: uint1, (int64(5) <= int64(2147483647))
Codegen: uint1, !(int64(5) > int64(2147483647))
Codegen: uint1, (int64(5) > int64(2147483647))
Codegen: int64, int64(5)
Codegen: int32, 5
Codegen: int64, int64(2147483647)
Codegen: int32, 2147483647
Codegen: handle64, "Total allocation for buffer i0 exceeds 2^31 - 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")
assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((int64(5)*int64(5)) <= int64(2147483647)), "Total allocation for buffer i0 exceeds 2^31 - 1")

Codegen: uint1, ((int64(5)*int64(5)) <= int64(2147483647))
Codegen: uint1, !((int64(5)*int64(5)) > int64(2147483647))
Codegen: uint1, ((int64(5)*int64(5)) > int64(2147483647))
Codegen: int64, (int64(5)*int64(5))
Codegen: int64, int64(5)
Codegen: int32, 5
Codegen: int64, int64(5)
Codegen: int32, 5
Codegen: int64, int64(2147483647)
Codegen: int32, 2147483647
Codegen: handle64, "Total allocation for buffer i0 exceeds 2^31 - 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")
assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((int64(5)*int64(5)) <= int64(2147483647)), "Product of extents for buffer i0 exceeds 2^31 - 1")

Codegen: uint1, ((int64(5)*int64(5)) <= int64(2147483647))
Codegen: uint1, !((int64(5)*int64(5)) > int64(2147483647))
Codegen: uint1, ((int64(5)*int64(5)) > int64(2147483647))
Codegen: int64, (int64(5)*int64(5))
Codegen: int64, int64(5)
Codegen: int32, 5
Codegen: int64, int64(5)
Codegen: int32, 5
Codegen: int64, int64(2147483647)
Codegen: int32, 2147483647
Codegen: handle64, "Product of extents for buffer i0 exceeds 2^31 - 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((int64(input.extent.0) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")

Codegen: uint1, (int64(input.extent.0) <= int64(2147483647))
Codegen: uint1, !(int64(input.extent.0) > int64(2147483647))
Codegen: uint1, (int64(input.extent.0) > int64(2147483647))
Codegen: int64, int64(input.extent.0)
Codegen: int32, input.extent.0
Codegen: int64, int64(2147483647)
Codegen: int32, 2147483647
Codegen: handle64, "Total allocation for buffer input exceeds 2^31 - 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")
assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647)), "Total allocation for buffer input exceeds 2^31 - 1")

Codegen: uint1, ((int64(input.extent.1)*int64(input.stride.1)) <= int64(2147483647))
Codegen: uint1, !((int64(input.extent.1)*int64(input.stride.1)) > int64(2147483647))
Codegen: uint1, ((int64(input.extent.1)*int64(input.stride.1)) > int64(2147483647))
Codegen: int64, (int64(input.extent.1)*int64(input.stride.1))
Codegen: int64, int64(input.stride.1)
Codegen: int32, input.stride.1
Codegen: int64, int64(input.extent.1)
Codegen: int32, input.extent.1
Codegen: int64, int64(2147483647)
Codegen: int32, 2147483647
Codegen: handle64, "Total allocation for buffer input exceeds 2^31 - 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")
assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((input.total_extent.1 <= int64(2147483647)), "Product of extents for buffer input exceeds 2^31 - 1")

Codegen: uint1, (input.total_extent.1 <= int64(2147483647))
Codegen: uint1, !(input.total_extent.1 > int64(2147483647))
Codegen: uint1, (input.total_extent.1 > int64(2147483647))
Codegen: int64, input.total_extent.1
Codegen: int64, int64(2147483647)
Codegen: int32, 2147483647
Codegen: handle64, "Product of extents for buffer input exceeds 2^31 - 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((int64(output.extent.0) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")

Codegen: uint1, (int64(output.extent.0) <= int64(2147483647))
Codegen: uint1, !(int64(output.extent.0) > int64(2147483647))
Codegen: uint1, (int64(output.extent.0) > int64(2147483647))
Codegen: int64, int64(output.extent.0)
Codegen: int32, output.extent.0
Codegen: int64, int64(2147483647)
Codegen: int32, 2147483647
Codegen: handle64, "Total allocation for buffer output exceeds 2^31 - 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")
assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert(((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647)), "Total allocation for buffer output exceeds 2^31 - 1")

Codegen: uint1, ((int64(output.extent.1)*int64(output.stride.1)) <= int64(2147483647))
Codegen: uint1, !((int64(output.extent.1)*int64(output.stride.1)) > int64(2147483647))
Codegen: uint1, ((int64(output.extent.1)*int64(output.stride.1)) > int64(2147483647))
Codegen: int64, (int64(output.extent.1)*int64(output.stride.1))
Codegen: int64, int64(output.stride.1)
Codegen: int32, output.stride.1
Codegen: int64, int64(output.extent.1)
Codegen: int32, output.extent.1
Codegen: int64, int64(2147483647)
Codegen: int32, 2147483647
Codegen: handle64, "Total allocation for buffer output exceeds 2^31 - 1"
Creating call to error handlers
Creating cleanup code
Codegen: assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")
let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((output.total_extent.1 <= int64(2147483647)), "Product of extents for buffer output exceeds 2^31 - 1")

Codegen: uint1, (output.total_extent.1 <= int64(2147483647))
Codegen: uint1, !(output.total_extent.1 > int64(2147483647))
Codegen: uint1, (output.total_extent.1 > int64(2147483647))
Codegen: int64, output.total_extent.1
Codegen: int64, int64(2147483647)
Codegen: int32, 2147483647
Codegen: handle64, "Product of extents for buffer output exceeds 2^31 - 1"
Creating call to error handlers
Creating cleanup code
Codegen: let blur.y.min_realized = min(((output.min.1 + output.extent.1) + -16), output.min.1)
let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: int32, min(((output.min.1 + output.extent.1) + -16), output.min.1)
Codegen: int32, ((output.min.1 + output.extent.1) + -16)
Codegen: int32, -16
Codegen: int32, (output.min.1 + output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, output.min.1
Codegen: int32, output.min.1
Codegen: let blur.y.extent_realized.s.s = max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: int32, max(((output.min.1 + output.extent.1) + -1), min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1)))
Codegen: int32, ((output.min.1 + output.extent.1) + -1)
Codegen: int32, -1
Codegen: int32, (output.min.1 + output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, output.min.1
Codegen: int32, min((((((output.extent.1 + -1)/16)*16) + output.min.1) + 15), ((output.min.1 + output.extent.1) + -1))
Codegen: int32, (((((output.extent.1 + -1)/16)*16) + output.min.1) + 15)
Codegen: int32, 15
Codegen: int32, ((((output.extent.1 + -1)/16)*16) + output.min.1)
Codegen: int32, output.min.1
Codegen: int32, (((output.extent.1 + -1)/16)*16)
Codegen: int32, 16
Codegen: int32, ((output.extent.1 + -1)/16)
Codegen: int32, (output.extent.1 + -1)
Codegen: int32, -1
Codegen: int32, output.extent.1
Codegen: int32, ((output.min.1 + output.extent.1) + -1)
Codegen: int32, -1
Codegen: int32, (output.min.1 + output.extent.1)
Codegen: int32, output.extent.1
Codegen: int32, output.min.1
Codegen: let blur.x.min_realized = min(((output.min.0 + output.extent.0) + -128), output.min.0)
let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: int32, min(((output.min.0 + output.extent.0) + -128), output.min.0)
Codegen: int32, ((output.min.0 + output.extent.0) + -128)
Codegen: int32, -128
Codegen: int32, (output.min.0 + output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, output.min.0
Codegen: int32, output.min.0
Codegen: let blur.x.extent_realized.s.s = max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: int32, max(((output.min.0 + output.extent.0) + -1), min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1)))
Codegen: int32, ((output.min.0 + output.extent.0) + -1)
Codegen: int32, -1
Codegen: int32, (output.min.0 + output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, output.min.0
Codegen: int32, min((((((output.extent.0 + -1)/16)*16) + output.min.0) + 15), ((output.min.0 + output.extent.0) + -1))
Codegen: int32, (((((output.extent.0 + -1)/16)*16) + output.min.0) + 15)
Codegen: int32, 15
Codegen: int32, ((((output.extent.0 + -1)/16)*16) + output.min.0)
Codegen: int32, output.min.0
Codegen: int32, (((output.extent.0 + -1)/16)*16)
Codegen: int32, 16
Codegen: int32, ((output.extent.0 + -1)/16)
Codegen: int32, (output.extent.0 + -1)
Codegen: int32, -1
Codegen: int32, output.extent.0
Codegen: int32, ((output.min.0 + output.extent.0) + -1)
Codegen: int32, -1
Codegen: int32, (output.min.0 + output.extent.0)
Codegen: int32, output.extent.0
Codegen: int32, output.min.0
Codegen: allocate blur[float32 * ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) * ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)]
let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: int64, int64(((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
Codegen: int32, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)
Codegen: int32, 1
Codegen: int32, (blur.x.extent_realized.s.s - blur.x.min_realized)
Codegen: int32, blur.x.min_realized
Codegen: int32, blur.x.extent_realized.s.s
Codegen: int64, int64(((blur.y.extent_realized.s.s - blur.y.min_realized) + 1))
Codegen: int32, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)
Codegen: int32, 1
Codegen: int32, (blur.y.extent_realized.s.s - blur.y.min_realized)
Codegen: int32, blur.y.min_realized
Codegen: int32, blur.y.extent_realized.s.s
Codegen: handle64, "32-bit signed overflow computing size of allocation blur"
Creating call to error handlers
Creating cleanup code
Codegen: uint1, uint1(1)
Codegen: int32, 1
Creating call to halide_malloc for allocation blur of size 4 x ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1) x ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)
Codegen: handle64, "Out of memory (malloc returned NULL)"
Creating call to error handlers
Creating cleanup code
Pushing allocation called blur.host onto the symbol table
Codegen: let blur.buffer = create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: handle64, create_buffer_t(address_of(blur[0]), 4, blur.x.min_realized, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1), 1, blur.y.min_realized, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1), ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))
Codegen: handle64, address_of(blur[0])
Codegen: int64, int64(0)
Codegen: int32, 0
Codegen: int32, 4
Codegen: int32, blur.x.min_realized
Codegen: int32, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)
Codegen: int32, 1
Codegen: int32, (blur.x.extent_realized.s.s - blur.x.min_realized)
Codegen: int32, blur.x.min_realized
Codegen: int32, blur.x.extent_realized.s.s
Codegen: int32, 1
Codegen: int32, blur.y.min_realized
Codegen: int32, ((blur.y.extent_realized.s.s - blur.y.min_realized) + 1)
Codegen: int32, 1
Codegen: int32, (blur.y.extent_realized.s.s - blur.y.min_realized)
Codegen: int32, blur.y.min_realized
Codegen: int32, blur.y.extent_realized.s.s
Codegen: int32, ((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)
Codegen: int32, 1
Codegen: int32, (blur.x.extent_realized.s.s - blur.x.min_realized)
Codegen: int32, blur.x.min_realized
Codegen: int32, blur.x.extent_realized.s.s
Codegen: assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")
produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((halide_dev_malloc(blur.buffer) == 0), "Failed to allocate device buffer for blur")

Codegen: uint1, (halide_dev_malloc(blur.buffer) == 0)
Codegen: int32, halide_dev_malloc(blur.buffer)
Codegen: handle64, blur.buffer
Found halide_dev_malloc
Adding user_context to halide_dev_malloc args
Creating scalar call to halide_dev_malloc
Codegen: int32, 0
Codegen: handle64, "Failed to allocate device buffer for blur"
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: produce blur {
  parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
    let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
    parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
      parallel (.__thread_id_y, 0, 8) {
        parallel (.__thread_id_x, 0, 16) {
          let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
          blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
        }
      }
    }
  }
  set_dev_dirty(blur.buffer, uint8(1))
} update blur {
  assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
  assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
  assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
  for (blur.s1.y, output.min.1, output.extent.1) {
    for (blur.s1.x, output.min.0, output.extent.0) {
      for (blur.s1.i0.y$r, 0, 5) {
        for (blur.s1.i0.x$r, 0, 5) {
          blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
        }
      }
    }
  }
  set_host_dirty(blur.buffer, uint8(1))
}
assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
  let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
  parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
    parallel (.__thread_id_y, 0, 8) {
      parallel (.__thread_id_x, 0, 16) {
        let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
        blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
      }
    }
  }
}
set_dev_dirty(blur.buffer, uint8(1))

Codegen: parallel (blur.s0.y.__block_id_y, 0, ((output.extent.1 + 7)/8)) {
  let blur.s0.y.__thread_id_y.base = min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
  parallel (blur.s0.x.x.__block_id_x, 0, ((output.extent.0 + 127)/128)) {
    parallel (.__thread_id_y, 0, 8) {
      parallel (.__thread_id_x, 0, 16) {
        let blur.s0.s1.base = min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
        blur[ramp((((blur.s0.s1.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((blur.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)] = x8(0.000000f)
      }
    }
  }
}

Kernel launch: blur.s0.y.__block_id_y
output.extent.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
Bounds of min(((blur.s0.y.__block_id_y*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
min(((0*8) + output.min.1), ((output.min.1 + output.extent.1) + -8)), min(((((0 + ((output.extent.1 + 7)/8)) - 1)*8) + output.min.1), ((output.min.1 + output.extent.1) + -8))
output.extent.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
Bounds of min(((blur.s0.x.x.__block_id_x*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
min(((0*128) + output.min.0), ((output.min.0 + output.extent.0) + -128)), min(((((0 + ((output.extent.0 + 127)/128)) - 1)*128) + output.min.0), ((output.min.0 + output.extent.0) + -128))
Kernel bounds: (16, 8, 1, 1) threads, (((output.extent.0 + 127)/128), ((output.extent.1 + 7)/8), 1, 1) blocks
Codegen: int32, 0
Adding output.extent.1 to closure
Not adding blur.s0.y.__block_id_y to closure
Adding output.min.1 to closure
Adding output.min.1 to closure
Adding output.extent.1 to closure
Adding output.extent.0 to closure
Not adding blur.s0.x.x.__block_id_x to closure
Adding output.min.0 to closure
Adding output.min.0 to closure
Adding output.extent.0 to closure
Not adding blur.s0.s1.base to closure
Not adding .__thread_id_x to closure
Adding blur.x.min_realized to closure
Not adding blur.s0.y.__thread_id_y.base to closure
Not adding .__thread_id_y to closure
Adding blur.y.min_realized to closure
Adding blur.x.extent_realized.s.s to closure
Adding blur.x.min_realized to closure
Adding buffer blur to closure
var: blur.x.extent_realized.s.s
var: blur.x.min_realized
var: blur.y.min_realized
var: output.extent.0
var: output.extent.1
var: output.min.0
var: output.min.1
buffer: blur 0 (write)
CodeGen_OpenCL_Dev::compile kernel_blur_s0_y___block_id_y
Adding OpenCL kernel kernel_blur_s0_y___block_id_y
Compiled launch to kernel "kernel_blur_s0_y___block_id_y"
Created device module state global variable
Codegen: int32, ((output.extent.0 + 127)/128)
Codegen: int32, (output.extent.0 + 127)
Codegen: int32, 127
Codegen: int32, output.extent.0
Codegen: int32, ((output.extent.1 + 7)/8)
Codegen: int32, (output.extent.1 + 7)
Codegen: int32, 7
Codegen: int32, output.extent.1
Codegen: int32, 1
Codegen: int32, 16
Codegen: int32, 8
Codegen: int32, 1
Codegen: int32, 0
Codegen: handle64, "Failure inside halide_dev_run"
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: set_dev_dirty(blur.buffer, uint8(1))

Codegen: int32, set_dev_dirty(blur.buffer, uint8(1))
Codegen: handle64, blur.buffer
Codegen: uint8, uint8(1)
Codegen: int32, 1
Codegen: assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")
assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
for (blur.s1.y, output.min.1, output.extent.1) {
  for (blur.s1.x, output.min.0, output.extent.0) {
    for (blur.s1.i0.y$r, 0, 5) {
      for (blur.s1.i0.x$r, 0, 5) {
        blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
      }
    }
  }
}
set_host_dirty(blur.buffer, uint8(1))

Codegen: assert((halide_copy_to_host(input.buffer) == 0), "Failed to copy buffer input to host.")

Codegen: uint1, (halide_copy_to_host(input.buffer) == 0)
Codegen: int32, halide_copy_to_host(input.buffer)
Codegen: handle64, input.buffer
Found halide_copy_to_host
Adding user_context to halide_copy_to_host args
Creating scalar call to halide_copy_to_host
Codegen: int32, 0
Codegen: handle64, "Failed to copy buffer input to host."
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")
assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
for (blur.s1.y, output.min.1, output.extent.1) {
  for (blur.s1.x, output.min.0, output.extent.0) {
    for (blur.s1.i0.y$r, 0, 5) {
      for (blur.s1.i0.x$r, 0, 5) {
        blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
      }
    }
  }
}
set_host_dirty(blur.buffer, uint8(1))

Codegen: assert((halide_copy_to_host(i0.buffer) == 0), "Failed to copy buffer i0 to host.")

Codegen: uint1, (halide_copy_to_host(i0.buffer) == 0)
Codegen: int32, halide_copy_to_host(i0.buffer)
Codegen: handle64, i0.buffer
Found halide_copy_to_host
Adding user_context to halide_copy_to_host args
Creating scalar call to halide_copy_to_host
Codegen: int32, 0
Codegen: handle64, "Failed to copy buffer i0 to host."
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")
for (blur.s1.y, output.min.1, output.extent.1) {
  for (blur.s1.x, output.min.0, output.extent.0) {
    for (blur.s1.i0.y$r, 0, 5) {
      for (blur.s1.i0.x$r, 0, 5) {
        blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
      }
    }
  }
}
set_host_dirty(blur.buffer, uint8(1))

Codegen: assert((halide_copy_to_host(blur.buffer) == 0), "Failed to copy buffer blur to host.")

Codegen: uint1, (halide_copy_to_host(blur.buffer) == 0)
Codegen: int32, halide_copy_to_host(blur.buffer)
Codegen: handle64, blur.buffer
Found halide_copy_to_host
Adding user_context to halide_copy_to_host args
Creating scalar call to halide_copy_to_host
Codegen: int32, 0
Codegen: handle64, "Failed to copy buffer blur to host."
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: for (blur.s1.y, output.min.1, output.extent.1) {
  for (blur.s1.x, output.min.0, output.extent.0) {
    for (blur.s1.i0.y$r, 0, 5) {
      for (blur.s1.i0.x$r, 0, 5) {
        blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
      }
    }
  }
}
set_host_dirty(blur.buffer, uint8(1))

Codegen: for (blur.s1.y, output.min.1, output.extent.1) {
  for (blur.s1.x, output.min.0, output.extent.0) {
    for (blur.s1.i0.y$r, 0, 5) {
      for (blur.s1.i0.x$r, 0, 5) {
        blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
      }
    }
  }
}

Codegen: int32, output.min.1
Codegen: int32, output.extent.1
Codegen: for (blur.s1.x, output.min.0, output.extent.0) {
  for (blur.s1.i0.y$r, 0, 5) {
    for (blur.s1.i0.x$r, 0, 5) {
      blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
    }
  }
}

Codegen: int32, output.min.0
Codegen: int32, output.extent.0
Codegen: for (blur.s1.i0.y$r, 0, 5) {
  for (blur.s1.i0.x$r, 0, 5) {
    blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
  }
}

Codegen: int32, 0
Codegen: int32, 5
Codegen: for (blur.s1.i0.x$r, 0, 5) {
  blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
}

Codegen: int32, 0
Codegen: int32, 5
Codegen: blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] = (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))

Codegen: float32, (blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))] + ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f))
Codegen: float32, ((float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))*0.003663f)
Codegen: float32, 0.003663f
Codegen: float32, (float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])*(float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f))
Codegen: float32, (float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])*0.000015f)
Codegen: float32, 0.000015f
Codegen: float32, float32(input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))])
Codegen: uint16, input[((max(min(((blur.s1.x + blur.s1.i0.x$r) + -2), (input.extent.0 + -1)), 0) + (max(min(((blur.s1.y + blur.s1.i0.y$r) + -2), (input.extent.1 + -1)), 0)*input.stride.1)) - (input.min.0 + (input.min.1*input.stride.1)))]
Codegen: int64, ((max(min(((int64(blur.s1.x) + int64(blur.s1.i0.x$r)) + int64(-2)), (int64(input.extent.0) + int64(-1))), int64(0)) + (max(min(((int64(blur.s1.y) + int64(blur.s1.i0.y$r)) + int64(-2)), (int64(input.extent.1) + int64(-1))), int64(0))*int64(input.stride.1))) - (int64(input.min.0) + (int64(input.min.1)*int64(input.stride.1))))
Codegen: int64, (int64(input.min.0) + (int64(input.min.1)*int64(input.stride.1)))
Codegen: int64, (int64(input.min.1)*int64(input.stride.1))
Codegen: int64, int64(input.stride.1)
Codegen: int32, input.stride.1
Codegen: int64, int64(input.min.1)
Codegen: int32, input.min.1
Codegen: int64, int64(input.min.0)
Codegen: int32, input.min.0
Codegen: int64, (max(min(((int64(blur.s1.x) + int64(blur.s1.i0.x$r)) + int64(-2)), (int64(input.extent.0) + int64(-1))), int64(0)) + (max(min(((int64(blur.s1.y) + int64(blur.s1.i0.y$r)) + int64(-2)), (int64(input.extent.1) + int64(-1))), int64(0))*int64(input.stride.1)))
Codegen: int64, (max(min(((int64(blur.s1.y) + int64(blur.s1.i0.y$r)) + int64(-2)), (int64(input.extent.1) + int64(-1))), int64(0))*int64(input.stride.1))
Codegen: int64, int64(input.stride.1)
Codegen: int32, input.stride.1
Codegen: int64, max(min(((int64(blur.s1.y) + int64(blur.s1.i0.y$r)) + int64(-2)), (int64(input.extent.1) + int64(-1))), int64(0))
Codegen: int64, min(((int64(blur.s1.y) + int64(blur.s1.i0.y$r)) + int64(-2)), (int64(input.extent.1) + int64(-1)))
Codegen: int64, ((int64(blur.s1.y) + int64(blur.s1.i0.y$r)) + int64(-2))
Codegen: int64, int64(-2)
Codegen: int32, -2
Codegen: int64, (int64(blur.s1.y) + int64(blur.s1.i0.y$r))
Codegen: int64, int64(blur.s1.i0.y$r)
Codegen: int32, blur.s1.i0.y$r
Codegen: int64, int64(blur.s1.y)
Codegen: int32, blur.s1.y
Codegen: int64, (int64(input.extent.1) + int64(-1))
Codegen: int64, int64(-1)
Codegen: int32, -1
Codegen: int64, int64(input.extent.1)
Codegen: int32, input.extent.1
Codegen: int64, int64(0)
Codegen: int32, 0
Codegen: int64, max(min(((int64(blur.s1.x) + int64(blur.s1.i0.x$r)) + int64(-2)), (int64(input.extent.0) + int64(-1))), int64(0))
Codegen: int64, min(((int64(blur.s1.x) + int64(blur.s1.i0.x$r)) + int64(-2)), (int64(input.extent.0) + int64(-1)))
Codegen: int64, ((int64(blur.s1.x) + int64(blur.s1.i0.x$r)) + int64(-2))
Codegen: int64, int64(-2)
Codegen: int32, -2
Codegen: int64, (int64(blur.s1.x) + int64(blur.s1.i0.x$r))
Codegen: int64, int64(blur.s1.i0.x$r)
Codegen: int32, blur.s1.i0.x$r
Codegen: int64, int64(blur.s1.x)
Codegen: int32, blur.s1.x
Codegen: int64, (int64(input.extent.0) + int64(-1))
Codegen: int64, int64(-1)
Codegen: int32, -1
Codegen: int64, int64(input.extent.0)
Codegen: int32, input.extent.0
Codegen: int64, int64(0)
Codegen: int32, 0
Codegen: float32, float32(i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))])
Codegen: uint16, i0[(blur.s1.i0.x$r + (blur.s1.i0.y$r*5))]
Codegen: int64, (int64(blur.s1.i0.x$r) + (int64(blur.s1.i0.y$r)*int64(5)))
Codegen: int64, (int64(blur.s1.i0.y$r)*int64(5))
Codegen: int64, int64(5)
Codegen: int32, 5
Codegen: int64, int64(blur.s1.i0.y$r)
Codegen: int32, blur.s1.i0.y$r
Codegen: int64, int64(blur.s1.i0.x$r)
Codegen: int32, blur.s1.i0.x$r
Codegen: float32, blur[((blur.s1.x - blur.x.min_realized) + ((blur.s1.y - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1)))]
Codegen: int64, ((int64(blur.s1.x) - int64(blur.x.min_realized)) + ((int64(blur.s1.y) - int64(blur.y.min_realized))*((int64(blur.x.extent_realized.s.s) - int64(blur.x.min_realized)) + int64(1))))
Codegen: int64, ((int64(blur.s1.y) - int64(blur.y.min_realized))*((int64(blur.x.extent_realized.s.s) - int64(blur.x.min_realized)) + int64(1)))
Codegen: int64, ((int64(blur.x.extent_realized.s.s) - int64(blur.x.min_realized)) + int64(1))
Codegen: int64, int64(1)
Codegen: int32, 1
Codegen: int64, (int64(blur.x.extent_realized.s.s) - int64(blur.x.min_realized))
Codegen: int64, int64(blur.x.min_realized)
Codegen: int32, blur.x.min_realized
Codegen: int64, int64(blur.x.extent_realized.s.s)
Codegen: int32, blur.x.extent_realized.s.s
Codegen: int64, (int64(blur.s1.y) - int64(blur.y.min_realized))
Codegen: int64, int64(blur.y.min_realized)
Codegen: int32, blur.y.min_realized
Codegen: int64, int64(blur.s1.y)
Codegen: int32, blur.s1.y
Codegen: int64, (int64(blur.s1.x) - int64(blur.x.min_realized))
Codegen: int64, int64(blur.x.min_realized)
Codegen: int32, blur.x.min_realized
Codegen: int64, int64(blur.s1.x)
Codegen: int32, blur.s1.x
Codegen: int64, ((int64(blur.s1.x) - int64(blur.x.min_realized)) + ((int64(blur.s1.y) - int64(blur.y.min_realized))*((int64(blur.x.extent_realized.s.s) - int64(blur.x.min_realized)) + int64(1))))
Codegen: int64, ((int64(blur.s1.y) - int64(blur.y.min_realized))*((int64(blur.x.extent_realized.s.s) - int64(blur.x.min_realized)) + int64(1)))
Codegen: int64, ((int64(blur.x.extent_realized.s.s) - int64(blur.x.min_realized)) + int64(1))
Codegen: int64, int64(1)
Codegen: int32, 1
Codegen: int64, (int64(blur.x.extent_realized.s.s) - int64(blur.x.min_realized))
Codegen: int64, int64(blur.x.min_realized)
Codegen: int32, blur.x.min_realized
Codegen: int64, int64(blur.x.extent_realized.s.s)
Codegen: int32, blur.x.extent_realized.s.s
Codegen: int64, (int64(blur.s1.y) - int64(blur.y.min_realized))
Codegen: int64, int64(blur.y.min_realized)
Codegen: int32, blur.y.min_realized
Codegen: int64, int64(blur.s1.y)
Codegen: int32, blur.s1.y
Codegen: int64, (int64(blur.s1.x) - int64(blur.x.min_realized))
Codegen: int64, int64(blur.x.min_realized)
Codegen: int32, blur.x.min_realized
Codegen: int64, int64(blur.s1.x)
Codegen: int32, blur.s1.x
Codegen: set_host_dirty(blur.buffer, uint8(1))

Codegen: int32, set_host_dirty(blur.buffer, uint8(1))
Codegen: handle64, blur.buffer
Codegen: uint8, uint8(1)
Codegen: int32, 1
Codegen: assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")
produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((halide_dev_malloc(output.buffer) == 0), "Failed to allocate device buffer for output")

Codegen: uint1, (halide_dev_malloc(output.buffer) == 0)
Codegen: int32, halide_dev_malloc(output.buffer)
Codegen: handle64, output.buffer
Found halide_dev_malloc
Adding user_context to halide_dev_malloc args
Creating scalar call to halide_dev_malloc
Codegen: int32, 0
Codegen: handle64, "Failed to allocate device buffer for output"
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: produce output {
  assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
  assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
  parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
    let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
    parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
      parallel (.__thread_id_y, 0, 16) {
        parallel (.__thread_id_x, 0, 2) {
          let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
          output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
        }
      }
    }
  }
  assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
  free blur
  set_dev_dirty(output.buffer, uint8(1))
}
0

Codegen: assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")
assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
  let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
  parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
    parallel (.__thread_id_y, 0, 16) {
      parallel (.__thread_id_x, 0, 2) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
        output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
      }
    }
  }
}
assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
free blur
set_dev_dirty(output.buffer, uint8(1))

Codegen: assert((halide_copy_to_dev(output.buffer) == 0), "Failed to copy buffer output to dev.")

Codegen: uint1, (halide_copy_to_dev(output.buffer) == 0)
Codegen: int32, halide_copy_to_dev(output.buffer)
Codegen: handle64, output.buffer
Found halide_copy_to_dev
Adding user_context to halide_copy_to_dev args
Creating scalar call to halide_copy_to_dev
Codegen: int32, 0
Codegen: handle64, "Failed to copy buffer output to dev."
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")
parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
  let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
  parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
    parallel (.__thread_id_y, 0, 16) {
      parallel (.__thread_id_x, 0, 2) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
        output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
      }
    }
  }
}
assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
free blur
set_dev_dirty(output.buffer, uint8(1))

Codegen: assert((halide_copy_to_dev(blur.buffer) == 0), "Failed to copy buffer blur to dev.")

Codegen: uint1, (halide_copy_to_dev(blur.buffer) == 0)
Codegen: int32, halide_copy_to_dev(blur.buffer)
Codegen: handle64, blur.buffer
Found halide_copy_to_dev
Adding user_context to halide_copy_to_dev args
Creating scalar call to halide_copy_to_dev
Codegen: int32, 0
Codegen: handle64, "Failed to copy buffer blur to dev."
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
  let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
  parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
    parallel (.__thread_id_y, 0, 16) {
      parallel (.__thread_id_x, 0, 2) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
        output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
      }
    }
  }
}
assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
free blur
set_dev_dirty(output.buffer, uint8(1))

Codegen: parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
  let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
  parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
    parallel (.__thread_id_y, 0, 16) {
      parallel (.__thread_id_x, 0, 2) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
        output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
      }
    }
  }
}
assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
free blur

Codegen: parallel (output.s0.y.__block_id_y, 0, ((output.extent.1 + 15)/16)) {
  let output.s0.y.__thread_id_y.base = min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
  parallel (output.s0.x.x.__block_id_x, 0, ((output.extent.0 + 15)/16)) {
    parallel (.__thread_id_y, 0, 16) {
      parallel (.__thread_id_x, 0, 2) {
        let output.s0.s0.base = min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
        output[ramp((((output.s0.s0.base + (.__thread_id_x*8)) + ((output.s0.y.__thread_id_y.base + .__thread_id_y)*output.stride.1)) - (output.min.0 + (output.min.1*output.stride.1))), 1, 8)] = uint16x8((max(min(blur[ramp((((output.s0.s0.base + (.__thread_id_x*8)) - blur.x.min_realized) + (((output.s0.y.__thread_id_y.base + .__thread_id_y) - blur.y.min_realized)*((blur.x.extent_realized.s.s - blur.x.min_realized) + 1))), 1, 8)], x8(1.000000f)), x8(0.000000f))*x8(65535.000000f)))
      }
    }
  }
}

Kernel launch: output.s0.y.__block_id_y
output.extent.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.min.1 not in scope, so leaving it as-is
output.extent.1 not in scope, so leaving it as-is
Bounds of min(((output.s0.y.__block_id_y*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
min(((0*16) + output.min.1), ((output.min.1 + output.extent.1) + -16)), min(((((0 + ((output.extent.1 + 15)/16)) - 1)*16) + output.min.1), ((output.min.1 + output.extent.1) + -16))
output.extent.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.min.0 not in scope, so leaving it as-is
output.extent.0 not in scope, so leaving it as-is
Bounds of min(((output.s0.x.x.__block_id_x*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
min(((0*16) + output.min.0), ((output.min.0 + output.extent.0) + -16)), min(((((0 + ((output.extent.0 + 15)/16)) - 1)*16) + output.min.0), ((output.min.0 + output.extent.0) + -16))
Kernel bounds: (2, 16, 1, 1) threads, (((output.extent.0 + 15)/16), ((output.extent.1 + 15)/16), 1, 1) blocks
Codegen: int32, 0
Adding output.extent.1 to closure
Not adding output.s0.y.__block_id_y to closure
Adding output.min.1 to closure
Adding output.min.1 to closure
Adding output.extent.1 to closure
Adding output.extent.0 to closure
Not adding output.s0.x.x.__block_id_x to closure
Adding output.min.0 to closure
Adding output.min.0 to closure
Adding output.extent.0 to closure
Not adding output.s0.s0.base to closure
Not adding .__thread_id_x to closure
Not adding output.s0.y.__thread_id_y.base to closure
Not adding .__thread_id_y to closure
Adding output.stride.1 to closure
Adding output.min.0 to closure
Adding output.min.1 to closure
Adding output.stride.1 to closure
Not adding output.s0.s0.base to closure
Not adding .__thread_id_x to closure
Adding blur.x.min_realized to closure
Not adding output.s0.y.__thread_id_y.base to closure
Not adding .__thread_id_y to closure
Adding blur.y.min_realized to closure
Adding blur.x.extent_realized.s.s to closure
Adding blur.x.min_realized to closure
Adding buffer blur to closure
Adding buffer output to closure
var: blur.x.extent_realized.s.s
var: blur.x.min_realized
var: blur.y.min_realized
var: output.extent.0
var: output.extent.1
var: output.min.0
var: output.min.1
var: output.stride.1
buffer: blur 0 (read)
buffer: output 0 (write)
CodeGen_OpenCL_Dev::compile kernel_output_s0_y___block_id_y
Adding OpenCL kernel kernel_output_s0_y___block_id_y
Compiled launch to kernel "kernel_output_s0_y___block_id_y"
Codegen: int32, ((output.extent.0 + 15)/16)
Codegen: int32, (output.extent.0 + 15)
Codegen: int32, 15
Codegen: int32, output.extent.0
Codegen: int32, ((output.extent.1 + 15)/16)
Codegen: int32, (output.extent.1 + 15)
Codegen: int32, 15
Codegen: int32, output.extent.1
Codegen: int32, 1
Codegen: int32, 2
Codegen: int32, 16
Codegen: int32, 1
Codegen: int32, 0
Codegen: handle64, "Failure inside halide_dev_run"
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")
free blur

Codegen: assert((halide_dev_free(blur.buffer) == 0), "Failed to free device buffer for blur")

Codegen: uint1, (halide_dev_free(blur.buffer) == 0)
Codegen: int32, halide_dev_free(blur.buffer)
Codegen: handle64, blur.buffer
Found halide_dev_free
Adding user_context to halide_dev_free args
Creating scalar call to halide_dev_free
Codegen: int32, 0
Codegen: handle64, "Failed to free device buffer for blur"
Creating call to error handlers
Creating cleanup code
Creating call to halide_free
Codegen: free blur

Creating call to halide_free
Codegen: set_dev_dirty(output.buffer, uint8(1))

Codegen: int32, set_dev_dirty(output.buffer, uint8(1))
Codegen: handle64, output.buffer
Codegen: uint8, uint8(1)
Codegen: int32, 1
Codegen: 0

Codegen: int32, 0
0x23827d0
Creating call from wrapper to actual function
Done generating llvm bitcode
OpenCL kernel:
/*OpenCL C*/
#pragma OPENCL FP_CONTRACT ON
float maxval_f32() {return FLT_MAX;}
float minval_f32() {return -FLT_MAX;}
float nan_f32() { return NAN; }
float neg_inf_f32() { return -INFINITY; }
bool is_nan_f32(float x) {return x != x; }
float inf_f32() { return INFINITY; }
float float_from_bits(unsigned int x) {return as_float(x);}
char smod_char(char a, char b) {
char r = a % b;
if (r < 0) { r += b < 0 ? -b : b; }
return r;
}

short smod_short(short a, short b) {
short r = a % b;
if (r < 0) { r += b < 0 ? -b : b; }
return r;
}

int smod_int(int a, int b) {
int r = a % b;
if (r < 0) { r += b < 0 ? -b : b; }
return r;
}

char sdiv_char(char a, char b) {
char q = a / b;
char r = a - q*b;
char bs = b >> (8*sizeof(char) - 1);
char rs = r >> (8*sizeof(char) - 1);
return q - (rs&bs) + (rs&~bs);
}

short sdiv_short(short a, short b) {
short q = a / b;
short r = a - q*b;
short bs = b >> (8*sizeof(short) - 1);
short rs = r >> (8*sizeof(short) - 1);
return q - (rs&bs) + (rs&~bs);
}

int sdiv_int(int a, int b) {
int q = a / b;
int r = a - q*b;
int bs = b >> (8*sizeof(int) - 1);
int rs = r >> (8*sizeof(int) - 1);
return q - (rs&bs) + (rs&~bs);
}

#define sqrt_f32 sqrt 
#define sin_f32 sin 
#define cos_f32 cos 
#define exp_f32 exp 
#define log_f32 log 
#define abs_f32 fabs 
#define floor_f32 floor 
#define ceil_f32 ceil 
#define round_f32 round 
#define trunc_f32 trunc 
#define pow_f32 pow
#define asin_f32 asin 
#define acos_f32 acos 
#define tan_f32 tan 
#define atan_f32 atan 
#define atan2_f32 atan2
#define sinh_f32 sinh 
#define asinh_f32 asinh 
#define cosh_f32 cosh 
#define acosh_f32 acosh 
#define tanh_f32 tanh 
#define atanh_f32 atanh 
#define fast_inverse_f32 native_recip 
#define fast_inverse_sqrt_f32 native_rsqrt 
int halide_gpu_thread_barrier() {
  barrier(CLK_LOCAL_MEM_FENCE);
  return 0;
}
#define __address_space___shared __local

__kernel void _at_least_one_kernel(int x) { }
// Address spaces for kernel_blur_s0_y___block_id_y
#define __address_space__blur __global
__kernel void kernel_blur_s0_y___block_id_y(
 const int _blur_x_extent_realized_s_s,
 const int _blur_x_min_realized,
 const int _blur_y_min_realized,
 const int _output_extent_0,
 const int _output_extent_1,
 const int _output_min_0,
 const int _output_min_1,
 __address_space__blur float8 *_blur,
 __address_space___shared int16* __shared)
{
 int _blur_s0_y___block_id_y = get_group_id(1);
 int _0 = _blur_s0_y___block_id_y * 8;
 int _1 = _0 + _output_min_1;
 int _2 = _output_min_1 + _output_extent_1;
 int _3 = _2 + -8;
 int _4 = min(_1, _3);
 int _blur_s0_x_x___block_id_x = get_group_id(0);
 int ___thread_id_y = get_local_id(1);
 int ___thread_id_x = get_local_id(0);
 int _5 = _blur_s0_x_x___block_id_x * 128;
 int _6 = _5 + _output_min_0;
 int _7 = _output_min_0 + _output_extent_0;
 int _8 = _7 + -128;
 int _9 = min(_6, _8);
 float8 _10 = float_from_bits(0 /* 0 */);
 int _11 = ___thread_id_x * 8;
 int _12 = _9 + _11;
 int _13 = _12 - _blur_x_min_realized;
 int _14 = _4 + ___thread_id_y;
 int _15 = _14 - _blur_y_min_realized;
 int _16 = _blur_x_extent_realized_s_s - _blur_x_min_realized;
 int _17 = _16 + 1;
 int _18 = _15 * _17;
 int _19 = _13 + _18;
 vstore8(_10,0, (__address_space__blur float*)_blur + _19);
} // kernel kernel_blur_s0_y___block_id_y
#undef __address_space__blur
// Address spaces for kernel_output_s0_y___block_id_y
#define __address_space__blur __global
#define __address_space__output __global
__kernel void kernel_output_s0_y___block_id_y(
 const int _blur_x_extent_realized_s_s,
 const int _blur_x_min_realized,
 const int _blur_y_min_realized,
 const int _output_extent_0,
 const int _output_extent_1,
 const int _output_min_0,
 const int _output_min_1,
 const int _output_stride_1,
 __address_space__blur const float8 *_blur,
 __address_space__output ushort8 *_output,
 __address_space___shared int16* __shared)
{
 int _output_s0_y___block_id_y = get_group_id(1);
 int _20 = _output_s0_y___block_id_y * 16;
 int _21 = _20 + _output_min_1;
 int _22 = _output_min_1 + _output_extent_1;
 int _23 = _22 + -16;
 int _24 = min(_21, _23);
 int _output_s0_x_x___block_id_x = get_group_id(0);
 int ___thread_id_y = get_local_id(1);
 int ___thread_id_x = get_local_id(0);
 int _25 = _output_s0_x_x___block_id_x * 16;
 int _26 = _25 + _output_min_0;
 int _27 = _output_min_0 + _output_extent_0;
 int _28 = _27 + -16;
 int _29 = min(_26, _28);
 int _30 = ___thread_id_x * 8;
 int _31 = _29 + _30;
 int _32 = _31 - _blur_x_min_realized;
 int _33 = _24 + ___thread_id_y;
 int _34 = _33 - _blur_y_min_realized;
 int _35 = _blur_x_extent_realized_s_s - _blur_x_min_realized;
 int _36 = _35 + 1;
 int _37 = _34 * _36;
 int _38 = _32 + _37;
 float8 _39 = vload8(0, (__address_space__blur float*)_blur + _38);
 float8 _40 = float_from_bits(1065353216 /* 1 */);
 float8 _41 = min(_39, _40);
 float8 _42 = float_from_bits(0 /* 0 */);
 float8 _43 = max(_41, _42);
 float8 _44 = float_from_bits(1199570688 /* 65535 */);
 float8 _45 = _43 * _44;
 ushort8 _46 = convert_ushort8(_45);
 int _47 = _33 * _output_stride_1;
 int _48 = _31 + _47;
 int _49 = _output_min_1 * _output_stride_1;
 int _50 = _output_min_0 + _49;
 int _51 = _48 - _50;
 vstore8(_46,0, (__address_space__output ushort*)_output + _51);
} // kernel kernel_output_s0_y___block_id_y
#undef __address_space__blur
#undef __address_space__output

Codegen: handle64, "Failure inside halide_init_kernels"
Creating call to error handlers
Creating cleanup code
Optimizing module
; ModuleID = 'halide_module_gaussinBlur_gpu'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64--linux-gnu"

%struct.timespec = type { i64, i64 }
%"struct.Halide::Runtime::Internal::halide_work_queue_t" = type { %struct.pthread_mutex_t, %"struct.Halide::Runtime::Internal::work"*, %struct.pthread_cond_t, [64 x i64], i8 }
%struct.pthread_mutex_t = type { [64 x i8] }
%"struct.Halide::Runtime::Internal::work" = type { %"struct.Halide::Runtime::Internal::work"*, i32 (i8*, i32, i8*)*, i8*, i32, i32, i8*, i32, i32 }
%struct.pthread_cond_t = type { [48 x i8] }
%struct.halide_trace_event = type { i8*, i32, i32, i32, i32, i32, i32, i8*, i32, i32* }
%"struct.Halide::Runtime::Internal::CacheEntry" = type { i8*, %"struct.Halide::Runtime::Internal::CacheEntry"*, %"struct.Halide::Runtime::Internal::CacheEntry"*, %"struct.Halide::Runtime::Internal::CacheEntry"*, i64, i8*, i32, i32, %struct.buffer_t, [1 x %struct.buffer_t] }
%struct.buffer_t = type { i64, i8*, [4 x i32], [4 x i32], [4 x i32], i32, i8, i8 }
%struct._cl_context = type opaque
%struct._cl_command_queue = type opaque
%"struct.Halide::Runtime::Internal::module_state" = type { %struct._cl_program*, %"struct.Halide::Runtime::Internal::module_state"* }
%struct._cl_program = type opaque
%"struct.Halide::Runtime::Internal::dev_copy" = type { i64, i64, [4 x i64], [4 x i64], i64 }
%struct._cl_platform_id = type opaque
%"class.Halide::Runtime::Internal::Printer" = type { [1024 x i8], i8*, i8*, i8* }
%struct._cl_device_id = type opaque
%struct._cl_mem = type opaque
%"class.Halide::Runtime::Internal::ClContext" = type <{ i8*, %struct._cl_context*, %struct._cl_command_queue*, i32, [4 x i8] }>
%struct._cl_event = type opaque
%struct._cl_kernel = type opaque

@halide_reference_clock_inited = weak global i8 0, align 1
@halide_reference_clock = weak global %struct.timespec zeroinitializer, align 8
@_ZN6Halide7Runtime8Internal21halide_custom_do_taskE = weak global i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)* null, align 8
@_ZN6Halide7Runtime8Internal24halide_custom_do_par_forE = weak global i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)* null, align 8
@_ZN6Halide7Runtime8Internal18halide_num_threadsE = weak global i32 0, align 4
@_ZN6Halide7Runtime8Internal30halide_thread_pool_initializedE = weak global i8 0, align 1
@_ZN6Halide7Runtime8Internal17halide_work_queueE = weak global %"struct.Halide::Runtime::Internal::halide_work_queue_t" zeroinitializer, align 8
@_ZN6Halide7Runtime8Internal24halide_ocl_platform_nameE = weak global [256 x i8] zeroinitializer, align 16
@_ZN6Halide7Runtime8Internal29halide_ocl_platform_name_lockE = weak global i32 0, align 4
@_ZN6Halide7Runtime8Internal36halide_ocl_platform_name_initializedE = weak global i8 0, align 1
@_ZN6Halide7Runtime8Internal22halide_ocl_device_typeE = weak global [256 x i8] zeroinitializer, align 16
@_ZN6Halide7Runtime8Internal27halide_ocl_device_type_lockE = weak global i32 0, align 4
@_ZN6Halide7Runtime8Internal34halide_ocl_device_type_initializedE = weak global i8 0, align 1
@_ZN6Halide7Runtime8Internal17halide_gpu_deviceE = weak global i32 0, align 4
@_ZN6Halide7Runtime8Internal22halide_gpu_device_lockE = weak global i32 0, align 4
@_ZN6Halide7Runtime8Internal29halide_gpu_device_initializedE = weak global i8 0, align 1
@.str2 = private unnamed_addr constant [21 x i8] c"HL_OCL_PLATFORM_NAME\00", align 1
@.str13 = private unnamed_addr constant [19 x i8] c"HL_OCL_DEVICE_TYPE\00", align 1
@.str24 = private unnamed_addr constant [14 x i8] c"HL_GPU_DEVICE\00", align 1
@_ZN6Halide7Runtime8Internal19halide_custom_traceE = weak global i32 (i8*, %struct.halide_trace_event*)* null, align 8
@_ZN6Halide7Runtime8Internal17halide_trace_fileE = weak global i32 0, align 4
@_ZN6Halide7Runtime8Internal22halide_trace_file_lockE = weak global i32 0, align 4
@_ZN6Halide7Runtime8Internal29halide_trace_file_initializedE = weak global i8 0, align 1
@_ZN6Halide7Runtime8Internal35halide_trace_file_internally_openedE = weak global i8 0, align 1
@_ZN6Halide7Runtime8Internal30pixel_type_to_tiff_sample_typeE = weak global [10 x i16] [i16 3, i16 3, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2, i16 1, i16 2], align 16
@_ZN6Halide7Runtime8Internal20halide_custom_mallocE = weak global i8* (i8*, i64)* null, align 8
@_ZN6Halide7Runtime8Internal18halide_custom_freeE = weak global void (i8*, i8*)* null, align 8
@_ZN6Halide7Runtime8Internal20halide_error_handlerE = weak global void (i8*, i8*)* null, align 8
@.str33 = private unnamed_addr constant [8 x i8] c"Error: \00", align 1
@_ZN6Halide7Runtime8Internal19halide_custom_printE = weak global void (i8*, i8*)* null, align 8
@_ZN6Halide7Runtime8Internal16memoization_lockE = weak global %struct.pthread_mutex_t zeroinitializer, align 1
@_ZN6Halide7Runtime8Internal13cache_entriesE = weak global [256 x %"struct.Halide::Runtime::Internal::CacheEntry"*] zeroinitializer, align 16
@_ZN6Halide7Runtime8Internal18most_recently_usedE = weak global %"struct.Halide::Runtime::Internal::CacheEntry"* null, align 8
@_ZN6Halide7Runtime8Internal19least_recently_usedE = weak global %"struct.Halide::Runtime::Internal::CacheEntry"* null, align 8
@_ZN6Halide7Runtime8Internal14max_cache_sizeE = weak global i64 1048576, align 8
@_ZN6Halide7Runtime8Internal18current_cache_sizeE = weak global i64 0, align 8
@.str36 = private unnamed_addr constant [31 x i8] c"from.elem_size == to.elem_size\00", align 1
@.str137 = private unnamed_addr constant [31 x i8] c"from.extent[i] == to.extent[i]\00", align 1
@.str238 = private unnamed_addr constant [31 x i8] c"from.stride[i] == to.stride[i]\00", align 1
@.str339 = private unnamed_addr constant [14 x i8] c"entry != NULL\00", align 1
@.str440 = private unnamed_addr constant [27 x i8] c"entry->more_recent != NULL\00", align 1
@.str541 = private unnamed_addr constant [29 x i8] c"least_recently_used == entry\00", align 1
@.str1264 = private unnamed_addr constant [17 x i8] c"0123456789abcdef\00", align 1
@_ZN6Halide7Runtime8Internal11weak_cl_ctxE = weak global %struct._cl_context* null, align 8
@_ZN6Halide7Runtime8Internal9weak_cl_qE = weak global %struct._cl_command_queue* null, align 8
@_ZN6Halide7Runtime8Internal12weak_cl_lockE = weak global i32 0, align 4
@_ZN6Halide7Runtime8Internal10cl_ctx_ptrE = weak global %struct._cl_context** null, align 8
@_ZN6Halide7Runtime8Internal8cl_q_ptrE = weak global %struct._cl_command_queue** null, align 8
@_ZN6Halide7Runtime8Internal11cl_lock_ptrE = weak global i32* null, align 8
@_ZN6Halide7Runtime8Internal10state_listE = weak global %"struct.Halide::Runtime::Internal::module_state"* null, align 8
@.str67 = private unnamed_addr constant [5 x i8] c"size\00", align 1
@.str168 = private unnamed_addr constant [12 x i8] c"ctx != NULL\00", align 1
@.str269 = private unnamed_addr constant [10 x i8] c"q != NULL\00", align 1
@.str370 = private unnamed_addr constant [20 x i8] c"cl_lock_ptr != NULL\00", align 1
@.str471 = private unnamed_addr constant [19 x i8] c"cl_ctx_ptr != NULL\00", align 1
@.str572 = private unnamed_addr constant [17 x i8] c"cl_q_ptr != NULL\00", align 1
@.str1573 = private unnamed_addr constant [28 x i8] c"ctx != NULL && *ctx == NULL\00", align 1
@.str1674 = private unnamed_addr constant [24 x i8] c"q != NULL && *q == NULL\00", align 1
@.str1775 = private unnamed_addr constant [30 x i8] c"CL: clGetPlatformIDs failed: \00", align 1
@.str1876 = private unnamed_addr constant [29 x i8] c"CL: Failed to find platform\0A\00", align 1
@.str1977 = private unnamed_addr constant [4 x i8] c"cpu\00", align 1
@.str2078 = private unnamed_addr constant [4 x i8] c"gpu\00", align 1
@.str2179 = private unnamed_addr constant [4 x i8] c"acc\00", align 1
@.str2280 = private unnamed_addr constant [28 x i8] c"CL: clGetDeviceIDs failed: \00", align 1
@.str2381 = private unnamed_addr constant [27 x i8] c"CL: Failed to get device: \00", align 1
@.str2582 = private unnamed_addr constant [29 x i8] c"CL: clCreateContext failed: \00", align 1
@.str2783 = private unnamed_addr constant [34 x i8] c"CL: clCreateCommandQueue failed: \00", align 1
@.str684 = private unnamed_addr constant [24 x i8] c"CL: Bad device pointer \00", align 1
@.str785 = private unnamed_addr constant [31 x i8] c": clGetMemObjectInfo returned \00", align 1
@.str1286 = private unnamed_addr constant [65 x i8] c"real_size >= size && \22Validating pointer with insufficient size\22\00", align 1
@switch.table = private unnamed_addr constant [64 x i8*] [i8* getelementptr inbounds ([28 x i8]* @.str149, i64 0, i64 0), i8* getelementptr inbounds ([21 x i8]* @.str148, i64 0, i64 0), i8* getelementptr inbounds ([23 x i8]* @.str147, i64 0, i64 0), i8* getelementptr inbounds ([21 x i8]* @.str146, i64 0, i64 0), i8* getelementptr inbounds ([21 x i8]* @.str145, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8]* @.str144, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8]* @.str143, i64 0, i64 0), i8* getelementptr inbounds ([25 x i8]* @.str142, i64 0, i64 0), i8* getelementptr inbounds ([26 x i8]* @.str141, i64 0, i64 0), i8* getelementptr inbounds ([27 x i8]* @.str140, i64 0, i64 0), i8* getelementptr inbounds ([26 x i8]* @.str139, i64 0, i64 0), i8* getelementptr inbounds ([23 x i8]* @.str13888, i64 0, i64 0), i8* getelementptr inbounds ([20 x i8]* @.str13789, i64 0, i64 0), i8* getelementptr inbounds ([21 x i8]* @.str136, i64 0, i64 0), i8* getelementptr inbounds ([21 x i8]* @.str135, i64 0, i64 0), i8* getelementptr inbounds ([18 x i8]* @.str134, i64 0, i64 0), i8* getelementptr inbounds ([29 x i8]* @.str133, i64 0, i64 0), i8* getelementptr inbounds ([23 x i8]* @.str132, i64 0, i64 0), i8* getelementptr inbounds ([30 x i8]* @.str131, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str130, i64 0, i64 0), i8* getelementptr inbounds ([25 x i8]* @.str129, i64 0, i64 0), i8* getelementptr inbounds ([18 x i8]* @.str128, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str127, i64 0, i64 0), i8* getelementptr inbounds ([22 x i8]* @.str126, i64 0, i64 0), i8* getelementptr inbounds ([35 x i8]* @.str125, i64 0, i64 0), i8* getelementptr inbounds ([22 x i8]* @.str124, i64 0, i64 0), i8* getelementptr inbounds ([20 x i8]* @.str123, i64 0, i64 0), i8* getelementptr inbounds ([25 x i8]* @.str122, i64 0, i64 0), i8* getelementptr inbounds ([28 x i8]* @.str121, i64 0, i64 0), i8* getelementptr inbounds ([19 x i8]* @.str120, i64 0, i64 0), i8* getelementptr inbounds ([18 x i8]* @.str119, i64 0, i64 0), i8* getelementptr inbounds ([20 x i8]* @.str118, i64 0, i64 0), i8* getelementptr inbounds ([23 x i8]* @.str117, i64 0, i64 0), i8* getelementptr inbounds ([17 x i8]* @.str116, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0), i8* getelementptr inbounds ([15 x i8]* @.str115, i64 0, i64 0), i8* getelementptr inbounds ([25 x i8]* @.str114, i64 0, i64 0), i8* getelementptr inbounds ([30 x i8]* @.str113, i64 0, i64 0), i8* getelementptr inbounds ([25 x i8]* @.str112, i64 0, i64 0), i8* getelementptr inbounds ([20 x i8]* @.str111, i64 0, i64 0), i8* getelementptr inbounds ([32 x i8]* @.str110, i64 0, i64 0), i8* getelementptr inbounds ([22 x i8]* @.str109, i64 0, i64 0), i8* getelementptr inbounds ([20 x i8]* @.str108, i64 0, i64 0), i8* getelementptr inbounds ([33 x i8]* @.str107, i64 0, i64 0), i8* getelementptr inbounds ([26 x i8]* @.str106, i64 0, i64 0), i8* getelementptr inbounds ([24 x i8]* @.str105, i64 0, i64 0), i8* getelementptr inbounds ([20 x i8]* @.str104, i64 0, i64 0), i8* getelementptr inbounds ([11 x i8]* @.str103, i64 0, i64 0)]
@.str150 = private unnamed_addr constant [16 x i8] c"<Unknown error>\00", align 1
@.str151 = private unnamed_addr constant [37 x i8] c"context != NULL && cmd_queue != NULL\00", align 1
@.str30 = private unnamed_addr constant [40 x i8] c"validate_dev_pointer(user_context, buf)\00", align 1
@.str32 = private unnamed_addr constant [32 x i8] c"CL: clReleaseMemObject failed: \00", align 1
@.str37 = private unnamed_addr constant [50 x i8] c"CL: clGetContextInfo(CL_CONTEXT_DEVICES) failed: \00", align 1
@.str38 = private unnamed_addr constant [66 x i8] c"CL: clGetDeviceInfo (CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE) failed: \00", align 1
@.str39 = private unnamed_addr constant [59 x i8] c"CL: clGetDeviceInfo (CL_DEVICE_MAX_CONSTANT_ARGS) failed: \00", align 1
@.str40 = private unnamed_addr constant [29 x i8] c"-D MAX_CONSTANT_BUFFER_SIZE=\00", align 1
@.str41 = private unnamed_addr constant [23 x i8] c" -D MAX_CONSTANT_ARGS=\00", align 1
@.str43 = private unnamed_addr constant [39 x i8] c"CL: clCreateProgramWithSource failed: \00", align 1
@.str46 = private unnamed_addr constant [28 x i8] c"CL: clBuildProgram failed: \00", align 1
@.str47 = private unnamed_addr constant [14 x i8] c"\0ABuild Log:\0A \00", align 1
@.str48 = private unnamed_addr constant [29 x i8] c"clGetProgramBuildInfo failed\00", align 1
@.str50 = private unnamed_addr constant [24 x i8] c"ctx.error == CL_SUCCESS\00", align 1
@.str51 = private unnamed_addr constant [22 x i8] c"CL: clFinish failed: \00", align 1
@.str53 = private unnamed_addr constant [18 x i8] c"err == CL_SUCCESS\00", align 1
@.str58 = private unnamed_addr constant [46 x i8] c"validate_dev_pointer(user_context, buf, size)\00", align 1
@.str59 = private unnamed_addr constant [89 x i8] c"buf->stride[0] >= 0 && buf->stride[1] >= 0 && buf->stride[2] >= 0 && buf->stride[3] >= 0\00", align 1
@.str68 = private unnamed_addr constant [28 x i8] c"CL: clCreateBuffer failed: \00", align 1
@.str72 = private unnamed_addr constant [22 x i8] c"buf->host && buf->dev\00", align 1
@.str80 = private unnamed_addr constant [38 x i8] c"CL: clEnqueueWriteBufferRect failed: \00", align 1
@.str83 = private unnamed_addr constant [37 x i8] c"CL: clEnqueueReadBufferRect failed: \00", align 1
@.str89 = private unnamed_addr constant [10 x i8] c"state_ptr\00", align 1
@.str90 = private unnamed_addr constant [8 x i8] c"program\00", align 1
@.str92 = private unnamed_addr constant [20 x i8] c"CL: clCreateKernel \00", align 1
@.str93 = private unnamed_addr constant [10 x i8] c" failed: \00", align 1
@.str1187 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str97 = private unnamed_addr constant [28 x i8] c"CL: clSetKernelArg failed: \00", align 1
@.str99 = private unnamed_addr constant [27 x i8] c"CL: clSetKernelArg failed \00", align 1
@.str101 = private unnamed_addr constant [36 x i8] c"CL: clEnqueueNDRangeKernel failed: \00", align 1
@.str149 = private unnamed_addr constant [28 x i8] c"CL_INVALID_GLOBAL_WORK_SIZE\00", align 1
@.str148 = private unnamed_addr constant [21 x i8] c"CL_INVALID_MIP_LEVEL\00", align 1
@.str147 = private unnamed_addr constant [23 x i8] c"CL_INVALID_BUFFER_SIZE\00", align 1
@.str146 = private unnamed_addr constant [21 x i8] c"CL_INVALID_GL_OBJECT\00", align 1
@.str145 = private unnamed_addr constant [21 x i8] c"CL_INVALID_OPERATION\00", align 1
@.str144 = private unnamed_addr constant [17 x i8] c"CL_INVALID_EVENT\00", align 1
@.str143 = private unnamed_addr constant [27 x i8] c"CL_INVALID_EVENT_WAIT_LIST\00", align 1
@.str142 = private unnamed_addr constant [25 x i8] c"CL_INVALID_GLOBAL_OFFSET\00", align 1
@.str141 = private unnamed_addr constant [26 x i8] c"CL_INVALID_WORK_ITEM_SIZE\00", align 1
@.str140 = private unnamed_addr constant [27 x i8] c"CL_INVALID_WORK_GROUP_SIZE\00", align 1
@.str139 = private unnamed_addr constant [26 x i8] c"CL_INVALID_WORK_DIMENSION\00", align 1
@.str13888 = private unnamed_addr constant [23 x i8] c"CL_INVALID_KERNEL_ARGS\00", align 1
@.str13789 = private unnamed_addr constant [20 x i8] c"CL_INVALID_ARG_SIZE\00", align 1
@.str136 = private unnamed_addr constant [21 x i8] c"CL_INVALID_ARG_VALUE\00", align 1
@.str135 = private unnamed_addr constant [21 x i8] c"CL_INVALID_ARG_INDEX\00", align 1
@.str134 = private unnamed_addr constant [18 x i8] c"CL_INVALID_KERNEL\00", align 1
@.str133 = private unnamed_addr constant [29 x i8] c"CL_INVALID_KERNEL_DEFINITION\00", align 1
@.str132 = private unnamed_addr constant [23 x i8] c"CL_INVALID_KERNEL_NAME\00", align 1
@.str131 = private unnamed_addr constant [30 x i8] c"CL_INVALID_PROGRAM_EXECUTABLE\00", align 1
@.str130 = private unnamed_addr constant [19 x i8] c"CL_INVALID_PROGRAM\00", align 1
@.str129 = private unnamed_addr constant [25 x i8] c"CL_INVALID_BUILD_OPTIONS\00", align 1
@.str128 = private unnamed_addr constant [18 x i8] c"CL_INVALID_BINARY\00", align 1
@.str127 = private unnamed_addr constant [19 x i8] c"CL_INVALID_SAMPLER\00", align 1
@.str126 = private unnamed_addr constant [22 x i8] c"CL_INVALID_IMAGE_SIZE\00", align 1
@.str125 = private unnamed_addr constant [35 x i8] c"CL_INVALID_IMAGE_FORMAT_DESCRIPTOR\00", align 1
@.str124 = private unnamed_addr constant [22 x i8] c"CL_INVALID_MEM_OBJECT\00", align 1
@.str123 = private unnamed_addr constant [20 x i8] c"CL_INVALID_HOST_PTR\00", align 1
@.str122 = private unnamed_addr constant [25 x i8] c"CL_INVALID_COMMAND_QUEUE\00", align 1
@.str121 = private unnamed_addr constant [28 x i8] c"CL_INVALID_QUEUE_PROPERTIES\00", align 1
@.str120 = private unnamed_addr constant [19 x i8] c"CL_INVALID_CONTEXT\00", align 1
@.str119 = private unnamed_addr constant [18 x i8] c"CL_INVALID_DEVICE\00", align 1
@.str118 = private unnamed_addr constant [20 x i8] c"CL_INVALID_PLATFORM\00", align 1
@.str117 = private unnamed_addr constant [23 x i8] c"CL_INVALID_DEVICE_TYPE\00", align 1
@.str116 = private unnamed_addr constant [17 x i8] c"CL_INVALID_VALUE\00", align 1
@.str115 = private unnamed_addr constant [15 x i8] c"CL_MAP_FAILURE\00", align 1
@.str114 = private unnamed_addr constant [25 x i8] c"CL_BUILD_PROGRAM_FAILURE\00", align 1
@.str113 = private unnamed_addr constant [30 x i8] c"CL_IMAGE_FORMAT_NOT_SUPPORTED\00", align 1
@.str112 = private unnamed_addr constant [25 x i8] c"CL_IMAGE_FORMAT_MISMATCH\00", align 1
@.str111 = private unnamed_addr constant [20 x i8] c"CL_MEM_COPY_OVERLAP\00", align 1
@.str110 = private unnamed_addr constant [32 x i8] c"CL_PROFILING_INFO_NOT_AVAILABLE\00", align 1
@.str109 = private unnamed_addr constant [22 x i8] c"CL_OUT_OF_HOST_MEMORY\00", align 1
@.str108 = private unnamed_addr constant [20 x i8] c"CL_OUT_OF_RESOURCES\00", align 1
@.str107 = private unnamed_addr constant [33 x i8] c"CL_MEM_OBJECT_ALLOCATION_FAILURE\00", align 1
@.str106 = private unnamed_addr constant [26 x i8] c"CL_COMPILER_NOT_AVAILABLE\00", align 1
@.str105 = private unnamed_addr constant [24 x i8] c"CL_DEVICE_NOT_AVAILABLE\00", align 1
@.str104 = private unnamed_addr constant [20 x i8] c"CL_DEVICE_NOT_FOUND\00", align 1
@.str103 = private unnamed_addr constant [11 x i8] c"CL_SUCCESS\00", align 1
@str = private constant [30 x i8] c"buffer argument input is NULL\00", align 32
@str90 = private constant [31 x i8] c"buffer argument output is NULL\00", align 32
@i0.data = private constant [50 x i8] c"\01\00\04\00\07\00\04\00\01\00\04\00\10\00\1A\00\10\00\04\00\07\00\1A\00)\00\1A\00\07\00\04\00\10\00\1A\00\10\00\04\00\01\00\04\00\07\00\04\00\01\00", align 32
@i0.buffer = private global %struct.buffer_t { i64 0, i8* getelementptr inbounds ([50 x i8]* @i0.data, i32 0, i32 0), [4 x i32] [i32 5, i32 5, i32 0, i32 0], [4 x i32] [i32 1, i32 5, i32 25, i32 0], [4 x i32] zeroinitializer, i32 2, i8 1, i8 0 }
@str93 = private constant [77 x i8] c"Input buffer i0 has type uint16, but elem_size of the buffer_t passed in is \00", align 32
@str94 = private constant [14 x i8] c" instead of 2\00", align 32
@str95 = private constant [80 x i8] c"Input buffer input has type uint16, but elem_size of the buffer_t passed in is \00", align 32
@str96 = private constant [82 x i8] c"Output buffer output has type uint16, but elem_size of the buffer_t passed in is \00", align 32
@str97 = private constant [60 x i8] c"Input buffer i0 is accessed at 0, which is before the min (\00", align 32
@str98 = private constant [17 x i8] c") in dimension 0\00", align 32
@str99 = private constant [60 x i8] c"Input buffer i0 is accessed at 4, which is beyond the max (\00", align 32
@str100 = private constant [17 x i8] c") in dimension 1\00", align 32
@str101 = private constant [35 x i8] c"Input buffer input is accessed at \00", align 32
@str102 = private constant [28 x i8] c", which is before the min (\00", align 32
@str103 = private constant [28 x i8] c", which is beyond the max (\00", align 32
@str104 = private constant [37 x i8] c"Output buffer output is accessed at \00", align 32
@str105 = private constant [45 x i8] c"Static constraint violated: i0.stride.0 == 1\00", align 32
@str106 = private constant [42 x i8] c"Static constraint violated: i0.min.0 == 0\00", align 32
@str107 = private constant [45 x i8] c"Static constraint violated: i0.extent.0 == 5\00", align 32
@str108 = private constant [45 x i8] c"Static constraint violated: i0.stride.1 == 5\00", align 32
@str109 = private constant [42 x i8] c"Static constraint violated: i0.min.1 == 0\00", align 32
@str110 = private constant [45 x i8] c"Static constraint violated: i0.extent.1 == 5\00", align 32
@str111 = private constant [48 x i8] c"Static constraint violated: input.stride.0 == 1\00", align 32
@str112 = private constant [49 x i8] c"Static constraint violated: output.stride.0 == 1\00", align 32
@str115 = private constant [51 x i8] c"Total allocation for buffer input exceeds 2^31 - 1\00", align 32
@str116 = private constant [53 x i8] c"Product of extents for buffer input exceeds 2^31 - 1\00", align 32
@str117 = private constant [52 x i8] c"Total allocation for buffer output exceeds 2^31 - 1\00", align 32
@str118 = private constant [54 x i8] c"Product of extents for buffer output exceeds 2^31 - 1\00", align 32
@str119 = private constant [57 x i8] c"32-bit signed overflow computing size of allocation blur\00", align 32
@str120 = private constant [37 x i8] c"Out of memory (malloc returned NULL)\00", align 32
@str121 = private constant [42 x i8] c"Failed to allocate device buffer for blur\00", align 32
@entry_name = private unnamed_addr constant [30 x i8] c"kernel_blur_s0_y___block_id_y\00"
@module_state = private global i8* null
@str122 = private constant [30 x i8] c"Failure inside halide_dev_run\00", align 32
@str123 = private constant [37 x i8] c"Failed to copy buffer input to host.\00", align 32
@str124 = private constant [34 x i8] c"Failed to copy buffer i0 to host.\00", align 32
@str125 = private constant [36 x i8] c"Failed to copy buffer blur to host.\00", align 32
@str126 = private constant [44 x i8] c"Failed to allocate device buffer for output\00", align 32
@str127 = private constant [37 x i8] c"Failed to copy buffer output to dev.\00", align 32
@str128 = private constant [35 x i8] c"Failed to copy buffer blur to dev.\00", align 32
@entry_name129 = private unnamed_addr constant [32 x i8] c"kernel_output_s0_y___block_id_y\00"
@str130 = private constant [38 x i8] c"Failed to free device buffer for blur\00", align 32
@halide_kernel_src = private constant [5325 x i8] c"/*OpenCL C*/\0A#pragma OPENCL FP_CONTRACT ON\0Afloat maxval_f32() {return FLT_MAX;}\0Afloat minval_f32() {return -FLT_MAX;}\0Afloat nan_f32() { return NAN; }\0Afloat neg_inf_f32() { return -INFINITY; }\0Abool is_nan_f32(float x) {return x != x; }\0Afloat inf_f32() { return INFINITY; }\0Afloat float_from_bits(unsigned int x) {return as_float(x);}\0Achar smod_char(char a, char b) {\0Achar r = a % b;\0Aif (r < 0) { r += b < 0 ? -b : b; }\0Areturn r;\0A}\0A\0Ashort smod_short(short a, short b) {\0Ashort r = a % b;\0Aif (r < 0) { r += b < 0 ? -b : b; }\0Areturn r;\0A}\0A\0Aint smod_int(int a, int b) {\0Aint r = a % b;\0Aif (r < 0) { r += b < 0 ? -b : b; }\0Areturn r;\0A}\0A\0Achar sdiv_char(char a, char b) {\0Achar q = a / b;\0Achar r = a - q*b;\0Achar bs = b >> (8*sizeof(char) - 1);\0Achar rs = r >> (8*sizeof(char) - 1);\0Areturn q - (rs&bs) + (rs&~bs);\0A}\0A\0Ashort sdiv_short(short a, short b) {\0Ashort q = a / b;\0Ashort r = a - q*b;\0Ashort bs = b >> (8*sizeof(short) - 1);\0Ashort rs = r >> (8*sizeof(short) - 1);\0Areturn q - (rs&bs) + (rs&~bs);\0A}\0A\0Aint sdiv_int(int a, int b) {\0Aint q = a / b;\0Aint r = a - q*b;\0Aint bs = b >> (8*sizeof(int) - 1);\0Aint rs = r >> (8*sizeof(int) - 1);\0Areturn q - (rs&bs) + (rs&~bs);\0A}\0A\0A#define sqrt_f32 sqrt \0A#define sin_f32 sin \0A#define cos_f32 cos \0A#define exp_f32 exp \0A#define log_f32 log \0A#define abs_f32 fabs \0A#define floor_f32 floor \0A#define ceil_f32 ceil \0A#define round_f32 round \0A#define trunc_f32 trunc \0A#define pow_f32 pow\0A#define asin_f32 asin \0A#define acos_f32 acos \0A#define tan_f32 tan \0A#define atan_f32 atan \0A#define atan2_f32 atan2\0A#define sinh_f32 sinh \0A#define asinh_f32 asinh \0A#define cosh_f32 cosh \0A#define acosh_f32 acosh \0A#define tanh_f32 tanh \0A#define atanh_f32 atanh \0A#define fast_inverse_f32 native_recip \0A#define fast_inverse_sqrt_f32 native_rsqrt \0Aint halide_gpu_thread_barrier() {\0A  barrier(CLK_LOCAL_MEM_FENCE);\0A  return 0;\0A}\0A#define __address_space___shared __local\0A\0A__kernel void _at_least_one_kernel(int x) { }\0A// Address spaces for kernel_blur_s0_y___block_id_y\0A#define __address_space__blur __global\0A__kernel void kernel_blur_s0_y___block_id_y(\0A const int _blur_x_extent_realized_s_s,\0A const int _blur_x_min_realized,\0A const int _blur_y_min_realized,\0A const int _output_extent_0,\0A const int _output_extent_1,\0A const int _output_min_0,\0A const int _output_min_1,\0A __address_space__blur float8 *_blur,\0A __address_space___shared int16* __shared)\0A{\0A int _blur_s0_y___block_id_y = get_group_id(1);\0A int _0 = _blur_s0_y___block_id_y * 8;\0A int _1 = _0 + _output_min_1;\0A int _2 = _output_min_1 + _output_extent_1;\0A int _3 = _2 + -8;\0A int _4 = min(_1, _3);\0A int _blur_s0_x_x___block_id_x = get_group_id(0);\0A int ___thread_id_y = get_local_id(1);\0A int ___thread_id_x = get_local_id(0);\0A int _5 = _blur_s0_x_x___block_id_x * 128;\0A int _6 = _5 + _output_min_0;\0A int _7 = _output_min_0 + _output_extent_0;\0A int _8 = _7 + -128;\0A int _9 = min(_6, _8);\0A float8 _10 = float_from_bits(0 /* 0 */);\0A int _11 = ___thread_id_x * 8;\0A int _12 = _9 + _11;\0A int _13 = _12 - _blur_x_min_realized;\0A int _14 = _4 + ___thread_id_y;\0A int _15 = _14 - _blur_y_min_realized;\0A int _16 = _blur_x_extent_realized_s_s - _blur_x_min_realized;\0A int _17 = _16 + 1;\0A int _18 = _15 * _17;\0A int _19 = _13 + _18;\0A vstore8(_10,0, (__address_space__blur float*)_blur + _19);\0A} // kernel kernel_blur_s0_y___block_id_y\0A#undef __address_space__blur\0A// Address spaces for kernel_output_s0_y___block_id_y\0A#define __address_space__blur __global\0A#define __address_space__output __global\0A__kernel void kernel_output_s0_y___block_id_y(\0A const int _blur_x_extent_realized_s_s,\0A const int _blur_x_min_realized,\0A const int _blur_y_min_realized,\0A const int _output_extent_0,\0A const int _output_extent_1,\0A const int _output_min_0,\0A const int _output_min_1,\0A const int _output_stride_1,\0A __address_space__blur const float8 *_blur,\0A __address_space__output ushort8 *_output,\0A __address_space___shared int16* __shared)\0A{\0A int _output_s0_y___block_id_y = get_group_id(1);\0A int _20 = _output_s0_y___block_id_y * 16;\0A int _21 = _20 + _output_min_1;\0A int _22 = _output_min_1 + _output_extent_1;\0A int _23 = _22 + -16;\0A int _24 = min(_21, _23);\0A int _output_s0_x_x___block_id_x = get_group_id(0);\0A int ___thread_id_y = get_local_id(1);\0A int ___thread_id_x = get_local_id(0);\0A int _25 = _output_s0_x_x___block_id_x * 16;\0A int _26 = _25 + _output_min_0;\0A int _27 = _output_min_0 + _output_extent_0;\0A int _28 = _27 + -16;\0A int _29 = min(_26, _28);\0A int _30 = ___thread_id_x * 8;\0A int _31 = _29 + _30;\0A int _32 = _31 - _blur_x_min_realized;\0A int _33 = _24 + ___thread_id_y;\0A int _34 = _33 - _blur_y_min_realized;\0A int _35 = _blur_x_extent_realized_s_s - _blur_x_min_realized;\0A int _36 = _35 + 1;\0A int _37 = _34 * _36;\0A int _38 = _32 + _37;\0A float8 _39 = vload8(0, (__address_space__blur float*)_blur + _38);\0A float8 _40 = float_from_bits(1065353216 /* 1 */);\0A float8 _41 = min(_39, _40);\0A float8 _42 = float_from_bits(0 /* 0 */);\0A float8 _43 = max(_41, _42);\0A float8 _44 = float_from_bits(1199570688 /* 65535 */);\0A float8 _45 = _43 * _44;\0A ushort8 _46 = convert_ushort8(_45);\0A int _47 = _33 * _output_stride_1;\0A int _48 = _31 + _47;\0A int _49 = _output_min_1 * _output_stride_1;\0A int _50 = _output_min_0 + _49;\0A int _51 = _48 - _50;\0A vstore8(_46,0, (__address_space__output ushort*)_output + _51);\0A} // kernel kernel_output_s0_y___block_id_y\0A#undef __address_space__blur\0A#undef __address_space__output\0A\00", align 32
@str131 = private constant [35 x i8] c"Failure inside halide_init_kernels\00", align 32

declare i32 @syscall(i32, ...) #0

; Function Attrs: nounwind uwtable
define weak i64 @halide_current_time_ns(i8* %user_context) #1 {
entry:
  %now = alloca %struct.timespec, align 8
  %call = call i32 (i32, ...)* @syscall(i32 228, i32 0, %struct.timespec* %now) #5
  %tv_sec = getelementptr inbounds %struct.timespec* %now, i64 0, i32 0
  %0 = load i64* %tv_sec, align 8, !tbaa !1
  %1 = load i64* getelementptr inbounds (%struct.timespec* @halide_reference_clock, i64 0, i32 0), align 8, !tbaa !1
  %sub = sub nsw i64 %0, %1
  %mul = mul nsw i64 %sub, 1000000000
  %tv_nsec = getelementptr inbounds %struct.timespec* %now, i64 0, i32 1
  %2 = load i64* %tv_nsec, align 8, !tbaa !6
  %3 = load i64* getelementptr inbounds (%struct.timespec* @halide_reference_clock, i64 0, i32 1), align 8, !tbaa !6
  %sub1 = sub i64 %2, %3
  %add = add nsw i64 %sub1, %mul
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define linkonce void @_ZN6Halide7Runtime8Internal17halide_print_implEPvPKc(i8* %user_context, i8* %str) #1 {
entry:
  %call = tail call i64 @strlen(i8* %str) #5
  %call1 = tail call i64 @write(i32 2, i8* %str, i64 %call) #5
  ret void
}

declare i64 @write(i32, i8* nocapture readonly, i64) #0

; Function Attrs: nounwind readonly
declare i64 @strlen(i8* nocapture) #2

; Function Attrs: nounwind uwtable
define weak i32 @halide_host_cpu_count() #1 {
entry:
  %call = tail call i64 @sysconf(i32 84) #5
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

declare i64 @sysconf(i32) #0

; Function Attrs: nounwind uwtable
define linkonce void @halide_mutex_cleanup(%struct.pthread_mutex_t* %mutex_arg) #1 {
entry:
  %call = tail call i32 @pthread_mutex_destroy(%struct.pthread_mutex_t* %mutex_arg) #5
  %0 = getelementptr inbounds %struct.pthread_mutex_t* %mutex_arg, i64 0, i32 0, i64 0
  %call1 = tail call i8* @memset(i8* %0, i32 0, i64 64) #5
  ret void
}

declare i32 @pthread_mutex_destroy(%struct.pthread_mutex_t*) #0

declare i8* @memset(i8*, i32, i64) #0

; Function Attrs: nounwind uwtable
define linkonce void @halide_mutex_lock(%struct.pthread_mutex_t* %mutex_arg) #1 {
entry:
  %call = tail call i32 @pthread_mutex_lock(%struct.pthread_mutex_t* %mutex_arg) #5
  ret void
}

declare i32 @pthread_mutex_lock(%struct.pthread_mutex_t*) #0

; Function Attrs: nounwind uwtable
define linkonce void @halide_mutex_unlock(%struct.pthread_mutex_t* %mutex_arg) #1 {
entry:
  %call = tail call i32 @pthread_mutex_unlock(%struct.pthread_mutex_t* %mutex_arg) #5
  ret void
}

declare i32 @pthread_mutex_unlock(%struct.pthread_mutex_t*) #0

; Function Attrs: nounwind uwtable
define weak void @halide_shutdown_thread_pool() #1 {
entry:
  %retval = alloca i8*, align 8
  %0 = load i8* @_ZN6Halide7Runtime8Internal30halide_thread_pool_initializedE, align 1, !tbaa !7, !range !9
  %tobool = icmp eq i8 %0, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %call = tail call i32 @pthread_mutex_lock(%struct.pthread_mutex_t* getelementptr inbounds (%"struct.Halide::Runtime::Internal::halide_work_queue_t"* @_ZN6Halide7Runtime8Internal17halide_work_queueE, i64 0, i32 0)) #5
  store i8 1, i8* getelementptr inbounds (%"struct.Halide::Runtime::Internal::halide_work_queue_t"* @_ZN6Halide7Runtime8Internal17halide_work_queueE, i64 0, i32 4), align 8, !tbaa !10
  %call1 = tail call i32 @pthread_cond_broadcast(%struct.pthread_cond_t* getelementptr inbounds (%"struct.Halide::Runtime::Internal::halide_work_queue_t"* @_ZN6Halide7Runtime8Internal17halide_work_queueE, i64 0, i32 2)) #5
  %call2 = tail call i32 @pthread_mutex_unlock(%struct.pthread_mutex_t* getelementptr inbounds (%"struct.Halide::Runtime::Internal::halide_work_queue_t"* @_ZN6Halide7Runtime8Internal17halide_work_queueE, i64 0, i32 0)) #5
  %1 = load i32* @_ZN6Halide7Runtime8Internal18halide_num_threadsE, align 4, !tbaa !15
  %cmp10 = icmp sgt i32 %1, 1
  br i1 %cmp10, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %if.end
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body ], [ 0, %for.body.preheader ]
  %arrayidx = getelementptr inbounds %"struct.Halide::Runtime::Internal::halide_work_queue_t"* @_ZN6Halide7Runtime8Internal17halide_work_queueE, i64 0, i32 3, i64 %indvars.iv
  %2 = load i64* %arrayidx, align 8, !tbaa !17
  %call3 = call i32 @pthread_join(i64 %2, i8** %retval) #5
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %3 = load i32* @_ZN6Halide7Runtime8Internal18halide_num_threadsE, align 4, !tbaa !15
  %sub = add nsw i32 %3, -1
  %4 = sext i32 %sub to i64
  %cmp = icmp slt i64 %indvars.iv.next, %4
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %if.end
  %call4 = call i32 @pthread_mutex_destroy(%struct.pthread_mutex_t* getelementptr inbounds (%"struct.Halide::Runtime::Internal::halide_work_queue_t"* @_ZN6Halide7Runtime8Internal17halide_work_queueE, i64 0, i32 0)) #5
  %call5 = call i32 @pthread_mutex_init(%struct.pthread_mutex_t* getelementptr inbounds (%"struct.Halide::Runtime::Internal::halide_work_queue_t"* @_ZN6Halide7Runtime8Internal17halide_work_queueE, i64 0, i32 0), i64* null) #5
  %call6 = call i32 @pthread_cond_destroy(%struct.pthread_cond_t* getelementptr inbounds (%"struct.Halide::Runtime::Internal::halide_work_queue_t"* @_ZN6Halide7Runtime8Internal17halide_work_queueE, i64 0, i32 2)) #5
  store i8 0, i8* @_ZN6Halide7Runtime8Internal30halide_thread_pool_initializedE, align 1, !tbaa !7
  br label %return

return:                                           ; preds = %for.end, %entry
  ret void
}

declare i32 @pthread_cond_broadcast(%struct.pthread_cond_t*) #0

declare i32 @pthread_join(i64, i8**) #0

declare i32 @pthread_mutex_init(%struct.pthread_mutex_t*, i64*) #0

declare i32 @pthread_cond_destroy(%struct.pthread_cond_t*) #0

; Function Attrs: nounwind uwtable
define weak void @halide_set_num_threads(i32 %n) #1 {
entry:
  %0 = load i32* @_ZN6Halide7Runtime8Internal18halide_num_threadsE, align 4, !tbaa !15
  %cmp = icmp eq i32 %0, %n
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = load i8* @_ZN6Halide7Runtime8Internal30halide_thread_pool_initializedE, align 1, !tbaa !7, !range !9
  %tobool = icmp eq i8 %1, 0
  br i1 %tobool, label %if.end2, label %if.then1

if.then1:                                         ; preds = %if.end
  tail call void @halide_shutdown_thread_pool() #6
  br label %if.end2

if.end2:                                          ; preds = %if.then1, %if.end
  store i32 %n, i32* @_ZN6Halide7Runtime8Internal18halide_num_threadsE, align 4, !tbaa !15
  br label %return

return:                                           ; preds = %if.end2, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define weak void @halide_set_custom_do_task(i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)* %f) #1 {
entry:
  store i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)* %f, i32 (i8*, i32 (i8*, i32, i8*)*, i32, i8*)** @_ZN6Halide7Runtime8Internal21halide_custom_do_taskE, align 8, !tbaa !18
  ret void
}

; Function Attrs: nounwind uwtable
define weak void @halide_set_custom_do_par_for(i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)* %f) #1 {
entry:
  store i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)* %f, i32 (i8*, i32 (i8*, i32, i8*)*, i32, i32, i8*)** @_ZN6Halide7Runtime8Internal24halide_custom_do_par_forE, align 8, !tbaa !18
  ret void
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #3

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #3

; Function Attrs: nounwind readonly
declare i8* @getenv(i8* nocapture) #2

; Function Attrs: nounwind readonly
declare i32 @atoi(i8* nocapture) #2

; Function Attrs: nounwind uwtable
define weak void @halide_set_ocl_platform_name(i8* %n) #1 {
entry:
  %tobool = icmp eq i8* %n, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i8* @strncpy(i8* getelementptr inbounds ([256 x i8]* @_ZN6Halide7Runtime8Internal24halide_ocl_platform_nameE, i64 0, i64 0), i8* %n, i64 255) #5
  br label %if.end

if.else:                                          ; preds = %entry
  store i8 0, i8* getelementptr inbounds ([256 x i8]* @_ZN6Halide7Runtime8Internal24halide_ocl_platform_nameE, i64 0, i64 0), align 16, !tbaa !19
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i8 1, i8* @_ZN6Halide7Runtime8Internal36halide_ocl_platform_name_initializedE, align 1, !tbaa !7
  ret void
}

; Function Attrs: nounwind
declare i8* @strncpy(i8*, i8* nocapture readonly, i64) #4

; Function Attrs: nounwind uwtable
define linkonce i8* @halide_get_ocl_platform_name(i8* %user_context) #1 {
entry:
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.cond.i, %entry
  %0 = atomicrmw xchg i32* @_ZN6Halide7Runtime8Internal29halide_ocl_platform_name_lockE, i32 1 seq_cst
  %tobool.i = icmp eq i32 %0, 0
  br i1 %tobool.i, label %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit, label %while.cond.i

_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit: ; preds = %while.cond.i
  %1 = load i8* @_ZN6Halide7Runtime8Internal36halide_ocl_platform_name_initializedE, align 1, !tbaa !7, !range !9
  %tobool = icmp eq i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit
  %call = tail call i8* @getenv(i8* getelementptr inbounds ([21 x i8]* @.str2, i64 0, i64 0)) #5
  tail call void @halide_set_ocl_platform_name(i8* %call) #6
  br label %if.end

if.end:                                           ; preds = %if.then, %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit
  store atomic i32 0, i32* @_ZN6Halide7Runtime8Internal29halide_ocl_platform_name_lockE release, align 4
  ret i8* getelementptr inbounds ([256 x i8]* @_ZN6Halide7Runtime8Internal24halide_ocl_platform_nameE, i64 0, i64 0)
}

; Function Attrs: nounwind uwtable
define weak void @halide_set_ocl_device_type(i8* %n) #1 {
entry:
  %tobool = icmp eq i8* %n, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i8* @strncpy(i8* getelementptr inbounds ([256 x i8]* @_ZN6Halide7Runtime8Internal22halide_ocl_device_typeE, i64 0, i64 0), i8* %n, i64 255) #5
  br label %if.end

if.else:                                          ; preds = %entry
  store i8 0, i8* getelementptr inbounds ([256 x i8]* @_ZN6Halide7Runtime8Internal22halide_ocl_device_typeE, i64 0, i64 0), align 16, !tbaa !19
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i8 1, i8* @_ZN6Halide7Runtime8Internal34halide_ocl_device_type_initializedE, align 1, !tbaa !7
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce i8* @halide_get_ocl_device_type(i8* %user_context) #1 {
entry:
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.cond.i, %entry
  %0 = atomicrmw xchg i32* @_ZN6Halide7Runtime8Internal27halide_ocl_device_type_lockE, i32 1 seq_cst
  %tobool.i = icmp eq i32 %0, 0
  br i1 %tobool.i, label %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit, label %while.cond.i

_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit: ; preds = %while.cond.i
  %1 = load i8* @_ZN6Halide7Runtime8Internal34halide_ocl_device_type_initializedE, align 1, !tbaa !7, !range !9
  %tobool = icmp eq i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit
  %call = tail call i8* @getenv(i8* getelementptr inbounds ([19 x i8]* @.str13, i64 0, i64 0)) #5
  tail call void @halide_set_ocl_device_type(i8* %call) #6
  br label %if.end

if.end:                                           ; preds = %if.then, %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit
  store atomic i32 0, i32* @_ZN6Halide7Runtime8Internal27halide_ocl_device_type_lockE release, align 4
  ret i8* getelementptr inbounds ([256 x i8]* @_ZN6Halide7Runtime8Internal22halide_ocl_device_typeE, i64 0, i64 0)
}

; Function Attrs: nounwind uwtable
define weak void @halide_set_gpu_device(i32 %d) #1 {
entry:
  store i32 %d, i32* @_ZN6Halide7Runtime8Internal17halide_gpu_deviceE, align 4, !tbaa !15
  store i8 1, i8* @_ZN6Halide7Runtime8Internal29halide_gpu_device_initializedE, align 1, !tbaa !7
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce i32 @halide_get_gpu_device(i8* %user_context) #1 {
entry:
  br label %while.cond.i

while.cond.i:                                     ; preds = %while.cond.i, %entry
  %0 = atomicrmw xchg i32* @_ZN6Halide7Runtime8Internal22halide_gpu_device_lockE, i32 1 seq_cst
  %tobool.i = icmp eq i32 %0, 0
  br i1 %tobool.i, label %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit, label %while.cond.i

_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit: ; preds = %while.cond.i
  %1 = load i8* @_ZN6Halide7Runtime8Internal29halide_gpu_device_initializedE, align 1, !tbaa !7, !range !9
  %tobool = icmp eq i8 %1, 0
  br i1 %tobool, label %if.then, label %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit.if.end4_crit_edge

_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit.if.end4_crit_edge: ; preds = %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit
  %.pre = load i32* @_ZN6Halide7Runtime8Internal17halide_gpu_deviceE, align 4, !tbaa !15
  br label %if.end4

if.then:                                          ; preds = %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit
  %call = tail call i8* @getenv(i8* getelementptr inbounds ([14 x i8]* @.str24, i64 0, i64 0)) #5
  %tobool1 = icmp eq i8* %call, null
  br i1 %tobool1, label %if.end, label %if.then2

if.then2:                                         ; preds = %if.then
  %call3 = tail call i32 @atoi(i8* %call) #5
  br label %if.end

if.end:                                           ; preds = %if.then2, %if.then
  %storemerge = phi i32 [ %call3, %if.then2 ], [ -1, %if.then ]
  store i32 %storemerge, i32* @_ZN6Halide7Runtime8Internal17halide_gpu_deviceE, align 4, !tbaa !15
  store i8 1, i8* @_ZN6Halide7Runtime8Internal29halide_gpu_device_initializedE, align 1, !tbaa !7
  br label %if.end4

if.end4:                                          ; preds = %if.end, %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit.if.end4_crit_edge
  %2 = phi i32 [ %.pre, %_ZN6Halide7Runtime8Internal14ScopedSpinLockC2EPVi.exit.if.end4_crit_edge ], [ %storemerge, %if.end ]
  store atomic i32 0, i32* @_ZN6Halide7Runtime8Internal22halide_gpu_device_lockE release, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define weak void @halide_set_custom_trace(i32 (i8*, %struct.halide_trace_event*)* %t) #1 {
entry:
  store i32 (i8*, %struct.halide_trace_event*)* %t, i32 (i8*, %struct.halide_trace_event*)** @_ZN6Halide7Runtime8Internal19halide_custom_traceE, align 8, !tbaa !18
  ret void
}

; Function Attrs: nounwind uwtable
define weak void @halide_set_trace_file(i32 %fd) #1 {
entry:
  store i32 %fd, i32* @_ZN6Halide7Runtime8Internal17halide_trace_fileE, align 4, !tbaa !15
  store i8 1, i8* @_ZN6Halide7Runtime8Internal29halide_trace_file_initializedE, align 1, !tbaa !7
  ret void
}

; Function Attrs: nounwind uwtable
define weak i32 @halide_shutdown_trace() #1 {
entry:
  %0 = load i8* @_ZN6Halide7Runtime8Internal35halide_trace_file_internally_openedE, align 1, !tbaa !7, !range !9
  %tobool = icmp eq i8 %0, 0
  br i1 %tobool, label %return, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i32* @_ZN6Halide7Runtime8Internal17halide_trace_fileE, align 4, !tbaa !15
  %call = tail call i32 @close(i32 %1) #5
  store i32 0, i32* @_ZN6Halide7Runtime8Internal17halide_trace_fileE, align 4, !tbaa !15
  store i8 0, i8* @_ZN6Halide7Runtime8Internal29halide_trace_file_initializedE, align 1, !tbaa !7
  store i8 0, i8* @_ZN6Halide7Runtime8Internal35halide_trace_file_internally_openedE, align 1, !tbaa !7
  br label %return

return:                                           ; preds = %if.then, %entry
  %retval.0 = phi i32 [ %call, %if.then ], [ 0, %entry ]
  ret i32 %retval.0
}

declare i32 @close(i32) #0

; Function Attrs: nounwind uwtable
define weak void @halide_set_custom_allocator(i8* (i8*, i64)* %cust_malloc, void (i8*, i8*)* %cust_free) #1 {
entry:
  store i8* (i8*, i64)* %cust_malloc, i8* (i8*, i64)** @_ZN6Halide7Runtime8Internal20halide_custom_mallocE, align 8, !tbaa !18
  store void (i8*, i8*)* %cust_free, void (i8*, i8*)** @_ZN6Halide7Runtime8Internal18halide_custom_freeE, align 8, !tbaa !18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce noalias i8* @halide_malloc(i8* %user_context, i64 %x) #1 {
entry:
  %0 = load i8* (i8*, i64)** @_ZN6Halide7Runtime8Internal20halide_custom_mallocE, align 8, !tbaa !18
  %tobool = icmp eq i8* (i8*, i64)* %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call = tail call i8* %0(i8* %user_context, i64 %x) #5
  br label %return

if.else:                                          ; preds = %entry
  %add = add i64 %x, 40
  %call1 = tail call i8* @malloc(i64 %add) #5
  %cmp = icmp eq i8* %call1, null
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %if.else
  %1 = ptrtoint i8* %call1 to i64
  %add3 = add i64 %1, 32
  %shr = and i64 %add3, -32
  %2 = inttoptr i64 %shr to i8*
  %3 = inttoptr i64 %shr to i8**
  %arrayidx = getelementptr inbounds i8** %3, i64 -1
  store i8* %call1, i8** %arrayidx, align 8, !tbaa !18
  br label %return

return:                                           ; preds = %if.end, %if.else, %if.then
  %retval.0 = phi i8* [ %call, %if.then ], [ %2, %if.end ], [ null, %if.else ]
  ret i8* %retval.0
}

; Function Attrs: nounwind
declare noalias i8* @malloc(i64) #4

; Function Attrs: nounwind uwtable
define linkonce void @halide_free(i8* %user_context, i8* %ptr) #1 {
entry:
  %0 = load void (i8*, i8*)** @_ZN6Halide7Runtime8Internal18halide_custom_freeE, align 8, !tbaa !18
  %tobool = icmp eq void (i8*, i8*)* %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  tail call void %0(i8* %user_context, i8* %ptr) #5
  br label %if.end

if.else:                                          ; preds = %entry
  %arrayidx = getelementptr inbounds i8* %ptr, i64 -8
  %1 = bitcast i8* %arrayidx to i8**
  %2 = load i8** %1, align 8, !tbaa !18
  tail call void @free(i8* %2) #5
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind
declare void @free(i8* nocapture) #4

; Function Attrs: nounwind uwtable
define linkonce void @halide_error(i8* %user_context, i8* %msg) #1 {
entry:
  %buf = alloca [4096 x i8], align 16
  %0 = load void (i8*, i8*)** @_ZN6Halide7Runtime8Internal20halide_error_handlerE, align 8, !tbaa !18
  %tobool = icmp eq void (i8*, i8*)* %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  tail call void %0(i8* %user_context, i8* %msg) #5
  br label %if.end9

if.else:                                          ; preds = %entry
  %1 = getelementptr inbounds [4096 x i8]* %buf, i64 0, i64 0
  call void @llvm.lifetime.start(i64 4096, i8* %1) #3
  %add.ptr = getelementptr inbounds [4096 x i8]* %buf, i64 0, i64 4095
  %call = call i8* @halide_string_to_string(i8* %1, i8* %add.ptr, i8* getelementptr inbounds ([8 x i8]* @.str33, i64 0, i64 0)) #5
  %call4 = call i8* @halide_string_to_string(i8* %call, i8* %add.ptr, i8* %msg) #5
  %arrayidx = getelementptr inbounds i8* %call4, i64 -1
  %2 = load i8* %arrayidx, align 1, !tbaa !19
  %cmp = icmp eq i8 %2, 10
  br i1 %cmp, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.else
  store i8 10, i8* %call4, align 1, !tbaa !19
  %arrayidx7 = getelementptr inbounds i8* %call4, i64 1
  store i8 0, i8* %arrayidx7, align 1, !tbaa !19
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.else
  call void @halide_print(i8* %user_context, i8* %1) #5
  call void @exit(i32 1) #5
  call void @llvm.lifetime.end(i64 4096, i8* %1) #3
  br label %if.end9

if.end9:                                          ; preds = %if.end, %if.then
  ret void
}

declare void @exit(i32) #0

; Function Attrs: nounwind uwtable
define weak void @halide_set_error_handler(void (i8*, i8*)* %handler) #1 {
entry:
  store void (i8*, i8*)* %handler, void (i8*, i8*)** @_ZN6Halide7Runtime8Internal20halide_error_handlerE, align 8, !tbaa !18
  ret void
}

; Function Attrs: nounwind uwtable
define weak void @halide_print(i8* %user_context, i8* %msg) #1 {
entry:
  %0 = load void (i8*, i8*)** @_ZN6Halide7Runtime8Internal19halide_custom_printE, align 8, !tbaa !18
  %tobool = icmp eq void (i8*, i8*)* %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  tail call void %0(i8* %user_context, i8* %msg) #5
  br label %if.end

if.else:                                          ; preds = %entry
  tail call void @_ZN6Halide7Runtime8Internal17halide_print_implEPvPKc(i8* %user_context, i8* %msg) #5
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define weak void @halide_set_custom_print(void (i8*, i8*)* %print) #1 {
entry:
  store void (i8*, i8*)* %print, void (i8*, i8*)** @_ZN6Halide7Runtime8Internal19halide_custom_printE, align 8, !tbaa !18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce i64 @_ZN6Halide7Runtime8Internal11full_extentERK8buffer_t(%struct.buffer_t* dereferenceable(72) %buf) #1 {
entry:
  %arrayidx = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 0
  %0 = load i32* %arrayidx, align 4, !tbaa !15
  %cmp2 = icmp slt i32 %0, 0
  %sub = sub nsw i32 0, %0
  %sub. = select i1 %cmp2, i32 %sub, i32 %0
  %arrayidx4 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 2, i64 0
  %1 = load i32* %arrayidx4, align 4, !tbaa !15
  %mul = mul nsw i32 %sub., %1
  %conv = sext i32 %mul to i64
  %cmp5 = icmp ugt i64 %conv, 1
  %result.1 = select i1 %cmp5, i64 %conv, i64 1
  %arrayidx.1 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 1
  %2 = load i32* %arrayidx.1, align 4, !tbaa !15
  %cmp2.1 = icmp slt i32 %2, 0
  %sub.1 = sub nsw i32 0, %2
  %sub..1 = select i1 %cmp2.1, i32 %sub.1, i32 %2
  %arrayidx4.1 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 2, i64 1
  %3 = load i32* %arrayidx4.1, align 4, !tbaa !15
  %mul.1 = mul nsw i32 %sub..1, %3
  %conv.1 = sext i32 %mul.1 to i64
  %cmp5.1 = icmp ugt i64 %conv.1, %result.1
  %result.1.1 = select i1 %cmp5.1, i64 %conv.1, i64 %result.1
  %arrayidx.2 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 2
  %4 = load i32* %arrayidx.2, align 4, !tbaa !15
  %cmp2.2 = icmp slt i32 %4, 0
  %sub.2 = sub nsw i32 0, %4
  %sub..2 = select i1 %cmp2.2, i32 %sub.2, i32 %4
  %arrayidx4.2 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 2, i64 2
  %5 = load i32* %arrayidx4.2, align 4, !tbaa !15
  %mul.2 = mul nsw i32 %sub..2, %5
  %conv.2 = sext i32 %mul.2 to i64
  %cmp5.2 = icmp ugt i64 %conv.2, %result.1.1
  %result.1.2 = select i1 %cmp5.2, i64 %conv.2, i64 %result.1.1
  %arrayidx.3 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 3
  %6 = load i32* %arrayidx.3, align 4, !tbaa !15
  %cmp2.3 = icmp slt i32 %6, 0
  %sub.3 = sub nsw i32 0, %6
  %sub..3 = select i1 %cmp2.3, i32 %sub.3, i32 %6
  %arrayidx4.3 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 2, i64 3
  %7 = load i32* %arrayidx4.3, align 4, !tbaa !15
  %mul.3 = mul nsw i32 %sub..3, %7
  %conv.3 = sext i32 %mul.3 to i64
  %cmp5.3 = icmp ugt i64 %conv.3, %result.1.2
  %result.1.3 = select i1 %cmp5.3, i64 %conv.3, i64 %result.1.2
  ret i64 %result.1.3
}

; Function Attrs: nounwind uwtable
define linkonce void @_ZN6Halide7Runtime8Internal12copy_from_toEPvRK8buffer_tRS3_(i8* %user_context, %struct.buffer_t* dereferenceable(72) %from, %struct.buffer_t* dereferenceable(72) %to) #1 {
entry:
  %call = tail call i64 @_ZN6Halide7Runtime8Internal11full_extentERK8buffer_t(%struct.buffer_t* dereferenceable(72) %from) #6
  %elem_size = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 5
  %0 = load i32* %elem_size, align 4, !tbaa !20
  %elem_size1 = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 5
  %1 = load i32* %elem_size1, align 4, !tbaa !20
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %for.cond.preheader, label %if.then

if.then:                                          ; preds = %entry
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([31 x i8]* @.str36, i64 0, i64 0)) #5
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then, %entry
  %arrayidx = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 2, i64 0
  %2 = load i32* %arrayidx, align 4, !tbaa !15
  %arrayidx5 = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 2, i64 0
  %3 = load i32* %arrayidx5, align 4, !tbaa !15
  %cmp6 = icmp eq i32 %2, %3
  br i1 %cmp6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %for.cond.preheader
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([31 x i8]* @.str137, i64 0, i64 0)) #5
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %for.cond.preheader
  %arrayidx10 = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 3, i64 0
  %4 = load i32* %arrayidx10, align 4, !tbaa !15
  %arrayidx13 = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 3, i64 0
  %5 = load i32* %arrayidx13, align 4, !tbaa !15
  %cmp14 = icmp eq i32 %4, %5
  br i1 %cmp14, label %for.inc, label %if.then15

if.then15:                                        ; preds = %if.end8
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([31 x i8]* @.str238, i64 0, i64 0)) #5
  br label %for.inc

for.inc:                                          ; preds = %if.then15, %if.end8
  %arrayidx.1 = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 2, i64 1
  %6 = load i32* %arrayidx.1, align 4, !tbaa !15
  %arrayidx5.1 = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 2, i64 1
  %7 = load i32* %arrayidx5.1, align 4, !tbaa !15
  %cmp6.1 = icmp eq i32 %6, %7
  br i1 %cmp6.1, label %if.end8.1, label %if.then7.1

if.then7.1:                                       ; preds = %for.inc
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([31 x i8]* @.str137, i64 0, i64 0)) #5
  br label %if.end8.1

if.end8.1:                                        ; preds = %if.then7.1, %for.inc
  %arrayidx10.1 = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 3, i64 1
  %8 = load i32* %arrayidx10.1, align 4, !tbaa !15
  %arrayidx13.1 = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 3, i64 1
  %9 = load i32* %arrayidx13.1, align 4, !tbaa !15
  %cmp14.1 = icmp eq i32 %8, %9
  br i1 %cmp14.1, label %for.inc.1, label %if.then15.1

if.then15.1:                                      ; preds = %if.end8.1
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([31 x i8]* @.str238, i64 0, i64 0)) #5
  br label %for.inc.1

for.inc.1:                                        ; preds = %if.then15.1, %if.end8.1
  %arrayidx.2 = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 2, i64 2
  %10 = load i32* %arrayidx.2, align 4, !tbaa !15
  %arrayidx5.2 = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 2, i64 2
  %11 = load i32* %arrayidx5.2, align 4, !tbaa !15
  %cmp6.2 = icmp eq i32 %10, %11
  br i1 %cmp6.2, label %if.end8.2, label %if.then7.2

if.then7.2:                                       ; preds = %for.inc.1
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([31 x i8]* @.str137, i64 0, i64 0)) #5
  br label %if.end8.2

if.end8.2:                                        ; preds = %if.then7.2, %for.inc.1
  %arrayidx10.2 = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 3, i64 2
  %12 = load i32* %arrayidx10.2, align 4, !tbaa !15
  %arrayidx13.2 = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 3, i64 2
  %13 = load i32* %arrayidx13.2, align 4, !tbaa !15
  %cmp14.2 = icmp eq i32 %12, %13
  br i1 %cmp14.2, label %for.inc.2, label %if.then15.2

if.then15.2:                                      ; preds = %if.end8.2
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([31 x i8]* @.str238, i64 0, i64 0)) #5
  br label %for.inc.2

for.inc.2:                                        ; preds = %if.then15.2, %if.end8.2
  %arrayidx.3 = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 2, i64 3
  %14 = load i32* %arrayidx.3, align 4, !tbaa !15
  %arrayidx5.3 = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 2, i64 3
  %15 = load i32* %arrayidx5.3, align 4, !tbaa !15
  %cmp6.3 = icmp eq i32 %14, %15
  br i1 %cmp6.3, label %if.end8.3, label %if.then7.3

if.then7.3:                                       ; preds = %for.inc.2
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([31 x i8]* @.str137, i64 0, i64 0)) #5
  br label %if.end8.3

if.end8.3:                                        ; preds = %if.then7.3, %for.inc.2
  %arrayidx10.3 = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 3, i64 3
  %16 = load i32* %arrayidx10.3, align 4, !tbaa !15
  %arrayidx13.3 = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 3, i64 3
  %17 = load i32* %arrayidx13.3, align 4, !tbaa !15
  %cmp14.3 = icmp eq i32 %16, %17
  br i1 %cmp14.3, label %for.inc.3, label %if.then15.3

if.then15.3:                                      ; preds = %if.end8.3
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([31 x i8]* @.str238, i64 0, i64 0)) #5
  br label %for.inc.3

for.inc.3:                                        ; preds = %if.then15.3, %if.end8.3
  %host = getelementptr inbounds %struct.buffer_t* %to, i64 0, i32 1
  %18 = load i8** %host, align 8, !tbaa !22
  %host17 = getelementptr inbounds %struct.buffer_t* %from, i64 0, i32 1
  %19 = load i8** %host17, align 8, !tbaa !22
  %20 = load i32* %elem_size, align 4, !tbaa !20
  %conv = sext i32 %20 to i64
  %mul = mul i64 %conv, %call
  %call19 = tail call i8* @memcpy(i8* %18, i8* %19, i64 %mul) #5
  ret void
}

; Function Attrs: nounwind
declare i8* @memcpy(i8*, i8* nocapture readonly, i64) #4

; Function Attrs: nounwind uwtable
define linkonce void @_ZN6Halide7Runtime8Internal14copy_of_bufferEPvRK8buffer_t(%struct.buffer_t* noalias sret %agg.result, i8* %user_context, %struct.buffer_t* dereferenceable(72) %buf) #1 {
entry:
  %0 = bitcast %struct.buffer_t* %agg.result to i8*
  %1 = bitcast %struct.buffer_t* %buf to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* %1, i64 72, i32 8, i1 false), !tbaa.struct !23
  %call = tail call i64 @_ZN6Halide7Runtime8Internal11full_extentERK8buffer_t(%struct.buffer_t* dereferenceable(72) %agg.result) #6
  %elem_size = getelementptr inbounds %struct.buffer_t* %agg.result, i64 0, i32 5
  %2 = load i32* %elem_size, align 8, !tbaa !20
  %conv = sext i32 %2 to i64
  %mul = mul i64 %conv, %call
  %call1 = tail call i8* @halide_malloc(i8* %user_context, i64 %mul) #5
  %host = getelementptr inbounds %struct.buffer_t* %agg.result, i64 0, i32 1
  store i8* %call1, i8** %host, align 8, !tbaa !22
  tail call void @_ZN6Halide7Runtime8Internal12copy_from_toEPvRK8buffer_tRS3_(i8* %user_context, %struct.buffer_t* dereferenceable(72) %buf, %struct.buffer_t* dereferenceable(72) %agg.result) #6
  ret void
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #3

; Function Attrs: nounwind uwtable
define linkonce zeroext i1 @_ZN6Halide7Runtime8Internal10keys_equalEPKhS3_m(i8* %key1, i8* %key2, i64 %key_size) #1 {
entry:
  %call = tail call i32 @memcmp(i8* %key1, i8* %key2, i64 %key_size) #5
  %cmp = icmp eq i32 %call, 0
  ret i1 %cmp
}

; Function Attrs: nounwind readonly
declare i32 @memcmp(i8* nocapture, i8* nocapture, i64) #2

; Function Attrs: nounwind uwtable
define linkonce zeroext i1 @_ZN6Halide7Runtime8Internal12bounds_equalERK8buffer_tS4_(%struct.buffer_t* dereferenceable(72) %buf1, %struct.buffer_t* dereferenceable(72) %buf2) #1 {
entry:
  %elem_size = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 5
  %0 = load i32* %elem_size, align 4, !tbaa !20
  %elem_size1 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 5
  %1 = load i32* %elem_size1, align 4, !tbaa !20
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %for.cond.preheader, label %return

for.cond.preheader:                               ; preds = %entry
  %arrayidx = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 4, i64 0
  %2 = load i32* %arrayidx, align 4, !tbaa !15
  %arrayidx4 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 4, i64 0
  %3 = load i32* %arrayidx4, align 4, !tbaa !15
  %cmp5 = icmp eq i32 %2, %3
  br i1 %cmp5, label %lor.lhs.false, label %return

for.cond:                                         ; preds = %lor.lhs.false10
  %arrayidx.1 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 4, i64 1
  %4 = load i32* %arrayidx.1, align 4, !tbaa !15
  %arrayidx4.1 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 4, i64 1
  %5 = load i32* %arrayidx4.1, align 4, !tbaa !15
  %cmp5.1 = icmp eq i32 %4, %5
  br i1 %cmp5.1, label %lor.lhs.false.1, label %return

lor.lhs.false:                                    ; preds = %for.cond.preheader
  %arrayidx6 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 2, i64 0
  %6 = load i32* %arrayidx6, align 4, !tbaa !15
  %arrayidx8 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 2, i64 0
  %7 = load i32* %arrayidx8, align 4, !tbaa !15
  %cmp9 = icmp eq i32 %6, %7
  br i1 %cmp9, label %lor.lhs.false10, label %return

lor.lhs.false10:                                  ; preds = %lor.lhs.false
  %arrayidx11 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 3, i64 0
  %8 = load i32* %arrayidx11, align 4, !tbaa !15
  %arrayidx13 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 3, i64 0
  %9 = load i32* %arrayidx13, align 4, !tbaa !15
  %cmp14 = icmp eq i32 %8, %9
  br i1 %cmp14, label %for.cond, label %return

return:                                           ; preds = %lor.lhs.false.3, %for.cond.2, %lor.lhs.false10.2, %lor.lhs.false.2, %for.cond.1, %lor.lhs.false10.1, %lor.lhs.false.1, %lor.lhs.false10, %lor.lhs.false, %for.cond, %for.cond.preheader, %entry
  ret i1 false

lor.lhs.false.1:                                  ; preds = %for.cond
  %arrayidx6.1 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 2, i64 1
  %10 = load i32* %arrayidx6.1, align 4, !tbaa !15
  %arrayidx8.1 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 2, i64 1
  %11 = load i32* %arrayidx8.1, align 4, !tbaa !15
  %cmp9.1 = icmp eq i32 %10, %11
  br i1 %cmp9.1, label %lor.lhs.false10.1, label %return

lor.lhs.false10.1:                                ; preds = %lor.lhs.false.1
  %arrayidx11.1 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 3, i64 1
  %12 = load i32* %arrayidx11.1, align 4, !tbaa !15
  %arrayidx13.1 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 3, i64 1
  %13 = load i32* %arrayidx13.1, align 4, !tbaa !15
  %cmp14.1 = icmp eq i32 %12, %13
  br i1 %cmp14.1, label %for.cond.1, label %return

for.cond.1:                                       ; preds = %lor.lhs.false10.1
  %arrayidx.2 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 4, i64 2
  %14 = load i32* %arrayidx.2, align 4, !tbaa !15
  %arrayidx4.2 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 4, i64 2
  %15 = load i32* %arrayidx4.2, align 4, !tbaa !15
  %cmp5.2 = icmp eq i32 %14, %15
  br i1 %cmp5.2, label %lor.lhs.false.2, label %return

lor.lhs.false.2:                                  ; preds = %for.cond.1
  %arrayidx6.2 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 2, i64 2
  %16 = load i32* %arrayidx6.2, align 4, !tbaa !15
  %arrayidx8.2 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 2, i64 2
  %17 = load i32* %arrayidx8.2, align 4, !tbaa !15
  %cmp9.2 = icmp eq i32 %16, %17
  br i1 %cmp9.2, label %lor.lhs.false10.2, label %return

lor.lhs.false10.2:                                ; preds = %lor.lhs.false.2
  %arrayidx11.2 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 3, i64 2
  %18 = load i32* %arrayidx11.2, align 4, !tbaa !15
  %arrayidx13.2 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 3, i64 2
  %19 = load i32* %arrayidx13.2, align 4, !tbaa !15
  %cmp14.2 = icmp eq i32 %18, %19
  br i1 %cmp14.2, label %for.cond.2, label %return

for.cond.2:                                       ; preds = %lor.lhs.false10.2
  %arrayidx.3 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 4, i64 3
  %20 = load i32* %arrayidx.3, align 4, !tbaa !15
  %arrayidx4.3 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 4, i64 3
  %21 = load i32* %arrayidx4.3, align 4, !tbaa !15
  %cmp5.3 = icmp eq i32 %20, %21
  br i1 %cmp5.3, label %lor.lhs.false.3, label %return

lor.lhs.false.3:                                  ; preds = %for.cond.2
  %arrayidx6.3 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 2, i64 3
  %22 = load i32* %arrayidx6.3, align 4, !tbaa !15
  %arrayidx8.3 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 2, i64 3
  %23 = load i32* %arrayidx8.3, align 4, !tbaa !15
  %cmp9.3 = icmp eq i32 %22, %23
  br i1 %cmp9.3, label %lor.lhs.false10.3, label %return

lor.lhs.false10.3:                                ; preds = %lor.lhs.false.3
  %arrayidx11.3 = getelementptr inbounds %struct.buffer_t* %buf1, i64 0, i32 3, i64 3
  %24 = load i32* %arrayidx11.3, align 4, !tbaa !15
  %arrayidx13.3 = getelementptr inbounds %struct.buffer_t* %buf2, i64 0, i32 3, i64 3
  %25 = load i32* %arrayidx13.3, align 4, !tbaa !15
  %cmp14.3 = icmp eq i32 %24, %25
  ret i1 %cmp14.3
}

; Function Attrs: nounwind uwtable
define linkonce void @_ZN6Halide7Runtime8Internal10CacheEntry4initEPvPKhmjRK8buffer_tiPPS6_(%"struct.Halide::Runtime::Internal::CacheEntry"* %this, i8* %context, i8* %cache_key, i64 %cache_key_size, i32 %key_hash, %struct.buffer_t* dereferenceable(72) %computed_buf, i32 %tuples, %struct.buffer_t** %tuple_buffers) #1 align 2 {
entry:
  %ref.tmp = alloca %struct.buffer_t, align 8
  %user_context = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 0
  store i8* %context, i8** %user_context, align 8, !tbaa !24
  %next = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 1
  %key_size = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 4
  %0 = bitcast %"struct.Halide::Runtime::Internal::CacheEntry"** %next to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 24, i32 8, i1 false)
  store i64 %cache_key_size, i64* %key_size, align 8, !tbaa !26
  %hash = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 6
  store i32 %key_hash, i32* %hash, align 4, !tbaa !27
  %tuple_count = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 7
  store i32 %tuples, i32* %tuple_count, align 4, !tbaa !28
  %call = tail call i8* @halide_malloc(i8* %context, i64 %cache_key_size) #5
  %key = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 5
  store i8* %call, i8** %key, align 8, !tbaa !29
  %computed_bounds = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 8
  %1 = bitcast %struct.buffer_t* %computed_bounds to i8*
  %2 = bitcast %struct.buffer_t* %computed_buf to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 72, i32 8, i1 false), !tbaa.struct !23
  %3 = bitcast %struct.buffer_t* %computed_bounds to i8*
  call void @llvm.memset.p0i8.i64(i8* %3, i8 0, i64 16, i32 8, i1 false)
  %4 = load i64* %key_size, align 8, !tbaa !26
  %cmp28 = icmp eq i64 %4, 0
  br i1 %cmp28, label %for.cond10.preheader, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %5 = load i8* %cache_key, align 1, !tbaa !19
  store i8 %5, i8* %call, align 1, !tbaa !19
  %cmp1 = icmp ugt i64 %4, 1
  br i1 %cmp1, label %for.body.for.body_crit_edge.preheader, label %for.cond10.preheader

for.body.for.body_crit_edge.preheader:            ; preds = %for.body.preheader
  br label %for.body.for.body_crit_edge

for.cond10.preheader.loopexit:                    ; preds = %for.body.for.body_crit_edge
  br label %for.cond10.preheader

for.cond10.preheader:                             ; preds = %for.cond10.preheader.loopexit, %for.body.preheader, %entry
  %6 = load i32* %tuple_count, align 4, !tbaa !28
  %cmp1226 = icmp eq i32 %6, 0
  br i1 %cmp1226, label %for.end19, label %for.body13.lr.ph

for.body13.lr.ph:                                 ; preds = %for.cond10.preheader
  %7 = bitcast %struct.buffer_t* %ref.tmp to i8*
  br label %for.body13

for.body.for.body_crit_edge:                      ; preds = %for.body.for.body_crit_edge.preheader, %for.body.for.body_crit_edge.for.body.for.body_crit_edge_crit_edge
  %.pre = phi i8* [ %.pre.pre, %for.body.for.body_crit_edge.for.body.for.body_crit_edge_crit_edge ], [ %call, %for.body.for.body_crit_edge.preheader ]
  %inc2 = phi i64 [ %inc, %for.body.for.body_crit_edge.for.body.for.body_crit_edge_crit_edge ], [ 1, %for.body.for.body_crit_edge.preheader ]
  %arrayidx = getelementptr inbounds i8* %cache_key, i64 %inc2
  %8 = load i8* %arrayidx, align 1, !tbaa !19
  %arrayidx8 = getelementptr inbounds i8* %.pre, i64 %inc2
  store i8 %8, i8* %arrayidx8, align 1, !tbaa !19
  %inc = add nuw i64 %inc2, 1
  %9 = load i64* %key_size, align 8, !tbaa !26
  %cmp = icmp ult i64 %inc, %9
  br i1 %cmp, label %for.body.for.body_crit_edge.for.body.for.body_crit_edge_crit_edge, label %for.cond10.preheader.loopexit

for.body.for.body_crit_edge.for.body.for.body_crit_edge_crit_edge: ; preds = %for.body.for.body_crit_edge
  %.pre.pre = load i8** %key, align 8, !tbaa !29
  br label %for.body.for.body_crit_edge

for.body13:                                       ; preds = %for.body13, %for.body13.lr.ph
  %indvars.iv = phi i64 [ 0, %for.body13.lr.ph ], [ %indvars.iv.next, %for.body13 ]
  %arrayidx14 = getelementptr inbounds %struct.buffer_t** %tuple_buffers, i64 %indvars.iv
  %10 = load %struct.buffer_t** %arrayidx14, align 8, !tbaa !18
  %11 = trunc i64 %indvars.iv to i32
  %call15 = call dereferenceable(72) %struct.buffer_t* @_ZN6Halide7Runtime8Internal10CacheEntry6bufferEi(%"struct.Halide::Runtime::Internal::CacheEntry"* %this, i32 %11) #6
  %12 = load i8** %user_context, align 8, !tbaa !24
  call void @_ZN6Halide7Runtime8Internal14copy_of_bufferEPvRK8buffer_t(%struct.buffer_t* sret %ref.tmp, i8* %12, %struct.buffer_t* dereferenceable(72) %10) #6
  %13 = bitcast %struct.buffer_t* %call15 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %7, i64 72, i32 8, i1 false), !tbaa.struct !23
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %14 = load i32* %tuple_count, align 4, !tbaa !28
  %15 = trunc i64 %indvars.iv.next to i32
  %cmp12 = icmp ult i32 %15, %14
  br i1 %cmp12, label %for.body13, label %for.end19.loopexit

for.end19.loopexit:                               ; preds = %for.body13
  br label %for.end19

for.end19:                                        ; preds = %for.end19.loopexit, %for.cond10.preheader
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce dereferenceable(72) %struct.buffer_t* @_ZN6Halide7Runtime8Internal10CacheEntry6bufferEi(%"struct.Halide::Runtime::Internal::CacheEntry"* %this, i32 %i) #1 align 2 {
entry:
  %idxprom = sext i32 %i to i64
  %arrayidx2 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 9, i64 %idxprom
  ret %struct.buffer_t* %arrayidx2
}

; Function Attrs: nounwind uwtable
define linkonce void @_ZN6Halide7Runtime8Internal10CacheEntry7destroyEv(%"struct.Halide::Runtime::Internal::CacheEntry"* %this) #1 align 2 {
entry:
  %user_context = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 0
  %0 = load i8** %user_context, align 8, !tbaa !24
  %key = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 5
  %1 = load i8** %key, align 8, !tbaa !29
  tail call void @halide_free(i8* %0, i8* %1) #5
  %tuple_count = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %this, i64 0, i32 7
  %2 = load i32* %tuple_count, align 4, !tbaa !28
  %cmp9 = icmp eq i32 %2, 0
  br i1 %cmp9, label %for.end, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %i.010 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %3 = load i8** %user_context, align 8, !tbaa !24
  %call = tail call dereferenceable(72) %struct.buffer_t* @_ZN6Halide7Runtime8Internal10CacheEntry6bufferEi(%"struct.Halide::Runtime::Internal::CacheEntry"* %this, i32 %i.010) #6
  %call3 = tail call i32 @halide_dev_free(i8* %3, %struct.buffer_t* %call) #5
  %4 = load i8** %user_context, align 8, !tbaa !24
  %call5 = tail call dereferenceable(72) %struct.buffer_t* @_ZN6Halide7Runtime8Internal10CacheEntry6bufferEi(%"struct.Halide::Runtime::Internal::CacheEntry"* %this, i32 %i.010) #6
  %host = getelementptr inbounds %struct.buffer_t* %call5, i64 0, i32 1
  %5 = load i8** %host, align 8, !tbaa !22
  tail call void @halide_free(i8* %4, i8* %5) #5
  %inc = add nuw nsw i32 %i.010, 1
  %6 = load i32* %tuple_count, align 4, !tbaa !28
  %cmp = icmp ult i32 %inc, %6
  br i1 %cmp, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce i32 @_ZN6Halide7Runtime8Internal8djb_hashEPKhm(i8* %key, i64 %key_size) #1 {
entry:
  %cmp5 = icmp eq i64 %key_size, 0
  br i1 %cmp5, label %for.end, label %for.body.preheader

for.body.preheader:                               ; preds = %entry
  %xtraiter = and i64 %key_size, 3
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %for.body.preheader.split, label %for.body.prol.preheader

for.body.prol.preheader:                          ; preds = %for.body.preheader
  br label %for.body.prol

for.body.prol:                                    ; preds = %for.body.prol.preheader, %for.body.prol
  %i.07.prol = phi i64 [ %inc.prol, %for.body.prol ], [ 0, %for.body.prol.preheader ]
  %h.06.prol = phi i32 [ %add1.prol, %for.body.prol ], [ 5381, %for.body.prol.preheader ]
  %prol.iter = phi i64 [ %prol.iter.sub, %for.body.prol ], [ %xtraiter, %for.body.prol.preheader ]
  %add.prol = mul i32 %h.06.prol, 33
  %arrayidx.prol = getelementptr inbounds i8* %key, i64 %i.07.prol
  %0 = load i8* %arrayidx.prol, align 1, !tbaa !19
  %conv.prol = zext i8 %0 to i32
  %add1.prol = add i32 %conv.prol, %add.prol
  %inc.prol = add nuw i64 %i.07.prol, 1
  %prol.iter.sub = add i64 %prol.iter, -1
  %prol.iter.cmp = icmp eq i64 %prol.iter.sub, 0
  br i1 %prol.iter.cmp, label %for.body.preheader.split.loopexit, label %for.body.prol, !llvm.loop !30

for.body.preheader.split.loopexit:                ; preds = %for.body.prol
  %add1.prol.lcssa = phi i32 [ %add1.prol, %for.body.prol ]
  %1 = and i64 %key_size, 3
  br label %for.body.preheader.split

for.body.preheader.split:                         ; preds = %for.body.preheader, %for.body.preheader.split.loopexit
  %add1.lcssa.unr = phi i32 [ 0, %for.body.preheader ], [ %add1.prol.lcssa, %for.body.preheader.split.loopexit ]
  %i.07.unr = phi i64 [ 0, %for.body.preheader ], [ %1, %for.body.preheader.split.loopexit ]
  %h.06.unr = phi i32 [ 5381, %for.body.preheader ], [ %add1.prol.lcssa, %for.body.preheader.split.loopexit ]
  %2 = icmp ult i64 %key_size, 4
  br i1 %2, label %for.end, label %for.body.preheader3

for.body.preheader3:                              ; preds = %for.body.preheader.split
  br label %for.body

for.body:                                         ; preds = %for.body.preheader3, %for.body
  %i.07 = phi i64 [ %inc.3, %for.body ], [ %i.07.unr, %for.body.preheader3 ]
  %h.06 = phi i32 [ %add1.3, %for.body ], [ %h.06.unr, %for.body.preheader3 ]
  %add = mul i32 %h.06, 33
  %arrayidx = getelementptr inbounds i8* %key, i64 %i.07
  %3 = load i8* %arrayidx, align 1, !tbaa !19
  %conv = zext i8 %3 to i32
  %add1 = add i32 %conv, %add
  %inc = add nuw i64 %i.07, 1
  %add.1 = mul i32 %add1, 33
  %arrayidx.1 = getelementptr inbounds i8* %key, i64 %inc
  %4 = load i8* %arrayidx.1, align 1, !tbaa !19
  %conv.1 = zext i8 %4 to i32
  %add1.1 = add i32 %add.1, %conv.1
  %inc.1 = add i64 %i.07, 2
  %add.2 = mul i32 %add1.1, 33
  %arrayidx.2 = getelementptr inbounds i8* %key, i64 %inc.1
  %5 = load i8* %arrayidx.2, align 1, !tbaa !19
  %conv.2 = zext i8 %5 to i32
  %add1.2 = add i32 %add.2, %conv.2
  %inc.2 = add i64 %i.07, 3
  %add.3 = mul i32 %add1.2, 33
  %arrayidx.3 = getelementptr inbounds i8* %key, i64 %inc.2
  %6 = load i8* %arrayidx.3, align 1, !tbaa !19
  %conv.3 = zext i8 %6 to i32
  %add1.3 = add i32 %add.3, %conv.3
  %inc.3 = add i64 %i.07, 4
  %exitcond.3 = icmp eq i64 %inc.3, %key_size
  br i1 %exitcond.3, label %for.end.loopexit, label %for.body

for.end.loopexit:                                 ; preds = %for.body
  %add1.3.lcssa = phi i32 [ %add1.3, %for.body ]
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %for.body.preheader.split, %entry
  %h.0.lcssa = phi i32 [ 5381, %entry ], [ %add1.lcssa.unr, %for.body.preheader.split ], [ %add1.3.lcssa, %for.end.loopexit ]
  ret i32 %h.0.lcssa
}

; Function Attrs: nounwind uwtable
define linkonce void @_ZN6Halide7Runtime8Internal11prune_cacheEv() #1 {
entry:
  %0 = load i64* @_ZN6Halide7Runtime8Internal18current_cache_sizeE, align 8, !tbaa !17
  %1 = load i64* @_ZN6Halide7Runtime8Internal14max_cache_sizeE, align 8, !tbaa !17
  %cmp49 = icmp sgt i64 %0, %1
  %2 = load %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal19least_recently_usedE, align 8
  %cmp150 = icmp ne %"struct.Halide::Runtime::Internal::CacheEntry"* %2, null
  %or.cond51 = and i1 %cmp49, %cmp150
  br i1 %or.cond51, label %while.body.preheader, label %while.end28

while.body.preheader:                             ; preds = %entry
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %for.end
  %3 = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %18, %for.end ], [ %2, %while.body.preheader ]
  %hash = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %3, i64 0, i32 6
  %4 = load i32* %hash, align 4, !tbaa !27
  %5 = and i32 %4, 255
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr inbounds [256 x %"struct.Halide::Runtime::Internal::CacheEntry"*]* @_ZN6Halide7Runtime8Internal13cache_entriesE, i64 0, i64 %idxprom
  %6 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %arrayidx, align 8, !tbaa !18
  %cmp4 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %6, %3
  br i1 %cmp4, label %if.then, label %while.cond7.preheader

while.cond7.preheader:                            ; preds = %while.body
  br label %while.cond7

if.then:                                          ; preds = %while.body
  %next = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %3, i64 0, i32 1
  %7 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %next, align 8, !tbaa !32
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %7, %"struct.Halide::Runtime::Internal::CacheEntry"** %arrayidx, align 8, !tbaa !18
  br label %if.end19

while.cond7:                                      ; preds = %while.cond7.preheader, %land.rhs9
  %entry3.0 = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %8, %land.rhs9 ], [ %6, %while.cond7.preheader ]
  %cmp8 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0, null
  br i1 %cmp8, label %if.then16, label %land.rhs9

land.rhs9:                                        ; preds = %while.cond7
  %next10 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0, i64 0, i32 1
  %8 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %next10, align 8, !tbaa !32
  %cmp11 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %8, %3
  br i1 %cmp11, label %if.end, label %while.cond7

if.then16:                                        ; preds = %while.cond7
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([14 x i8]* @.str339, i64 0, i64 0)) #5
  unreachable

if.end:                                           ; preds = %land.rhs9
  %next10.lcssa = phi %"struct.Halide::Runtime::Internal::CacheEntry"** [ %next10, %land.rhs9 ]
  %next17 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %3, i64 0, i32 1
  %9 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %next17, align 8, !tbaa !32
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %9, %"struct.Halide::Runtime::Internal::CacheEntry"** %next10.lcssa, align 8, !tbaa !32
  br label %if.end19

if.end19:                                         ; preds = %if.end, %if.then
  %more_recent = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %3, i64 0, i32 2
  %10 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent, align 8, !tbaa !33
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %10, %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal19least_recently_usedE, align 8, !tbaa !18
  %cmp20 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %10, null
  br i1 %cmp20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %if.end19
  %less_recent = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %10, i64 0, i32 3
  store %"struct.Halide::Runtime::Internal::CacheEntry"* null, %"struct.Halide::Runtime::Internal::CacheEntry"** %less_recent, align 8, !tbaa !34
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %if.end19
  %11 = load %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal18most_recently_usedE, align 8, !tbaa !18
  %cmp23 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %11, %3
  br i1 %cmp23, label %if.then24, label %for.cond.preheader

if.then24:                                        ; preds = %if.end22
  store %"struct.Halide::Runtime::Internal::CacheEntry"* null, %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal18most_recently_usedE, align 8, !tbaa !18
  br label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.then24, %if.end22
  %tuple_count = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %3, i64 0, i32 7
  %12 = load i32* %tuple_count, align 4, !tbaa !28
  %cmp2647 = icmp eq i32 %12, 0
  br i1 %cmp2647, label %for.end, label %for.body.preheader

for.body.preheader:                               ; preds = %for.cond.preheader
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %i.048 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %call = tail call dereferenceable(72) %struct.buffer_t* @_ZN6Halide7Runtime8Internal10CacheEntry6bufferEi(%"struct.Halide::Runtime::Internal::CacheEntry"* %3, i32 %i.048) #6
  %call27 = tail call i64 @_ZN6Halide7Runtime8Internal11full_extentERK8buffer_t(%struct.buffer_t* dereferenceable(72) %call) #6
  %13 = load i64* @_ZN6Halide7Runtime8Internal18current_cache_sizeE, align 8, !tbaa !17
  %sub = sub i64 %13, %call27
  store i64 %sub, i64* @_ZN6Halide7Runtime8Internal18current_cache_sizeE, align 8, !tbaa !17
  %inc = add nuw nsw i32 %i.048, 1
  %14 = load i32* %tuple_count, align 4, !tbaa !28
  %cmp26 = icmp ult i32 %inc, %14
  br i1 %cmp26, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %for.cond.preheader
  tail call void @_ZN6Halide7Runtime8Internal10CacheEntry7destroyEv(%"struct.Halide::Runtime::Internal::CacheEntry"* %3) #6
  %15 = bitcast %"struct.Halide::Runtime::Internal::CacheEntry"* %3 to i8*
  tail call void @halide_free(i8* null, i8* %15) #5
  %16 = load i64* @_ZN6Halide7Runtime8Internal18current_cache_sizeE, align 8, !tbaa !17
  %17 = load i64* @_ZN6Halide7Runtime8Internal14max_cache_sizeE, align 8, !tbaa !17
  %cmp = icmp sgt i64 %16, %17
  %18 = load %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal19least_recently_usedE, align 8
  %cmp1 = icmp ne %"struct.Halide::Runtime::Internal::CacheEntry"* %18, null
  %or.cond = and i1 %cmp, %cmp1
  br i1 %or.cond, label %while.body, label %while.end28.loopexit

while.end28.loopexit:                             ; preds = %for.end
  br label %while.end28

while.end28:                                      ; preds = %while.end28.loopexit, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define weak void @halide_memoization_cache_set_size(i64 %size) #1 {
entry:
  %cmp = icmp eq i64 %size, 0
  %.size = select i1 %cmp, i64 1048576, i64 %size
  tail call void @halide_mutex_lock(%struct.pthread_mutex_t* @_ZN6Halide7Runtime8Internal16memoization_lockE) #5
  store i64 %.size, i64* @_ZN6Halide7Runtime8Internal14max_cache_sizeE, align 8, !tbaa !17
  tail call void @_ZN6Halide7Runtime8Internal11prune_cacheEv() #6
  tail call void @halide_mutex_unlock(%struct.pthread_mutex_t* @_ZN6Halide7Runtime8Internal16memoization_lockE) #5
  ret void
}

; Function Attrs: nounwind uwtable
define weak zeroext i1 @halide_memoization_cache_lookup(i8* %user_context, i8* %cache_key, i32 %size, %struct.buffer_t* %computed_bounds, i32 %tuple_count, %struct.buffer_t** %tuple_buffers) #1 {
entry:
  %conv = sext i32 %size to i64
  %call = tail call i32 @_ZN6Halide7Runtime8Internal8djb_hashEPKhm(i8* %cache_key, i64 %conv) #6
  %0 = and i32 %call, 255
  tail call void @halide_mutex_lock(%struct.pthread_mutex_t* @_ZN6Halide7Runtime8Internal16memoization_lockE) #5
  %idxprom = zext i32 %0 to i64
  %arrayidx = getelementptr inbounds [256 x %"struct.Halide::Runtime::Internal::CacheEntry"*]* @_ZN6Halide7Runtime8Internal13cache_entriesE, i64 0, i64 %idxprom
  %entry3.0111 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %arrayidx, align 8
  %cmp112 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0111, null
  br i1 %cmp112, label %cleanup, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %cmp16108 = icmp sgt i32 %tuple_count, 0
  br i1 %cmp16108, label %while.body.lr.ph.split.us, label %while.body.preheader

while.body.preheader:                             ; preds = %while.body.lr.ph
  br label %while.body

while.body.lr.ph.split.us:                        ; preds = %while.body.lr.ph
  %1 = sext i32 %tuple_count to i64
  br label %while.body.us

while.body.us:                                    ; preds = %if.end63.us, %while.body.lr.ph.split.us
  %entry3.0113.us = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %entry3.0111, %while.body.lr.ph.split.us ], [ %entry3.0.us, %if.end63.us ]
  %hash.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113.us, i64 0, i32 6
  %2 = load i32* %hash.us, align 4, !tbaa !27
  %cmp4.us = icmp eq i32 %2, %call
  br i1 %cmp4.us, label %land.lhs.true.us, label %if.end63.us

land.lhs.true.us:                                 ; preds = %while.body.us
  %key_size.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113.us, i64 0, i32 4
  %3 = load i64* %key_size.us, align 8, !tbaa !26
  %cmp6.us = icmp eq i64 %3, %conv
  br i1 %cmp6.us, label %land.lhs.true7.us, label %if.end63.us

land.lhs.true7.us:                                ; preds = %land.lhs.true.us
  %key.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113.us, i64 0, i32 5
  %4 = load i8** %key.us, align 8, !tbaa !29
  %call9.us = tail call zeroext i1 @_ZN6Halide7Runtime8Internal10keys_equalEPKhS3_m(i8* %4, i8* %cache_key, i64 %conv) #6
  br i1 %call9.us, label %land.lhs.true10.us, label %if.end63.us

land.lhs.true10.us:                               ; preds = %land.lhs.true7.us
  %computed_bounds11.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113.us, i64 0, i32 8
  %call12.us = tail call zeroext i1 @_ZN6Halide7Runtime8Internal12bounds_equalERK8buffer_tS4_(%struct.buffer_t* dereferenceable(72) %computed_bounds11.us, %struct.buffer_t* dereferenceable(72) %computed_bounds) #6
  br i1 %call12.us, label %land.lhs.true13.us, label %if.end63.us

land.lhs.true13.us:                               ; preds = %land.lhs.true10.us
  %tuple_count14.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113.us, i64 0, i32 7
  %5 = load i32* %tuple_count14.us, align 4, !tbaa !28
  %cmp15.us = icmp eq i32 %5, %tuple_count
  br i1 %cmp15.us, label %for.body.us.preheader, label %if.end63.us

for.body.us.preheader:                            ; preds = %land.lhs.true13.us
  br label %for.body.us

for.end.us:                                       ; preds = %for.body.us
  %call20.us.lcssa = phi i1 [ %call20.us, %for.body.us ]
  br i1 %call20.us.lcssa, label %if.then22.loopexit, label %if.end63.us

if.end63.us:                                      ; preds = %for.end.us, %land.lhs.true13.us, %land.lhs.true10.us, %land.lhs.true7.us, %land.lhs.true.us, %while.body.us
  %next.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113.us, i64 0, i32 1
  %entry3.0.us = load %"struct.Halide::Runtime::Internal::CacheEntry"** %next.us, align 8
  %cmp.us = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0.us, null
  br i1 %cmp.us, label %cleanup.loopexit14, label %while.body.us

for.body.us:                                      ; preds = %for.body.us.preheader, %for.body.us
  %indvars.iv117 = phi i64 [ %indvars.iv.next118, %for.body.us ], [ 0, %for.body.us.preheader ]
  %arrayidx18.us = getelementptr inbounds %struct.buffer_t** %tuple_buffers, i64 %indvars.iv117
  %6 = load %struct.buffer_t** %arrayidx18.us, align 8, !tbaa !18
  %7 = trunc i64 %indvars.iv117 to i32
  %call19.us = tail call dereferenceable(72) %struct.buffer_t* @_ZN6Halide7Runtime8Internal10CacheEntry6bufferEi(%"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113.us, i32 %7) #6
  %call20.us = tail call zeroext i1 @_ZN6Halide7Runtime8Internal12bounds_equalERK8buffer_tS4_(%struct.buffer_t* dereferenceable(72) %call19.us, %struct.buffer_t* dereferenceable(72) %6) #6
  %indvars.iv.next118 = add nuw nsw i64 %indvars.iv117, 1
  %cmp16.us = icmp slt i64 %indvars.iv.next118, %1
  %or.cond.us = and i1 %cmp16.us, %call20.us
  br i1 %or.cond.us, label %for.body.us, label %for.end.us

while.body:                                       ; preds = %while.body.preheader, %if.end63
  %entry3.0113 = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %entry3.0, %if.end63 ], [ %entry3.0111, %while.body.preheader ]
  %hash = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113, i64 0, i32 6
  %8 = load i32* %hash, align 4, !tbaa !27
  %cmp4 = icmp eq i32 %8, %call
  br i1 %cmp4, label %land.lhs.true, label %if.end63

land.lhs.true:                                    ; preds = %while.body
  %key_size = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113, i64 0, i32 4
  %9 = load i64* %key_size, align 8, !tbaa !26
  %cmp6 = icmp eq i64 %9, %conv
  br i1 %cmp6, label %land.lhs.true7, label %if.end63

land.lhs.true7:                                   ; preds = %land.lhs.true
  %key = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113, i64 0, i32 5
  %10 = load i8** %key, align 8, !tbaa !29
  %call9 = tail call zeroext i1 @_ZN6Halide7Runtime8Internal10keys_equalEPKhS3_m(i8* %10, i8* %cache_key, i64 %conv) #6
  br i1 %call9, label %land.lhs.true10, label %if.end63

land.lhs.true10:                                  ; preds = %land.lhs.true7
  %computed_bounds11 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113, i64 0, i32 8
  %call12 = tail call zeroext i1 @_ZN6Halide7Runtime8Internal12bounds_equalERK8buffer_tS4_(%struct.buffer_t* dereferenceable(72) %computed_bounds11, %struct.buffer_t* dereferenceable(72) %computed_bounds) #6
  br i1 %call12, label %land.lhs.true13, label %if.end63

land.lhs.true13:                                  ; preds = %land.lhs.true10
  %tuple_count14 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113, i64 0, i32 7
  %11 = load i32* %tuple_count14, align 4, !tbaa !28
  %cmp15 = icmp eq i32 %11, %tuple_count
  br i1 %cmp15, label %if.then22.loopexit15, label %if.end63

if.then22.loopexit:                               ; preds = %for.end.us
  %entry3.0113.us.lcssa = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %entry3.0113.us, %for.end.us ]
  br label %if.then22

if.then22.loopexit15:                             ; preds = %land.lhs.true13
  %entry3.0113.lcssa = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %entry3.0113, %land.lhs.true13 ]
  br label %if.then22

if.then22:                                        ; preds = %if.then22.loopexit15, %if.then22.loopexit
  %entry3.0.lcssa104 = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %entry3.0113.us.lcssa, %if.then22.loopexit ], [ %entry3.0113.lcssa, %if.then22.loopexit15 ]
  %12 = load %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal18most_recently_usedE, align 8, !tbaa !18
  %cmp23 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0.lcssa104, %12
  br i1 %cmp23, label %for.cond52.preheader, label %if.then24

if.then24:                                        ; preds = %if.then22
  %more_recent = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0.lcssa104, i64 0, i32 2
  %13 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent, align 8, !tbaa !33
  %cmp25 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %13, null
  br i1 %cmp25, label %if.then26, label %if.end

if.then26:                                        ; preds = %if.then24
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([27 x i8]* @.str440, i64 0, i64 0)) #5
  br label %if.end

if.end:                                           ; preds = %if.then26, %if.then24
  %less_recent = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0.lcssa104, i64 0, i32 3
  %14 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %less_recent, align 8, !tbaa !34
  %cmp27 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %14, null
  br i1 %cmp27, label %if.else, label %if.then28

if.then28:                                        ; preds = %if.end
  %15 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent, align 8, !tbaa !33
  %more_recent31 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %14, i64 0, i32 2
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %15, %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent31, align 8, !tbaa !33
  br label %if.end36

if.else:                                          ; preds = %if.end
  %16 = load %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal19least_recently_usedE, align 8, !tbaa !18
  %cmp32 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %16, %entry3.0.lcssa104
  br i1 %cmp32, label %if.end34, label %if.then33

if.then33:                                        ; preds = %if.else
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([29 x i8]* @.str541, i64 0, i64 0)) #5
  br label %if.end34

if.end34:                                         ; preds = %if.then33, %if.else
  %17 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent, align 8, !tbaa !33
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %17, %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal19least_recently_usedE, align 8, !tbaa !18
  br label %if.end36

if.end36:                                         ; preds = %if.end34, %if.then28
  %18 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent, align 8, !tbaa !33
  %cmp38 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %18, null
  br i1 %cmp38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %if.end36
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([27 x i8]* @.str440, i64 0, i64 0)) #5
  %.pre = load %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent, align 8, !tbaa !33
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %if.end36
  %19 = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %18, %if.end36 ], [ %.pre, %if.then39 ]
  %20 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %less_recent, align 8, !tbaa !34
  %less_recent43 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %19, i64 0, i32 3
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %20, %"struct.Halide::Runtime::Internal::CacheEntry"** %less_recent43, align 8, !tbaa !34
  store %"struct.Halide::Runtime::Internal::CacheEntry"* null, %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent, align 8, !tbaa !33
  %21 = load %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal18most_recently_usedE, align 8, !tbaa !18
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %21, %"struct.Halide::Runtime::Internal::CacheEntry"** %less_recent, align 8, !tbaa !34
  %22 = load %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal18most_recently_usedE, align 8, !tbaa !18
  %cmp46 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %22, null
  br i1 %cmp46, label %if.end49, label %if.then47

if.then47:                                        ; preds = %if.end40
  %more_recent48 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %22, i64 0, i32 2
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0.lcssa104, %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent48, align 8, !tbaa !33
  br label %if.end49

if.end49:                                         ; preds = %if.then47, %if.end40
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0.lcssa104, %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal18most_recently_usedE, align 8, !tbaa !18
  br label %for.cond52.preheader

for.cond52.preheader:                             ; preds = %if.end49, %if.then22
  br i1 %cmp16108, label %for.body54.lr.ph, label %cleanup

for.body54.lr.ph:                                 ; preds = %for.cond52.preheader
  %23 = add i32 %tuple_count, -1
  br label %for.body54

for.body54:                                       ; preds = %for.body54, %for.body54.lr.ph
  %indvars.iv = phi i64 [ 0, %for.body54.lr.ph ], [ %indvars.iv.next, %for.body54 ]
  %arrayidx57 = getelementptr inbounds %struct.buffer_t** %tuple_buffers, i64 %indvars.iv
  %24 = load %struct.buffer_t** %arrayidx57, align 8, !tbaa !18
  %25 = trunc i64 %indvars.iv to i32
  %call58 = tail call dereferenceable(72) %struct.buffer_t* @_ZN6Halide7Runtime8Internal10CacheEntry6bufferEi(%"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0.lcssa104, i32 %25) #6
  tail call void @_ZN6Halide7Runtime8Internal12copy_from_toEPvRK8buffer_tRS3_(i8* %user_context, %struct.buffer_t* dereferenceable(72) %call58, %struct.buffer_t* dereferenceable(72) %24) #6
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond8 = icmp eq i32 %25, %23
  br i1 %exitcond8, label %cleanup.loopexit, label %for.body54

if.end63:                                         ; preds = %land.lhs.true13, %land.lhs.true10, %land.lhs.true7, %land.lhs.true, %while.body
  %next = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0113, i64 0, i32 1
  %entry3.0 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %next, align 8
  %cmp = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0, null
  br i1 %cmp, label %cleanup.loopexit16, label %while.body

cleanup.loopexit:                                 ; preds = %for.body54
  br label %cleanup

cleanup.loopexit14:                               ; preds = %if.end63.us
  br label %cleanup

cleanup.loopexit16:                               ; preds = %if.end63
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit16, %cleanup.loopexit14, %cleanup.loopexit, %for.cond52.preheader, %entry
  %retval.0 = phi i1 [ false, %for.cond52.preheader ], [ true, %entry ], [ false, %cleanup.loopexit ], [ true, %cleanup.loopexit14 ], [ true, %cleanup.loopexit16 ]
  tail call void @halide_mutex_unlock(%struct.pthread_mutex_t* @_ZN6Halide7Runtime8Internal16memoization_lockE) #5
  ret i1 %retval.0
}

; Function Attrs: nounwind uwtable
define weak void @halide_memoization_cache_store(i8* %user_context, i8* %cache_key, i32 %size, %struct.buffer_t* %computed_bounds, i32 %tuple_count, %struct.buffer_t** %tuple_buffers) #1 {
entry:
  %conv = sext i32 %size to i64
  %call = tail call i32 @_ZN6Halide7Runtime8Internal8djb_hashEPKhm(i8* %cache_key, i64 %conv) #6
  %0 = and i32 %call, 255
  tail call void @halide_mutex_lock(%struct.pthread_mutex_t* @_ZN6Halide7Runtime8Internal16memoization_lockE) #5
  %idxprom = zext i32 %0 to i64
  %arrayidx = getelementptr inbounds [256 x %"struct.Halide::Runtime::Internal::CacheEntry"*]* @_ZN6Halide7Runtime8Internal13cache_entriesE, i64 0, i64 %idxprom
  %entry3.095 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %arrayidx, align 8
  %cmp96 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.095, null
  br i1 %cmp96, label %for.cond25.preheader, label %while.body.lr.ph

while.body.lr.ph:                                 ; preds = %entry
  %cmp1691 = icmp sgt i32 %tuple_count, 0
  br i1 %cmp1691, label %while.body.lr.ph.split.us, label %while.body.preheader

while.body.preheader:                             ; preds = %while.body.lr.ph
  br label %while.body

while.body.lr.ph.split.us:                        ; preds = %while.body.lr.ph
  %1 = sext i32 %tuple_count to i64
  br label %while.body.us

while.body.us:                                    ; preds = %if.end23.us, %while.body.lr.ph.split.us
  %entry3.097.us = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %entry3.095, %while.body.lr.ph.split.us ], [ %entry3.0.us, %if.end23.us ]
  %hash.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097.us, i64 0, i32 6
  %2 = load i32* %hash.us, align 4, !tbaa !27
  %cmp4.us = icmp eq i32 %2, %call
  br i1 %cmp4.us, label %land.lhs.true.us, label %if.end23.us

land.lhs.true.us:                                 ; preds = %while.body.us
  %key_size.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097.us, i64 0, i32 4
  %3 = load i64* %key_size.us, align 8, !tbaa !26
  %cmp6.us = icmp eq i64 %3, %conv
  br i1 %cmp6.us, label %land.lhs.true7.us, label %if.end23.us

land.lhs.true7.us:                                ; preds = %land.lhs.true.us
  %key.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097.us, i64 0, i32 5
  %4 = load i8** %key.us, align 8, !tbaa !29
  %call9.us = tail call zeroext i1 @_ZN6Halide7Runtime8Internal10keys_equalEPKhS3_m(i8* %4, i8* %cache_key, i64 %conv) #6
  br i1 %call9.us, label %land.lhs.true10.us, label %if.end23.us

land.lhs.true10.us:                               ; preds = %land.lhs.true7.us
  %computed_bounds11.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097.us, i64 0, i32 8
  %call12.us = tail call zeroext i1 @_ZN6Halide7Runtime8Internal12bounds_equalERK8buffer_tS4_(%struct.buffer_t* dereferenceable(72) %computed_bounds11.us, %struct.buffer_t* dereferenceable(72) %computed_bounds) #6
  br i1 %call12.us, label %land.lhs.true13.us, label %if.end23.us

land.lhs.true13.us:                               ; preds = %land.lhs.true10.us
  %tuple_count14.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097.us, i64 0, i32 7
  %5 = load i32* %tuple_count14.us, align 4, !tbaa !28
  %cmp15.us = icmp eq i32 %5, %tuple_count
  br i1 %cmp15.us, label %for.body.us.preheader, label %if.end23.us

for.body.us.preheader:                            ; preds = %land.lhs.true13.us
  br label %for.body.us

for.end.us:                                       ; preds = %for.body.us
  %call20.us.lcssa = phi i1 [ %call20.us, %for.body.us ]
  br i1 %call20.us.lcssa, label %cleanup.loopexit, label %if.end23.us

if.end23.us:                                      ; preds = %for.end.us, %land.lhs.true13.us, %land.lhs.true10.us, %land.lhs.true7.us, %land.lhs.true.us, %while.body.us
  %next.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097.us, i64 0, i32 1
  %entry3.0.us = load %"struct.Halide::Runtime::Internal::CacheEntry"** %next.us, align 8
  %cmp.us = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0.us, null
  br i1 %cmp.us, label %for.cond25.preheader.loopexit, label %while.body.us

for.body.us:                                      ; preds = %for.body.us.preheader, %for.body.us
  %indvars.iv100 = phi i64 [ %indvars.iv.next101, %for.body.us ], [ 0, %for.body.us.preheader ]
  %arrayidx18.us = getelementptr inbounds %struct.buffer_t** %tuple_buffers, i64 %indvars.iv100
  %6 = load %struct.buffer_t** %arrayidx18.us, align 8, !tbaa !18
  %7 = trunc i64 %indvars.iv100 to i32
  %call19.us = tail call dereferenceable(72) %struct.buffer_t* @_ZN6Halide7Runtime8Internal10CacheEntry6bufferEi(%"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097.us, i32 %7) #6
  %call20.us = tail call zeroext i1 @_ZN6Halide7Runtime8Internal12bounds_equalERK8buffer_tS4_(%struct.buffer_t* dereferenceable(72) %call19.us, %struct.buffer_t* dereferenceable(72) %6) #6
  %indvars.iv.next101 = add nuw nsw i64 %indvars.iv100, 1
  %cmp16.us = icmp slt i64 %indvars.iv.next101, %1
  %or.cond.us = and i1 %cmp16.us, %call20.us
  br i1 %or.cond.us, label %for.body.us, label %for.end.us

for.cond25.preheader.loopexit:                    ; preds = %if.end23.us
  br label %for.cond25.preheader

for.cond25.preheader.loopexit8:                   ; preds = %if.end23
  br label %for.cond25.preheader

for.cond25.preheader:                             ; preds = %for.cond25.preheader.loopexit8, %for.cond25.preheader.loopexit, %entry
  %cmp2688 = icmp sgt i32 %tuple_count, 0
  %8 = add i32 %tuple_count, -1
  br i1 %cmp2688, label %for.body27.preheader, label %for.end34

for.body27.preheader:                             ; preds = %for.cond25.preheader
  br label %for.body27

while.body:                                       ; preds = %while.body.preheader, %if.end23
  %entry3.097 = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %entry3.0, %if.end23 ], [ %entry3.095, %while.body.preheader ]
  %hash = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097, i64 0, i32 6
  %9 = load i32* %hash, align 4, !tbaa !27
  %cmp4 = icmp eq i32 %9, %call
  br i1 %cmp4, label %land.lhs.true, label %if.end23

land.lhs.true:                                    ; preds = %while.body
  %key_size = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097, i64 0, i32 4
  %10 = load i64* %key_size, align 8, !tbaa !26
  %cmp6 = icmp eq i64 %10, %conv
  br i1 %cmp6, label %land.lhs.true7, label %if.end23

land.lhs.true7:                                   ; preds = %land.lhs.true
  %key = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097, i64 0, i32 5
  %11 = load i8** %key, align 8, !tbaa !29
  %call9 = tail call zeroext i1 @_ZN6Halide7Runtime8Internal10keys_equalEPKhS3_m(i8* %11, i8* %cache_key, i64 %conv) #6
  br i1 %call9, label %land.lhs.true10, label %if.end23

land.lhs.true10:                                  ; preds = %land.lhs.true7
  %computed_bounds11 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097, i64 0, i32 8
  %call12 = tail call zeroext i1 @_ZN6Halide7Runtime8Internal12bounds_equalERK8buffer_tS4_(%struct.buffer_t* dereferenceable(72) %computed_bounds11, %struct.buffer_t* dereferenceable(72) %computed_bounds) #6
  br i1 %call12, label %land.lhs.true13, label %if.end23

land.lhs.true13:                                  ; preds = %land.lhs.true10
  %tuple_count14 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097, i64 0, i32 7
  %12 = load i32* %tuple_count14, align 4, !tbaa !28
  %cmp15 = icmp eq i32 %12, %tuple_count
  br i1 %cmp15, label %cleanup.loopexit7, label %if.end23

if.end23:                                         ; preds = %land.lhs.true13, %land.lhs.true10, %land.lhs.true7, %land.lhs.true, %while.body
  %next = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.097, i64 0, i32 1
  %entry3.0 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %next, align 8
  %cmp = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %entry3.0, null
  br i1 %cmp, label %for.cond25.preheader.loopexit8, label %while.body

for.body27:                                       ; preds = %for.body27.preheader, %for.body27
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.body27 ], [ 0, %for.body27.preheader ]
  %added_size.089 = phi i64 [ %add, %for.body27 ], [ 0, %for.body27.preheader ]
  %arrayidx30 = getelementptr inbounds %struct.buffer_t** %tuple_buffers, i64 %indvars.iv
  %13 = load %struct.buffer_t** %arrayidx30, align 8, !tbaa !18
  %call31 = tail call i64 @_ZN6Halide7Runtime8Internal11full_extentERK8buffer_t(%struct.buffer_t* dereferenceable(72) %13) #6
  %add = add i64 %call31, %added_size.089
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv3 = trunc i64 %indvars.iv to i32
  %exitcond4 = icmp eq i32 %lftr.wideiv3, %8
  br i1 %exitcond4, label %for.end34.loopexit, label %for.body27

for.end34.loopexit:                               ; preds = %for.body27
  %add.lcssa = phi i64 [ %add, %for.body27 ]
  br label %for.end34

for.end34:                                        ; preds = %for.end34.loopexit, %for.cond25.preheader
  %added_size.0.lcssa = phi i64 [ 0, %for.cond25.preheader ], [ %add.lcssa, %for.end34.loopexit ]
  %14 = load i64* @_ZN6Halide7Runtime8Internal18current_cache_sizeE, align 8, !tbaa !17
  %add35 = add i64 %14, %added_size.0.lcssa
  store i64 %add35, i64* @_ZN6Halide7Runtime8Internal18current_cache_sizeE, align 8, !tbaa !17
  tail call void @_ZN6Halide7Runtime8Internal11prune_cacheEv() #6
  %conv36 = sext i32 %8 to i64
  %mul = mul nsw i64 %conv36, 72
  %add37 = add i64 %mul, 200
  %call38 = tail call i8* @halide_malloc(i8* %user_context, i64 %add37) #5
  %15 = bitcast i8* %call38 to %"struct.Halide::Runtime::Internal::CacheEntry"*
  tail call void @_ZN6Halide7Runtime8Internal10CacheEntry4initEPvPKhmjRK8buffer_tiPPS6_(%"struct.Halide::Runtime::Internal::CacheEntry"* %15, i8* %user_context, i8* %cache_key, i64 %conv, i32 %call, %struct.buffer_t* dereferenceable(72) %computed_bounds, i32 %tuple_count, %struct.buffer_t** %tuple_buffers) #6
  %16 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %arrayidx, align 8, !tbaa !18
  %next42 = getelementptr inbounds i8* %call38, i64 8
  %17 = bitcast i8* %next42 to %"struct.Halide::Runtime::Internal::CacheEntry"**
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %16, %"struct.Halide::Runtime::Internal::CacheEntry"** %17, align 8, !tbaa !32
  %18 = load %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal18most_recently_usedE, align 8, !tbaa !18
  %less_recent = getelementptr inbounds i8* %call38, i64 24
  %19 = bitcast i8* %less_recent to %"struct.Halide::Runtime::Internal::CacheEntry"**
  store %"struct.Halide::Runtime::Internal::CacheEntry"* %18, %"struct.Halide::Runtime::Internal::CacheEntry"** %19, align 8, !tbaa !34
  %cmp43 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %18, null
  br i1 %cmp43, label %if.end45, label %if.then44

if.then44:                                        ; preds = %for.end34
  %more_recent = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %18, i64 0, i32 2
  %20 = bitcast %"struct.Halide::Runtime::Internal::CacheEntry"** %more_recent to i8**
  store i8* %call38, i8** %20, align 8, !tbaa !33
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %for.end34
  store i8* %call38, i8** bitcast (%"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal18most_recently_usedE to i8**), align 8, !tbaa !18
  %21 = load %"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal19least_recently_usedE, align 8, !tbaa !18
  %cmp46 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %21, null
  br i1 %cmp46, label %if.then47, label %if.end48

if.then47:                                        ; preds = %if.end45
  store i8* %call38, i8** bitcast (%"struct.Halide::Runtime::Internal::CacheEntry"** @_ZN6Halide7Runtime8Internal19least_recently_usedE to i8**), align 8, !tbaa !18
  br label %if.end48

if.end48:                                         ; preds = %if.then47, %if.end45
  %22 = bitcast %"struct.Halide::Runtime::Internal::CacheEntry"** %arrayidx to i8**
  store i8* %call38, i8** %22, align 8, !tbaa !18
  br label %cleanup

cleanup.loopexit:                                 ; preds = %for.end.us
  br label %cleanup

cleanup.loopexit7:                                ; preds = %land.lhs.true13
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit7, %cleanup.loopexit, %if.end48
  tail call void @halide_mutex_unlock(%struct.pthread_mutex_t* @_ZN6Halide7Runtime8Internal16memoization_lockE) #5
  ret void
}

; Function Attrs: nounwind uwtable
define weak void @halide_memoization_cache_cleanup() #1 {
entry:
  br label %for.body

for.body:                                         ; preds = %for.inc, %entry
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.inc ]
  %arrayidx = getelementptr inbounds [256 x %"struct.Halide::Runtime::Internal::CacheEntry"*]* @_ZN6Halide7Runtime8Internal13cache_entriesE, i64 0, i64 %indvars.iv
  %0 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %arrayidx, align 8, !tbaa !18
  store %"struct.Halide::Runtime::Internal::CacheEntry"* null, %"struct.Halide::Runtime::Internal::CacheEntry"** %arrayidx, align 8, !tbaa !18
  %cmp412 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %0, null
  br i1 %cmp412, label %for.inc, label %while.body.preheader

while.body.preheader:                             ; preds = %for.body
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %while.body
  %entry1.013 = phi %"struct.Halide::Runtime::Internal::CacheEntry"* [ %1, %while.body ], [ %0, %while.body.preheader ]
  %next5 = getelementptr inbounds %"struct.Halide::Runtime::Internal::CacheEntry"* %entry1.013, i64 0, i32 1
  %1 = load %"struct.Halide::Runtime::Internal::CacheEntry"** %next5, align 8, !tbaa !32
  tail call void @_ZN6Halide7Runtime8Internal10CacheEntry7destroyEv(%"struct.Halide::Runtime::Internal::CacheEntry"* %entry1.013) #6
  %2 = bitcast %"struct.Halide::Runtime::Internal::CacheEntry"* %entry1.013 to i8*
  tail call void @halide_free(i8* null, i8* %2) #5
  %cmp4 = icmp eq %"struct.Halide::Runtime::Internal::CacheEntry"* %1, null
  br i1 %cmp4, label %for.inc.loopexit, label %while.body

for.inc.loopexit:                                 ; preds = %while.body
  br label %for.inc

for.inc:                                          ; preds = %for.inc.loopexit, %for.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp eq i64 %indvars.iv.next, 256
  br i1 %exitcond, label %for.end, label %for.body

for.end:                                          ; preds = %for.inc
  store i64 0, i64* @_ZN6Halide7Runtime8Internal18current_cache_sizeE, align 8, !tbaa !17
  tail call void @halide_mutex_cleanup(%struct.pthread_mutex_t* @_ZN6Halide7Runtime8Internal16memoization_lockE) #5
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce i8* @halide_string_to_string(i8* %dst, i8* %end, i8* %arg) #1 {
entry:
  %cmp = icmp ult i8* %dst, %end
  br i1 %cmp, label %while.body.preheader, label %return

while.body.preheader:                             ; preds = %entry
  %cmp118 = icmp eq i8* %dst, %end
  br i1 %cmp118, label %if.then2, label %if.end3.preheader

if.end3.preheader:                                ; preds = %while.body.preheader
  br label %if.end3

if.then2.loopexit:                                ; preds = %if.end6
  br label %if.then2

if.then2:                                         ; preds = %if.then2.loopexit, %while.body.preheader
  %dst.addr.0.lcssa = phi i8* [ %dst, %while.body.preheader ], [ %end, %if.then2.loopexit ]
  %arrayidx = getelementptr inbounds i8* %dst.addr.0.lcssa, i64 -1
  store i8 0, i8* %arrayidx, align 1, !tbaa !19
  br label %return

if.end3:                                          ; preds = %if.end3.preheader, %if.end6
  %arg.addr.020 = phi i8* [ %incdec.ptr7, %if.end6 ], [ %arg, %if.end3.preheader ]
  %dst.addr.019 = phi i8* [ %incdec.ptr, %if.end6 ], [ %dst, %if.end3.preheader ]
  %0 = load i8* %arg.addr.020, align 1, !tbaa !19
  store i8 %0, i8* %dst.addr.019, align 1, !tbaa !19
  %cmp4 = icmp eq i8 %0, 0
  br i1 %cmp4, label %return.loopexit, label %if.end6

if.end6:                                          ; preds = %if.end3
  %incdec.ptr = getelementptr inbounds i8* %dst.addr.019, i64 1
  %incdec.ptr7 = getelementptr inbounds i8* %arg.addr.020, i64 1
  %cmp1 = icmp eq i8* %incdec.ptr, %end
  br i1 %cmp1, label %if.then2.loopexit, label %if.end3

return.loopexit:                                  ; preds = %if.end3
  %dst.addr.019.lcssa = phi i8* [ %dst.addr.019, %if.end3 ]
  br label %return

return:                                           ; preds = %return.loopexit, %if.then2, %entry
  %retval.0 = phi i8* [ %dst.addr.0.lcssa, %if.then2 ], [ %dst, %entry ], [ %dst.addr.019.lcssa, %return.loopexit ]
  ret i8* %retval.0
}

; Function Attrs: nounwind uwtable
define linkonce i8* @halide_uint64_to_string(i8* %dst, i8* %end, i64 %arg, i32 %min_digits) #1 {
entry:
  %buf = alloca [32 x i8], align 16
  %arrayidx = getelementptr inbounds [32 x i8]* %buf, i64 0, i64 31
  store i8 0, i8* %arrayidx, align 1, !tbaa !19
  %add.ptr = getelementptr inbounds [32 x i8]* %buf, i64 0, i64 30
  %cmp10 = icmp sgt i32 %min_digits, 0
  %tobool11 = icmp ne i64 %arg, 0
  %or.cond12 = or i1 %tobool11, %cmp10
  br i1 %or.cond12, label %for.body.preheader, label %for.end

for.body.preheader:                               ; preds = %entry
  br label %for.body

for.body:                                         ; preds = %for.body.preheader, %for.body
  %arg.addr.015 = phi i64 [ %div, %for.body ], [ %arg, %for.body.preheader ]
  %digits.014 = phi i8* [ %incdec.ptr, %for.body ], [ %add.ptr, %for.body.preheader ]
  %i.013 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %div = udiv i64 %arg.addr.015, 10
  %sub9 = add i64 %arg.addr.015, 48
  %0 = mul i64 %div, -10
  %add1 = add i64 %sub9, %0
  %conv = trunc i64 %add1 to i8
  store i8 %conv, i8* %digits.014, align 1, !tbaa !19
  %incdec.ptr = getelementptr inbounds i8* %digits.014, i64 -1
  %inc = add nuw nsw i32 %i.013, 1
  %cmp = icmp slt i32 %inc, %min_digits
  %1 = icmp ugt i64 %arg.addr.015, 9
  %or.cond = or i1 %1, %cmp
  br i1 %or.cond, label %for.body, label %for.end.loopexit

for.end.loopexit:                                 ; preds = %for.body
  %incdec.ptr.lcssa = phi i8* [ %incdec.ptr, %for.body ]
  br label %for.end

for.end:                                          ; preds = %for.end.loopexit, %entry
  %digits.0.lcssa = phi i8* [ %add.ptr, %entry ], [ %incdec.ptr.lcssa, %for.end.loopexit ]
  %incdec.ptr1 = getelementptr inbounds i8* %digits.0.lcssa, i64 1
  %call = call i8* @halide_string_to_string(i8* %dst, i8* %end, i8* %incdec.ptr1) #6
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define linkonce i8* @halide_int64_to_string(i8* %dst, i8* %end, i64 %arg, i32 %min_digits) #1 {
entry:
  %cmp = icmp sgt i64 %arg, -1
  %cmp1 = icmp ugt i8* %dst, %end
  %or.cond = or i1 %cmp1, %cmp
  br i1 %or.cond, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %incdec.ptr = getelementptr inbounds i8* %dst, i64 1
  store i8 45, i8* %dst, align 1, !tbaa !19
  %sub = sub nsw i64 0, %arg
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %arg.addr.0 = phi i64 [ %sub, %if.then ], [ %arg, %entry ]
  %dst.addr.0 = phi i8* [ %incdec.ptr, %if.then ], [ %dst, %entry ]
  %call = tail call i8* @halide_uint64_to_string(i8* %dst.addr.0, i8* %end, i64 %arg.addr.0, i32 %min_digits) #6
  ret i8* %call
}

; Function Attrs: nounwind uwtable
define linkonce i8* @halide_pointer_to_string(i8* %dst, i8* %end, i8* %arg) #1 {
entry:
  %buf = alloca [20 x i8], align 16
  %0 = getelementptr inbounds [20 x i8]* %buf, i64 0, i64 0
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 20, i32 16, i1 false)
  %add.ptr = getelementptr inbounds [20 x i8]* %buf, i64 0, i64 18
  %1 = ptrtoint i8* %arg to i64
  br label %for.body

for.body:                                         ; preds = %for.body, %entry
  %i.010 = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %bits.09 = phi i64 [ %1, %entry ], [ %shr, %for.body ]
  %buf_ptr.08 = phi i8* [ %add.ptr, %entry ], [ %incdec.ptr, %for.body ]
  %and = and i64 %bits.09, 15
  %arrayidx = getelementptr inbounds [17 x i8]* @.str1264, i64 0, i64 %and
  %2 = load i8* %arrayidx, align 1, !tbaa !19
  %incdec.ptr = getelementptr inbounds i8* %buf_ptr.08, i64 -1
  store i8 %2, i8* %buf_ptr.08, align 1, !tbaa !19
  %shr = lshr i64 %bits.09, 4
  %tobool = icmp ne i64 %shr, 0
  %inc = add nuw nsw i32 %i.010, 1
  %cmp = icmp slt i32 %inc, 16
  %or.cond = and i1 %cmp, %tobool
  br i1 %or.cond, label %for.body, label %for.end

for.end:                                          ; preds = %for.body
  %incdec.ptr.lcssa = phi i8* [ %incdec.ptr, %for.body ]
  %buf_ptr.08.lcssa = phi i8* [ %buf_ptr.08, %for.body ]
  %incdec.ptr1 = getelementptr inbounds i8* %buf_ptr.08.lcssa, i64 -2
  store i8 120, i8* %incdec.ptr.lcssa, align 1, !tbaa !19
  store i8 48, i8* %incdec.ptr1, align 1, !tbaa !19
  %call = call i8* @halide_string_to_string(i8* %dst, i8* %end, i8* %incdec.ptr1) #6
  ret i8* %call
}

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #3

; Function Attrs: nounwind uwtable
define linkonce i64 @_ZN6Halide7Runtime8Internal8buf_sizeEPvP8buffer_t(i8* %user_context, %struct.buffer_t* %buf) #1 {
entry:
  %elem_size = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 5
  %0 = load i32* %elem_size, align 4, !tbaa !20
  %conv = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 2, i64 0
  %1 = load i32* %arrayidx, align 4, !tbaa !15
  %mul = mul nsw i32 %1, %0
  %arrayidx2 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 0
  %2 = load i32* %arrayidx2, align 4, !tbaa !15
  %mul3 = mul nsw i32 %mul, %2
  %conv4 = sext i32 %mul3 to i64
  %cmp5 = icmp ugt i64 %conv4, %conv
  %conv4.size.0 = select i1 %cmp5, i64 %conv4, i64 %conv
  %arrayidx.1 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 2, i64 1
  %3 = load i32* %arrayidx.1, align 4, !tbaa !15
  %mul.1 = mul nsw i32 %3, %0
  %arrayidx2.1 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 1
  %4 = load i32* %arrayidx2.1, align 4, !tbaa !15
  %mul3.1 = mul nsw i32 %mul.1, %4
  %conv4.1 = sext i32 %mul3.1 to i64
  %cmp5.1 = icmp ugt i64 %conv4.1, %conv4.size.0
  %conv4.size.0.1 = select i1 %cmp5.1, i64 %conv4.1, i64 %conv4.size.0
  %arrayidx.2 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 2, i64 2
  %5 = load i32* %arrayidx.2, align 4, !tbaa !15
  %mul.2 = mul nsw i32 %5, %0
  %arrayidx2.2 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 2
  %6 = load i32* %arrayidx2.2, align 4, !tbaa !15
  %mul3.2 = mul nsw i32 %mul.2, %6
  %conv4.2 = sext i32 %mul3.2 to i64
  %cmp5.2 = icmp ugt i64 %conv4.2, %conv4.size.0.1
  %conv4.size.0.2 = select i1 %cmp5.2, i64 %conv4.2, i64 %conv4.size.0.1
  %arrayidx.3 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 2, i64 3
  %7 = load i32* %arrayidx.3, align 4, !tbaa !15
  %mul.3 = mul nsw i32 %7, %0
  %arrayidx2.3 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 3
  %8 = load i32* %arrayidx2.3, align 4, !tbaa !15
  %mul3.3 = mul nsw i32 %mul.3, %8
  %conv4.3 = sext i32 %mul3.3 to i64
  %cmp5.3 = icmp ugt i64 %conv4.3, %conv4.size.0.2
  %conv4.size.0.3 = select i1 %cmp5.3, i64 %conv4.3, i64 %conv4.size.0.2
  %tobool = icmp eq i64 %conv4.size.0.3, 0
  br i1 %tobool, label %if.then6, label %if.end7

if.then6:                                         ; preds = %entry
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([5 x i8]* @.str67, i64 0, i64 0)) #5
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %entry
  ret i64 %conv4.size.0.3
}

; Function Attrs: nounwind uwtable
define linkonce void @_ZN6Halide7Runtime8Internal21make_host_to_dev_copyEPK8buffer_t(%"struct.Halide::Runtime::Internal::dev_copy"* noalias sret %agg.result, %struct.buffer_t* %buf) #1 {
entry:
  %c = alloca %"struct.Halide::Runtime::Internal::dev_copy", align 8
  %0 = bitcast %"struct.Halide::Runtime::Internal::dev_copy"* %c to i8*
  call void @llvm.lifetime.start(i64 88, i8* %0) #3
  %host = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 1
  %1 = load i8** %host, align 8, !tbaa !22
  %2 = ptrtoint i8* %1 to i64
  %src = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 0
  store i64 %2, i64* %src, align 8, !tbaa !35
  %dev = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 0
  %3 = load i64* %dev, align 8, !tbaa !37
  %dst = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 1
  store i64 %3, i64* %dst, align 8, !tbaa !38
  %elem_size = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 5
  %4 = load i32* %elem_size, align 4, !tbaa !20
  %conv = sext i32 %4 to i64
  %chunk_size = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 4
  store i64 %conv, i64* %chunk_size, align 8, !tbaa !39
  %arrayidx = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 0
  %arrayidx2 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 0
  %arrayidx.1 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 1
  %5 = bitcast i64* %arrayidx to <2 x i64>*
  store <2 x i64> <i64 1, i64 1>, <2 x i64>* %5, align 8, !tbaa !17
  %arrayidx2.1 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 1
  %6 = bitcast i64* %arrayidx2 to <2 x i64>*
  store <2 x i64> zeroinitializer, <2 x i64>* %6, align 8, !tbaa !17
  %arrayidx.2 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 2
  %arrayidx2.2 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 2
  %arrayidx.3 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 3
  %7 = bitcast i64* %arrayidx.2 to <2 x i64>*
  store <2 x i64> <i64 1, i64 1>, <2 x i64>* %7, align 8, !tbaa !17
  %arrayidx2.3 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 3
  %8 = bitcast i64* %arrayidx2.2 to <2 x i64>*
  store <2 x i64> zeroinitializer, <2 x i64>* %8, align 8, !tbaa !17
  %cmp4 = icmp eq i32 %4, 0
  br i1 %cmp4, label %if.then, label %land.rhs.preheader

land.rhs.preheader:                               ; preds = %entry
  br label %land.rhs

if.then:                                          ; preds = %entry
  %9 = bitcast %"struct.Halide::Runtime::Internal::dev_copy"* %agg.result to i8*
  tail call void @llvm.memset.p0i8.i64(i8* %9, i8 0, i64 88, i32 8, i1 false)
  br label %cleanup

land.rhs:                                         ; preds = %land.rhs.preheader, %for.end47
  %indvars.iv19 = phi i64 [ %indvars.iv.next20, %for.end47 ], [ 0, %land.rhs.preheader ]
  %indvars.iv = phi i32 [ %indvars.iv.next, %for.end47 ], [ 0, %land.rhs.preheader ]
  %arrayidx10 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 2, i64 %indvars.iv19
  %10 = load i32* %arrayidx10, align 4, !tbaa !15
  %tobool = icmp eq i32 %10, 0
  br i1 %tobool, label %while.cond.preheader, label %for.body11

while.cond.preheader:                             ; preds = %for.end47, %land.rhs
  %11 = load i64* %chunk_size, align 8, !tbaa !39
  %12 = load i64* %arrayidx2, align 8, !tbaa !17
  %cmp66131 = icmp eq i64 %11, %12
  br i1 %cmp66131, label %while.body.lr.ph, label %while.end

while.body.lr.ph:                                 ; preds = %while.cond.preheader
  %.pre = load i64* %arrayidx, align 8, !tbaa !17
  %.pre152 = load i64* %arrayidx.1, align 8, !tbaa !17
  %.pre153 = load i64* %arrayidx2.1, align 8, !tbaa !17
  %.pre154 = load i64* %arrayidx.2, align 8, !tbaa !17
  %.pre155 = load i64* %arrayidx2.2, align 8, !tbaa !17
  %.pre156 = load i64* %arrayidx.3, align 8, !tbaa !17
  %.pre157 = load i64* %arrayidx2.3, align 8, !tbaa !17
  br label %while.body

for.body11:                                       ; preds = %land.rhs
  %arrayidx14 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 %indvars.iv19
  %13 = load i32* %arrayidx14, align 4, !tbaa !15
  %mul = mul nsw i32 %13, %4
  %cmp17132 = icmp sgt i64 %indvars.iv19, 0
  br i1 %cmp17132, label %for.body18.lr.ph, label %for.cond30.preheader

for.body18.lr.ph:                                 ; preds = %for.body11
  %conv19 = sext i32 %mul to i64
  %cmp24 = icmp eq i32 %mul, 0
  br i1 %cmp24, label %for.cond30.preheader, label %for.body18.us.preheader

for.body18.us.preheader:                          ; preds = %for.body18.lr.ph
  br label %for.body18.us

for.body18.us:                                    ; preds = %for.body18.us.preheader, %for.inc27.us
  %indvars.iv145 = phi i64 [ %indvars.iv.next146, %for.inc27.us ], [ 0, %for.body18.us.preheader ]
  %arrayidx22.us = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 %indvars.iv145
  %14 = load i64* %arrayidx22.us, align 8, !tbaa !17
  %cmp23.us = icmp ult i64 %conv19, %14
  br i1 %cmp23.us, label %for.body18.for.cond30.preheader_crit_edge, label %for.inc27.us

for.inc27.us:                                     ; preds = %for.body18.us
  %indvars.iv.next146 = add nuw nsw i64 %indvars.iv145, 1
  %cmp17.us = icmp slt i64 %indvars.iv.next146, %indvars.iv19
  br i1 %cmp17.us, label %for.body18.us, label %for.cond16.for.cond30.preheader_crit_edge.us-lcssa.us

for.cond16.for.cond30.preheader_crit_edge.us-lcssa.us: ; preds = %for.inc27.us
  %indvars.iv.next146.lcssa = phi i64 [ %indvars.iv.next146, %for.inc27.us ]
  %15 = trunc i64 %indvars.iv.next146.lcssa to i32
  br label %for.cond30.preheader

for.body18.for.cond30.preheader_crit_edge:        ; preds = %for.body18.us
  %indvars.iv145.lcssa = phi i64 [ %indvars.iv145, %for.body18.us ]
  %16 = trunc i64 %indvars.iv145.lcssa to i32
  br label %for.cond30.preheader

for.cond30.preheader:                             ; preds = %for.body18.lr.ph, %for.body18.for.cond30.preheader_crit_edge, %for.cond16.for.cond30.preheader_crit_edge.us-lcssa.us, %for.body11
  %insert.0.lcssa = phi i32 [ %16, %for.body18.for.cond30.preheader_crit_edge ], [ 0, %for.body11 ], [ %15, %for.cond16.for.cond30.preheader_crit_edge.us-lcssa.us ], [ %indvars.iv, %for.body18.lr.ph ]
  %17 = sext i32 %insert.0.lcssa to i64
  %cmp31135 = icmp sgt i64 %indvars.iv19, %17
  br i1 %cmp31135, label %for.body32.preheader, label %for.end47

for.body32.preheader:                             ; preds = %for.cond30.preheader
  %18 = sub i64 %indvars.iv19, %17
  %xtraiter160 = and i64 %18, 1
  %lcmp.mod161 = icmp ne i64 %xtraiter160, 0
  %lcmp.overflow162 = icmp eq i64 %indvars.iv19, %17
  %lcmp.or163 = or i1 %lcmp.overflow162, %lcmp.mod161
  br i1 %lcmp.or163, label %for.body32.prol.preheader, label %for.body32.preheader.split

for.body32.prol.preheader:                        ; preds = %for.body32.preheader
  %19 = and i64 %18, 1
  br label %for.body32.prol

for.body32.prol:                                  ; preds = %for.body32.prol.preheader, %for.body32.prol
  %indvars.iv143.prol = phi i64 [ %indvars.iv.next144.prol, %for.body32.prol ], [ %indvars.iv19, %for.body32.prol.preheader ]
  %prol.iter164 = phi i64 [ %prol.iter164.sub, %for.body32.prol ], [ %xtraiter160, %for.body32.prol.preheader ]
  %indvars.iv.next144.prol = add nsw i64 %indvars.iv143.prol, -1
  %arrayidx35.prol = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 %indvars.iv.next144.prol
  %20 = load i64* %arrayidx35.prol, align 8, !tbaa !17
  %arrayidx38.prol = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 %indvars.iv143.prol
  store i64 %20, i64* %arrayidx38.prol, align 8, !tbaa !17
  %arrayidx42.prol = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 %indvars.iv.next144.prol
  %21 = load i64* %arrayidx42.prol, align 8, !tbaa !17
  %arrayidx45.prol = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 %indvars.iv143.prol
  store i64 %21, i64* %arrayidx45.prol, align 8, !tbaa !17
  %prol.iter164.sub = add i64 %prol.iter164, -1
  %prol.iter164.cmp = icmp eq i64 %prol.iter164.sub, 0
  br i1 %prol.iter164.cmp, label %for.body32.preheader.split.loopexit, label %for.body32.prol, !llvm.loop !40

for.body32.preheader.split.loopexit:              ; preds = %for.body32.prol
  %22 = sub i64 %indvars.iv19, %19
  br label %for.body32.preheader.split

for.body32.preheader.split:                       ; preds = %for.body32.preheader.split.loopexit, %for.body32.preheader
  %indvars.iv143.unr = phi i64 [ %indvars.iv19, %for.body32.preheader ], [ %22, %for.body32.preheader.split.loopexit ]
  %23 = icmp ult i64 %18, 2
  br i1 %23, label %for.end47, label %for.body32.preheader28

for.body32.preheader28:                           ; preds = %for.body32.preheader.split
  br label %for.body32

for.body32:                                       ; preds = %for.body32.preheader28, %for.body32
  %indvars.iv143 = phi i64 [ %indvars.iv.next144.1, %for.body32 ], [ %indvars.iv143.unr, %for.body32.preheader28 ]
  %indvars.iv.next144 = add nsw i64 %indvars.iv143, -1
  %arrayidx35 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 %indvars.iv.next144
  %24 = load i64* %arrayidx35, align 8, !tbaa !17
  %arrayidx38 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 %indvars.iv143
  store i64 %24, i64* %arrayidx38, align 8, !tbaa !17
  %arrayidx42 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 %indvars.iv.next144
  %25 = load i64* %arrayidx42, align 8, !tbaa !17
  %arrayidx45 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 %indvars.iv143
  store i64 %25, i64* %arrayidx45, align 8, !tbaa !17
  %indvars.iv.next144.1 = add nsw i64 %indvars.iv143, -2
  %arrayidx35.1 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 %indvars.iv.next144.1
  %26 = load i64* %arrayidx35.1, align 8, !tbaa !17
  store i64 %26, i64* %arrayidx35, align 8, !tbaa !17
  %arrayidx42.1 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 %indvars.iv.next144.1
  %27 = load i64* %arrayidx42.1, align 8, !tbaa !17
  store i64 %27, i64* %arrayidx42, align 8, !tbaa !17
  %cmp31.1 = icmp sgt i64 %indvars.iv.next144.1, %17
  br i1 %cmp31.1, label %for.body32, label %for.end47.loopexit

for.end47.loopexit:                               ; preds = %for.body32
  br label %for.end47

for.end47:                                        ; preds = %for.end47.loopexit, %for.body32.preheader.split, %for.cond30.preheader
  %cmp48 = icmp eq i32 %mul, 0
  %28 = sext i32 %10 to i64
  %conv52 = select i1 %cmp48, i64 1, i64 %28
  %arrayidx55 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 %17
  store i64 %conv52, i64* %arrayidx55, align 8, !tbaa !17
  %conv56 = sext i32 %mul to i64
  %arrayidx59 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 %17
  store i64 %conv56, i64* %arrayidx59, align 8, !tbaa !17
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  %cmp7 = icmp slt i64 %indvars.iv.next20, 4
  %indvars.iv.next = add i32 %indvars.iv, 1
  br i1 %cmp7, label %land.rhs, label %while.cond.preheader

while.body:                                       ; preds = %while.body, %while.body.lr.ph
  %29 = phi i64 [ %.pre157, %while.body.lr.ph ], [ 0, %while.body ]
  %30 = phi i64 [ %.pre156, %while.body.lr.ph ], [ 1, %while.body ]
  %31 = phi i64 [ %.pre155, %while.body.lr.ph ], [ %29, %while.body ]
  %32 = phi i64 [ %.pre154, %while.body.lr.ph ], [ %30, %while.body ]
  %33 = phi i64 [ %.pre153, %while.body.lr.ph ], [ %31, %while.body ]
  %34 = phi i64 [ %.pre152, %while.body.lr.ph ], [ %32, %while.body ]
  %35 = phi i64 [ %.pre, %while.body.lr.ph ], [ %34, %while.body ]
  %36 = phi i64 [ %11, %while.body.lr.ph ], [ %33, %while.body ]
  %mul70 = mul i64 %36, %35
  %cmp66 = icmp eq i64 %mul70, %33
  br i1 %cmp66, label %while.body, label %while.end.loopexit

while.end.loopexit:                               ; preds = %while.body
  %mul70.lcssa = phi i64 [ %mul70, %while.body ]
  %.lcssa33 = phi i64 [ %34, %while.body ]
  %.lcssa32 = phi i64 [ %33, %while.body ]
  %.lcssa31 = phi i64 [ %32, %while.body ]
  %.lcssa30 = phi i64 [ %31, %while.body ]
  %.lcssa29 = phi i64 [ %30, %while.body ]
  %.lcssa = phi i64 [ %29, %while.body ]
  store i64 %mul70.lcssa, i64* %chunk_size, align 8, !tbaa !39
  store i64 %.lcssa33, i64* %arrayidx, align 8, !tbaa !17
  store i64 %.lcssa32, i64* %arrayidx2, align 8, !tbaa !17
  store i64 %.lcssa31, i64* %arrayidx.1, align 8, !tbaa !17
  store i64 %.lcssa30, i64* %arrayidx2.1, align 8, !tbaa !17
  store i64 %.lcssa29, i64* %arrayidx.2, align 8, !tbaa !17
  store i64 %.lcssa, i64* %arrayidx2.2, align 8, !tbaa !17
  store i64 1, i64* %arrayidx.3, align 8, !tbaa !17
  store i64 0, i64* %arrayidx2.3, align 8, !tbaa !17
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %while.cond.preheader
  %37 = bitcast %"struct.Halide::Runtime::Internal::dev_copy"* %agg.result to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %37, i8* %0, i64 88, i32 8, i1 false), !tbaa.struct !41
  br label %cleanup

cleanup:                                          ; preds = %while.end, %if.then
  call void @llvm.lifetime.end(i64 88, i8* %0) #3
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce void @_ZN6Halide7Runtime8Internal21make_dev_to_host_copyEPK8buffer_t(%"struct.Halide::Runtime::Internal::dev_copy"* noalias sret %agg.result, %struct.buffer_t* %buf) #1 {
entry:
  tail call void @_ZN6Halide7Runtime8Internal21make_host_to_dev_copyEPK8buffer_t(%"struct.Halide::Runtime::Internal::dev_copy"* sret %agg.result, %struct.buffer_t* %buf) #6
  %src = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %agg.result, i64 0, i32 0
  %0 = load i64* %src, align 8, !tbaa !35
  %dst = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %agg.result, i64 0, i32 1
  %1 = load i64* %dst, align 8, !tbaa !38
  store i64 %1, i64* %src, align 8, !tbaa !35
  store i64 %0, i64* %dst, align 8, !tbaa !38
  ret void
}

; Function Attrs: nounwind uwtable
define weak void @halide_set_cl_context(%struct._cl_context** %ctx_ptr, %struct._cl_command_queue** %q_ptr, i32* %lock_ptr) #1 {
entry:
  store %struct._cl_context** %ctx_ptr, %struct._cl_context*** @_ZN6Halide7Runtime8Internal10cl_ctx_ptrE, align 8, !tbaa !18
  store %struct._cl_command_queue** %q_ptr, %struct._cl_command_queue*** @_ZN6Halide7Runtime8Internal8cl_q_ptrE, align 8, !tbaa !18
  store i32* %lock_ptr, i32** @_ZN6Halide7Runtime8Internal11cl_lock_ptrE, align 8, !tbaa !18
  ret void
}

; Function Attrs: nounwind uwtable
define linkonce i32 @halide_acquire_cl_context(i8* %user_context, %struct._cl_context** %ctx, %struct._cl_command_queue** %q) #1 {
entry:
  %cmp = icmp eq %struct._cl_context** %ctx, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([12 x i8]* @.str168, i64 0, i64 0)) #5
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %cmp1 = icmp eq %struct._cl_command_queue** %q, null
  br i1 %cmp1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([10 x i8]* @.str269, i64 0, i64 0)) #5
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %0 = load %struct._cl_context*** @_ZN6Halide7Runtime8Internal10cl_ctx_ptrE, align 8, !tbaa !18
  %cmp4 = icmp eq %struct._cl_context** %0, null
  br i1 %cmp4, label %if.end6.thread, label %if.end6

if.end6.thread:                                   ; preds = %if.end3
  store %struct._cl_context** @_ZN6Halide7Runtime8Internal11weak_cl_ctxE, %struct._cl_context*** @_ZN6Halide7Runtime8Internal10cl_ctx_ptrE, align 8, !tbaa !18
  store %struct._cl_command_queue** @_ZN6Halide7Runtime8Internal9weak_cl_qE, %struct._cl_command_queue*** @_ZN6Halide7Runtime8Internal8cl_q_ptrE, align 8, !tbaa !18
  store i32* @_ZN6Halide7Runtime8Internal12weak_cl_lockE, i32** @_ZN6Halide7Runtime8Internal11cl_lock_ptrE, align 8, !tbaa !18
  br label %while.cond.preheader

if.end6:                                          ; preds = %if.end3
  %.pr = load i32** @_ZN6Halide7Runtime8Internal11cl_lock_ptrE, align 8, !tbaa !18
  %cmp7 = icmp eq i32* %.pr, null
  br i1 %cmp7, label %if.then8, label %while.cond.preheader

if.then8:                                         ; preds = %if.end6
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([20 x i8]* @.str370, i64 0, i64 0)) #5
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then8, %if.end6, %if.end6.thread
  br label %while.cond

while.cond:                                       ; preds = %while.cond.preheader, %while.cond
  %1 = load i32** @_ZN6Halide7Runtime8Internal11cl_lock_ptrE, align 8, !tbaa !18
  %2 = atomicrmw xchg i32* %1, i32 1 seq_cst
  %tobool = icmp eq i32 %2, 0
  br i1 %tobool, label %while.end, label %while.cond

while.end:                                        ; preds = %while.cond
  %3 = load %struct._cl_context*** @_ZN6Halide7Runtime8Internal10cl_ctx_ptrE, align 8, !tbaa !18
  %cmp10 = icmp eq %struct._cl_context** %3, null
  br i1 %cmp10, label %if.then11, label %if.end12

if.then11:                                        ; preds = %while.end
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([19 x i8]* @.str471, i64 0, i64 0)) #5
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %while.end
  %4 = load %struct._cl_command_queue*** @_ZN6Halide7Runtime8Internal8cl_q_ptrE, align 8, !tbaa !18
  %cmp13 = icmp eq %struct._cl_command_queue** %4, null
  br i1 %cmp13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end12
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([17 x i8]* @.str572, i64 0, i64 0)) #5
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %if.end12
  %5 = load %struct._cl_context*** @_ZN6Halide7Runtime8Internal10cl_ctx_ptrE, align 8, !tbaa !18
  %6 = load %struct._cl_context** %5, align 8, !tbaa !18
  %tobool16 = icmp eq %struct._cl_context* %6, null
  br i1 %tobool16, label %if.then17, label %if.end21

if.then17:                                        ; preds = %if.end15
  %7 = load %struct._cl_command_queue*** @_ZN6Halide7Runtime8Internal8cl_q_ptrE, align 8, !tbaa !18
  %call = tail call i32 @_ZN6Halide7Runtime8Internal21create_opencl_contextEPvPP11_cl_contextPP17_cl_command_queue(i8* %user_context, %struct._cl_context** %5, %struct._cl_command_queue** %7) #6
  %cmp18 = icmp eq i32 %call, 0
  br i1 %cmp18, label %if.then17.if.end21_crit_edge, label %if.then19

if.then17.if.end21_crit_edge:                     ; preds = %if.then17
  %.pre = load %struct._cl_context*** @_ZN6Halide7Runtime8Internal10cl_ctx_ptrE, align 8, !tbaa !18
  %.pre31 = load %struct._cl_context** %.pre, align 8, !tbaa !18
  br label %if.end21

if.then19:                                        ; preds = %if.then17
  %8 = load i32** @_ZN6Halide7Runtime8Internal11cl_lock_ptrE, align 8, !tbaa !18
  store atomic i32 0, i32* %8 release, align 4
  br label %return

if.end21:                                         ; preds = %if.then17.if.end21_crit_edge, %if.end15
  %9 = phi %struct._cl_context* [ %.pre31, %if.then17.if.end21_crit_edge ], [ %6, %if.end15 ]
  store %struct._cl_context* %9, %struct._cl_context** %ctx, align 8, !tbaa !18
  %10 = load %struct._cl_command_queue*** @_ZN6Halide7Runtime8Internal8cl_q_ptrE, align 8, !tbaa !18
  %11 = load %struct._cl_command_queue** %10, align 8, !tbaa !18
  store %struct._cl_command_queue* %11, %struct._cl_command_queue** %q, align 8, !tbaa !18
  br label %return

return:                                           ; preds = %if.end21, %if.then19
  %retval.0 = phi i32 [ 0, %if.end21 ], [ %call, %if.then19 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define linkonce i32 @_ZN6Halide7Runtime8Internal21create_opencl_contextEPvPP11_cl_contextPP17_cl_command_queue(i8* %user_context, %struct._cl_context** %ctx, %struct._cl_command_queue** %q) #1 {
entry:
  %err = alloca i32, align 4
  %platforms = alloca [4 x %struct._cl_platform_id*], align 16
  %platform_count = alloca i32, align 4
  %temp.lvalue = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %platform_name = alloca [256 x i8], align 16
  %temp.lvalue39 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %devices = alloca [4 x %struct._cl_device_id*], align 16
  %deviceCount = alloca i32, align 4
  %temp.lvalue67 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %temp.lvalue79 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %dev = alloca %struct._cl_device_id*, align 8
  %properties = alloca [3 x i64], align 16
  %temp.lvalue95 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %temp.lvalue113 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %cmp = icmp eq %struct._cl_context** %ctx, null
  br i1 %cmp, label %if.then, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %0 = load %struct._cl_context** %ctx, align 8, !tbaa !18
  %cmp5 = icmp eq %struct._cl_context* %0, null
  br i1 %cmp5, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([28 x i8]* @.str1573, i64 0, i64 0)) #5
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true
  %cmp6 = icmp eq %struct._cl_command_queue** %q, null
  br i1 %cmp6, label %if.then9, label %land.lhs.true7

land.lhs.true7:                                   ; preds = %if.end
  %1 = load %struct._cl_command_queue** %q, align 8, !tbaa !18
  %cmp8 = icmp eq %struct._cl_command_queue* %1, null
  br i1 %cmp8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %land.lhs.true7, %if.end
  tail call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([24 x i8]* @.str1674, i64 0, i64 0)) #5
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %land.lhs.true7
  store i32 0, i32* %platform_count, align 4, !tbaa !15
  %arraydecay = getelementptr inbounds [4 x %struct._cl_platform_id*]* %platforms, i64 0, i64 0
  %call = call i32 @clGetPlatformIDs(i32 4, %struct._cl_platform_id** %arraydecay, i32* %platform_count) #5
  store i32 %call, i32* %err, align 4, !tbaa !15
  %cmp11 = icmp eq i32 %call, 0
  br i1 %cmp11, label %if.end16, label %if.then12

if.then12:                                        ; preds = %if.end10
  %dst.i165 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 1
  %arraydecay.i166 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 0
  store i8* %arraydecay.i166, i8** %dst.i165, align 8, !tbaa !42
  %end.i167 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 2
  %add.ptr.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i, i8** %end.i167, align 8, !tbaa !44
  %user_context.i168 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i168, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i, align 1, !tbaa !19
  %call.i176 = call i8* @halide_string_to_string(i8* %arraydecay.i166, i8* %add.ptr.i, i8* getelementptr inbounds ([30 x i8]* @.str1775, i64 0, i64 0)) #5
  store i8* %call.i176, i8** %dst.i165, align 8, !tbaa !42
  %2 = load i32* %err, align 4, !tbaa !15
  %call14 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %2) #6
  %3 = load i8** %dst.i165, align 8, !tbaa !42
  %4 = load i8** %end.i167, align 8, !tbaa !44
  %call.i179 = call i8* @halide_string_to_string(i8* %3, i8* %4, i8* %call14) #5
  store i8* %call.i179, i8** %dst.i165, align 8, !tbaa !42
  %5 = load i8** %user_context.i168, align 8, !tbaa !45
  call void @halide_error(i8* %5, i8* %arraydecay.i166) #5
  %6 = load i32* %err, align 4, !tbaa !15
  br label %return

if.end16:                                         ; preds = %if.end10
  %call17 = call i8* @halide_get_ocl_platform_name(i8* %user_context) #5
  %cmp18 = icmp eq i8* %call17, null
  %7 = load i32* %platform_count, align 4, !tbaa !15
  %cmp32 = icmp eq i32 %7, 0
  br i1 %cmp18, label %if.else, label %for.cond.preheader

for.cond.preheader:                               ; preds = %if.end16
  br i1 %cmp32, label %if.then38, label %for.body.lr.ph

for.body.lr.ph:                                   ; preds = %for.cond.preheader
  %8 = getelementptr inbounds [256 x i8]* %platform_name, i64 0, i64 0
  br label %for.body

for.body:                                         ; preds = %for.inc, %for.body.lr.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc ], [ 0, %for.body.lr.ph ]
  call void @llvm.lifetime.start(i64 256, i8* %8) #3
  %arrayidx = getelementptr inbounds [4 x %struct._cl_platform_id*]* %platforms, i64 0, i64 %indvars.iv
  %9 = load %struct._cl_platform_id** %arrayidx, align 8, !tbaa !18
  %call22 = call i32 @clGetPlatformInfo(%struct._cl_platform_id* %9, i32 2306, i64 256, i8* %8, i64* null) #5
  store i32 %call22, i32* %err, align 4, !tbaa !15
  %cmp23 = icmp eq i32 %call22, 0
  br i1 %cmp23, label %if.end25, label %for.inc

if.end25:                                         ; preds = %for.body
  %call27 = call i8* @strstr(i8* %8, i8* %call17) #5
  %tobool = icmp eq i8* %call27, null
  br i1 %tobool, label %for.inc, label %cleanup

cleanup:                                          ; preds = %if.end25
  %arrayidx.lcssa = phi %struct._cl_platform_id** [ %arrayidx, %if.end25 ]
  %10 = load %struct._cl_platform_id** %arrayidx.lcssa, align 8, !tbaa !18
  call void @llvm.lifetime.end(i64 256, i8* %8) #3
  br label %if.end36

for.inc:                                          ; preds = %if.end25, %for.body
  call void @llvm.lifetime.end(i64 256, i8* %8) #3
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %11 = load i32* %platform_count, align 4, !tbaa !15
  %12 = zext i32 %11 to i64
  %cmp20 = icmp ult i64 %indvars.iv.next, %12
  br i1 %cmp20, label %for.body, label %if.then38.loopexit

if.else:                                          ; preds = %if.end16
  br i1 %cmp32, label %if.then38, label %if.then33

if.then33:                                        ; preds = %if.else
  %13 = load %struct._cl_platform_id** %arraydecay, align 16, !tbaa !18
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %cleanup
  %platform.2 = phi %struct._cl_platform_id* [ %10, %cleanup ], [ %13, %if.then33 ]
  %cmp37 = icmp eq %struct._cl_platform_id* %platform.2, null
  br i1 %cmp37, label %if.then38, label %if.end41

if.then38.loopexit:                               ; preds = %for.inc
  br label %if.then38

if.then38:                                        ; preds = %if.then38.loopexit, %if.end36, %if.else, %for.cond.preheader
  %dst.i182 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue39, i64 0, i32 1
  %arraydecay.i183 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue39, i64 0, i32 0, i64 0
  store i8* %arraydecay.i183, i8** %dst.i182, align 8, !tbaa !42
  %end.i184 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue39, i64 0, i32 2
  %add.ptr.i185 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue39, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i185, i8** %end.i184, align 8, !tbaa !44
  %user_context.i186 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue39, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i186, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i185, align 1, !tbaa !19
  %call.i191 = call i8* @halide_string_to_string(i8* %arraydecay.i183, i8* %add.ptr.i185, i8* getelementptr inbounds ([29 x i8]* @.str1876, i64 0, i64 0)) #5
  store i8* %call.i191, i8** %dst.i182, align 8, !tbaa !42
  %14 = load i8** %user_context.i186, align 8, !tbaa !45
  call void @halide_error(i8* %14, i8* %arraydecay.i183) #5
  br label %return

if.end41:                                         ; preds = %if.end36
  %call42 = call i8* @halide_get_ocl_device_type(i8* %user_context) #5
  %cmp43 = icmp eq i8* %call42, null
  br i1 %cmp43, label %if.end59, label %if.then44

if.then44:                                        ; preds = %if.end41
  %call45 = call i8* @strstr(i8* getelementptr inbounds ([4 x i8]* @.str1977, i64 0, i64 0), i8* %call42) #5
  %tobool46 = icmp eq i8* %call45, null
  %. = select i1 %tobool46, i64 0, i64 2
  %call49 = call i8* @strstr(i8* getelementptr inbounds ([4 x i8]* @.str2078, i64 0, i64 0), i8* %call42) #5
  %tobool50 = icmp eq i8* %call49, null
  %or52 = or i64 %., 4
  %device_type.1 = select i1 %tobool50, i64 %., i64 %or52
  %call54 = call i8* @strstr(i8* getelementptr inbounds ([4 x i8]* @.str2179, i64 0, i64 0), i8* %call42) #5
  %tobool55 = icmp eq i8* %call54, null
  %or57 = or i64 %device_type.1, 8
  %device_type.1.or57 = select i1 %tobool55, i64 %device_type.1, i64 %or57
  br label %if.end59

if.end59:                                         ; preds = %if.then44, %if.end41
  %device_type.2 = phi i64 [ 0, %if.end41 ], [ %device_type.1.or57, %if.then44 ]
  %cmp60 = icmp eq i64 %device_type.2, 0
  %.device_type.2 = select i1 %cmp60, i64 4294967295, i64 %device_type.2
  store i32 0, i32* %deviceCount, align 4, !tbaa !15
  %arraydecay63 = getelementptr inbounds [4 x %struct._cl_device_id*]* %devices, i64 0, i64 0
  %call64 = call i32 @clGetDeviceIDs(%struct._cl_platform_id* %platform.2, i64 %.device_type.2, i32 4, %struct._cl_device_id** %arraydecay63, i32* %deviceCount) #5
  store i32 %call64, i32* %err, align 4, !tbaa !15
  %cmp65 = icmp eq i32 %call64, 0
  br i1 %cmp65, label %if.end71, label %if.then66

if.then66:                                        ; preds = %if.end59
  %dst.i194 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue67, i64 0, i32 1
  %arraydecay.i195 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue67, i64 0, i32 0, i64 0
  store i8* %arraydecay.i195, i8** %dst.i194, align 8, !tbaa !42
  %end.i196 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue67, i64 0, i32 2
  %add.ptr.i197 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue67, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i197, i8** %end.i196, align 8, !tbaa !44
  %user_context.i198 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue67, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i198, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i197, align 1, !tbaa !19
  %call.i204 = call i8* @halide_string_to_string(i8* %arraydecay.i195, i8* %add.ptr.i197, i8* getelementptr inbounds ([28 x i8]* @.str2280, i64 0, i64 0)) #5
  store i8* %call.i204, i8** %dst.i194, align 8, !tbaa !42
  %15 = load i32* %err, align 4, !tbaa !15
  %call69 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %15) #6
  %16 = load i8** %dst.i194, align 8, !tbaa !42
  %17 = load i8** %end.i196, align 8, !tbaa !44
  %call.i207 = call i8* @halide_string_to_string(i8* %16, i8* %17, i8* %call69) #5
  store i8* %call.i207, i8** %dst.i194, align 8, !tbaa !42
  %18 = load i8** %user_context.i198, align 8, !tbaa !45
  call void @halide_error(i8* %18, i8* %arraydecay.i195) #5
  %19 = load i32* %err, align 4, !tbaa !15
  br label %return

if.end71:                                         ; preds = %if.end59
  %call72 = call i32 @halide_get_gpu_device(i8* %user_context) #5
  %cmp73 = icmp eq i32 %call72, -1
  %20 = load i32* %deviceCount, align 4
  %sub = add i32 %20, -1
  %device.0 = select i1 %cmp73, i32 %sub, i32 %call72
  %cmp76 = icmp sgt i32 %device.0, -1
  %cmp77 = icmp ult i32 %device.0, %20
  %or.cond = and i1 %cmp76, %cmp77
  br i1 %or.cond, label %if.end82, label %if.then78

if.then78:                                        ; preds = %if.end71
  %dst.i210 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue79, i64 0, i32 1
  %arraydecay.i211 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue79, i64 0, i32 0, i64 0
  store i8* %arraydecay.i211, i8** %dst.i210, align 8, !tbaa !42
  %end.i212 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue79, i64 0, i32 2
  %add.ptr.i213 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue79, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i213, i8** %end.i212, align 8, !tbaa !44
  %user_context.i214 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue79, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i214, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i213, align 1, !tbaa !19
  %call.i217 = call i8* @halide_string_to_string(i8* %arraydecay.i211, i8* %add.ptr.i213, i8* getelementptr inbounds ([27 x i8]* @.str2381, i64 0, i64 0)) #5
  store i8* %call.i217, i8** %dst.i210, align 8, !tbaa !42
  %21 = load i8** %end.i212, align 8, !tbaa !44
  %conv.i = sext i32 %device.0 to i64
  %call.i220 = call i8* @halide_int64_to_string(i8* %call.i217, i8* %21, i64 %conv.i, i32 1) #5
  store i8* %call.i220, i8** %dst.i210, align 8, !tbaa !42
  %22 = load i8** %user_context.i214, align 8, !tbaa !45
  call void @halide_error(i8* %22, i8* %arraydecay.i211) #5
  br label %return

if.end82:                                         ; preds = %if.end71
  %idxprom83 = sext i32 %device.0 to i64
  %arrayidx84 = getelementptr inbounds [4 x %struct._cl_device_id*]* %devices, i64 0, i64 %idxprom83
  %23 = load %struct._cl_device_id** %arrayidx84, align 8, !tbaa !18
  store %struct._cl_device_id* %23, %struct._cl_device_id** %dev, align 8, !tbaa !18
  %arrayinit.begin = getelementptr inbounds [3 x i64]* %properties, i64 0, i64 0
  store i64 4228, i64* %arrayinit.begin, align 16, !tbaa !17
  %arrayinit.element = getelementptr inbounds [3 x i64]* %properties, i64 0, i64 1
  %24 = ptrtoint %struct._cl_platform_id* %platform.2 to i64
  store i64 %24, i64* %arrayinit.element, align 8, !tbaa !17
  %arrayinit.element85 = getelementptr inbounds [3 x i64]* %properties, i64 0, i64 2
  store i64 0, i64* %arrayinit.element85, align 16, !tbaa !17
  %call89 = call %struct._cl_context* @clCreateContext(i64* %arrayinit.begin, i32 1, %struct._cl_device_id** %dev, void (i8*, i8*, i64, i8*)* null, i8* null, i32* %err) #5
  store %struct._cl_context* %call89, %struct._cl_context** %ctx, align 8, !tbaa !18
  %25 = load i32* %err, align 4, !tbaa !15
  %cmp90 = icmp eq i32 %25, 0
  br i1 %cmp90, label %if.else99, label %if.then91

if.then91:                                        ; preds = %if.end82
  %call93 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %25) #6
  %dst.i226 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 1
  %arraydecay.i227 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 0, i64 0
  store i8* %arraydecay.i227, i8** %dst.i226, align 8, !tbaa !42
  %end.i228 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 2
  %add.ptr.i229 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i229, i8** %end.i228, align 8, !tbaa !44
  %user_context.i230 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i230, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i229, align 1, !tbaa !19
  %call.i225 = call i8* @halide_string_to_string(i8* %arraydecay.i227, i8* %add.ptr.i229, i8* getelementptr inbounds ([29 x i8]* @.str2582, i64 0, i64 0)) #5
  store i8* %call.i225, i8** %dst.i226, align 8, !tbaa !42
  %26 = load i32* %err, align 4, !tbaa !15
  %call97 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %26) #6
  %27 = load i8** %dst.i226, align 8, !tbaa !42
  %28 = load i8** %end.i228, align 8, !tbaa !44
  %call.i201 = call i8* @halide_string_to_string(i8* %27, i8* %28, i8* %call97) #5
  store i8* %call.i201, i8** %dst.i226, align 8, !tbaa !42
  %29 = load i8** %user_context.i230, align 8, !tbaa !45
  call void @halide_error(i8* %29, i8* %arraydecay.i227) #5
  %30 = load i32* %err, align 4, !tbaa !15
  br label %return

if.else99:                                        ; preds = %if.end82
  %31 = load %struct._cl_device_id** %dev, align 8, !tbaa !18
  %call107 = call %struct._cl_command_queue* @clCreateCommandQueue(%struct._cl_context* %call89, %struct._cl_device_id* %31, i64 0, i32* %err) #5
  store %struct._cl_command_queue* %call107, %struct._cl_command_queue** %q, align 8, !tbaa !18
  %32 = load i32* %err, align 4, !tbaa !15
  %cmp108 = icmp eq i32 %32, 0
  br i1 %cmp108, label %return, label %if.then109

if.then109:                                       ; preds = %if.else99
  %call111 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %32) #6
  %dst.i169 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue113, i64 0, i32 1
  %arraydecay.i170 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue113, i64 0, i32 0, i64 0
  store i8* %arraydecay.i170, i8** %dst.i169, align 8, !tbaa !42
  %end.i171 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue113, i64 0, i32 2
  %add.ptr.i172 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue113, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i172, i8** %end.i171, align 8, !tbaa !44
  %user_context.i173 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue113, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i173, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i172, align 1, !tbaa !19
  %call.i164 = call i8* @halide_string_to_string(i8* %arraydecay.i170, i8* %add.ptr.i172, i8* getelementptr inbounds ([34 x i8]* @.str2783, i64 0, i64 0)) #5
  store i8* %call.i164, i8** %dst.i169, align 8, !tbaa !42
  %33 = load i32* %err, align 4, !tbaa !15
  %call115 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %33) #6
  %34 = load i8** %dst.i169, align 8, !tbaa !42
  %35 = load i8** %end.i171, align 8, !tbaa !44
  %call.i = call i8* @halide_string_to_string(i8* %34, i8* %35, i8* %call115) #5
  store i8* %call.i, i8** %dst.i169, align 8, !tbaa !42
  %36 = load i8** %user_context.i173, align 8, !tbaa !45
  call void @halide_error(i8* %36, i8* %arraydecay.i170) #5
  %37 = load i32* %err, align 4, !tbaa !15
  br label %return

return:                                           ; preds = %if.then109, %if.else99, %if.then91, %if.then78, %if.then66, %if.then38, %if.then12
  %retval.0 = phi i32 [ %6, %if.then12 ], [ -32, %if.then38 ], [ %19, %if.then66 ], [ -1, %if.then78 ], [ %30, %if.then91 ], [ %37, %if.then109 ], [ 0, %if.else99 ]
  ret i32 %retval.0
}

; Function Attrs: nounwind uwtable
define linkonce i32 @halide_release_cl_context(i8* %user_context) #1 {
entry:
  %0 = load i32** @_ZN6Halide7Runtime8Internal11cl_lock_ptrE, align 8, !tbaa !18
  store atomic i32 0, i32* %0 release, align 4
  ret i32 0
}

; Function Attrs: nounwind uwtable
define linkonce zeroext i1 @_ZN6Halide7Runtime8Internal20validate_dev_pointerEPvP8buffer_tm(i8* %user_context, %struct.buffer_t* %buf, i64 %size) #1 {
entry:
  %real_size = alloca i64, align 8
  %temp.lvalue = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %dev = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 0
  %0 = load i64* %dev, align 8, !tbaa !37
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %1 = inttoptr i64 %0 to %struct._cl_mem*
  %2 = bitcast i64* %real_size to i8*
  %call = call i32 @clGetMemObjectInfo(%struct._cl_mem* %1, i32 4354, i64 8, i8* %2, i64* null) #5
  %cmp2 = icmp eq i32 %call, 0
  br i1 %cmp2, label %if.end10, label %if.then3

if.then3:                                         ; preds = %if.end
  %dst.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 1
  %arraydecay.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 0
  store i8* %arraydecay.i, i8** %dst.i, align 8, !tbaa !42
  %end.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 2
  %add.ptr.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i, i8** %end.i, align 8, !tbaa !44
  %user_context.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i, align 1, !tbaa !19
  %call.i = call i8* @halide_string_to_string(i8* %arraydecay.i, i8* %add.ptr.i, i8* getelementptr inbounds ([24 x i8]* @.str684, i64 0, i64 0)) #5
  store i8* %call.i, i8** %dst.i, align 8, !tbaa !42
  %3 = load i64* %dev, align 8, !tbaa !37
  %4 = inttoptr i64 %3 to i8*
  %5 = load i8** %end.i, align 8, !tbaa !44
  %call.i42 = call i8* @halide_pointer_to_string(i8* %call.i, i8* %5, i8* %4) #5
  store i8* %call.i42, i8** %dst.i, align 8, !tbaa !42
  %6 = load i8** %end.i, align 8, !tbaa !44
  %call.i45 = call i8* @halide_string_to_string(i8* %call.i42, i8* %6, i8* getelementptr inbounds ([31 x i8]* @.str785, i64 0, i64 0)) #5
  store i8* %call.i45, i8** %dst.i, align 8, !tbaa !42
  %call8 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %call) #6
  %7 = load i8** %dst.i, align 8, !tbaa !42
  %8 = load i8** %end.i, align 8, !tbaa !44
  %call.i48 = call i8* @halide_string_to_string(i8* %7, i8* %8, i8* %call8) #5
  store i8* %call.i48, i8** %dst.i, align 8, !tbaa !42
  %9 = load i8** %user_context.i, align 8, !tbaa !45
  call void @halide_error(i8* %9, i8* %arraydecay.i) #5
  br label %return

if.end10:                                         ; preds = %if.end
  %10 = load i64* %real_size, align 8
  %cmp25 = icmp ult i64 %10, %size
  br i1 %cmp25, label %if.then26, label %return

if.then26:                                        ; preds = %if.end10
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([65 x i8]* @.str1286, i64 0, i64 0)) #5
  br label %return

return:                                           ; preds = %if.then26, %if.end10, %if.then3, %entry
  %retval.0 = phi i1 [ false, %if.then3 ], [ true, %entry ], [ true, %if.end10 ], [ true, %if.then26 ]
  ret i1 %retval.0
}

declare i32 @clGetMemObjectInfo(%struct._cl_mem*, i32, i64, i8*, i64*) #0

; Function Attrs: nounwind uwtable
define linkonce i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %err) #1 {
entry:
  %switch.tableidx = add i32 %err, 63
  %0 = icmp ult i32 %switch.tableidx, 64
  br i1 %0, label %switch.lookup, label %return

switch.lookup:                                    ; preds = %entry
  %1 = sext i32 %switch.tableidx to i64
  %switch.gep = getelementptr inbounds [64 x i8*]* @switch.table, i64 0, i64 %1
  %switch.load = load i8** %switch.gep, align 8
  ret i8* %switch.load

return:                                           ; preds = %entry
  ret i8* getelementptr inbounds ([16 x i8]* @.str150, i64 0, i64 0)
}

declare i32 @clGetPlatformIDs(i32, %struct._cl_platform_id**, i32*) #0

declare i32 @clGetPlatformInfo(%struct._cl_platform_id*, i32, i64, i8*, i64*) #0

; Function Attrs: nounwind readonly
declare i8* @strstr(i8*, i8* nocapture) #2

declare i32 @clGetDeviceIDs(%struct._cl_platform_id*, i64, i32, %struct._cl_device_id**, i32*) #0

declare %struct._cl_context* @clCreateContext(i64*, i32, %struct._cl_device_id**, void (i8*, i8*, i64, i8*)*, i8*, i32*) #0

declare %struct._cl_command_queue* @clCreateCommandQueue(%struct._cl_context*, %struct._cl_device_id*, i64, i32*) #0

; Function Attrs: nounwind uwtable
define weak i32 @halide_dev_free(i8* %user_context, %struct.buffer_t* %buf) #1 {
entry:
  %ctx = alloca %"class.Halide::Runtime::Internal::ClContext", align 8
  %temp.lvalue = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %dev = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 0
  %0 = load i64* %dev, align 8, !tbaa !37
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %return, label %if.end

if.end:                                           ; preds = %entry
  %user_context2.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 0
  store i8* %user_context, i8** %user_context2.i, align 8, !tbaa !46
  %context.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 1
  %cmd_queue.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 2
  %error.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 3
  %1 = bitcast %struct._cl_context** %context.i to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 20, i32 8, i1 false)
  %call.i53 = call i32 @halide_acquire_cl_context(i8* %user_context, %struct._cl_context** %context.i, %struct._cl_command_queue** %cmd_queue.i) #5
  store i32 %call.i53, i32* %error.i, align 8, !tbaa !48
  %2 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %cmp.i = icmp eq %struct._cl_context* %2, null
  %3 = load %struct._cl_command_queue** %cmd_queue.i, align 8
  %cmp8.i = icmp eq %struct._cl_command_queue* %3, null
  %or.cond = or i1 %cmp.i, %cmp8.i
  br i1 %or.cond, label %if.then.i, label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

if.then.i:                                        ; preds = %if.end
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([37 x i8]* @.str151, i64 0, i64 0)) #5
  %.pre = load i32* %error.i, align 8, !tbaa !48
  br label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit:  ; preds = %if.then.i, %if.end
  %4 = phi i32 [ %call.i53, %if.end ], [ %.pre, %if.then.i ]
  %cmp9 = icmp eq i32 %4, 0
  br i1 %cmp9, label %if.end12, label %cleanup

if.end12:                                         ; preds = %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %call = call zeroext i1 @_ZN6Halide7Runtime8Internal20validate_dev_pointerEPvP8buffer_tm(i8* %user_context, %struct.buffer_t* %buf, i64 0) #6
  br i1 %call, label %if.end14, label %if.then13

if.then13:                                        ; preds = %if.end12
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([40 x i8]* @.str30, i64 0, i64 0)) #5
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %if.end12
  %5 = load i64* %dev, align 8, !tbaa !37
  %6 = inttoptr i64 %5 to %struct._cl_mem*
  %call23 = call i32 @clReleaseMemObject(%struct._cl_mem* %6) #5
  store i64 0, i64* %dev, align 8, !tbaa !37
  %cmp25 = icmp eq i32 %call23, 0
  br i1 %cmp25, label %cleanup, label %if.then26

if.then26:                                        ; preds = %if.end14
  %dst.i49 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 1
  %arraydecay.i50 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 0
  store i8* %arraydecay.i50, i8** %dst.i49, align 8, !tbaa !42
  %end.i51 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 2
  %add.ptr.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i, i8** %end.i51, align 8, !tbaa !44
  %user_context.i52 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i52, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i, align 1, !tbaa !19
  %call.i48 = call i8* @halide_string_to_string(i8* %arraydecay.i50, i8* %add.ptr.i, i8* getelementptr inbounds ([32 x i8]* @.str32, i64 0, i64 0)) #5
  store i8* %call.i48, i8** %dst.i49, align 8, !tbaa !42
  %call28 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %call23) #6
  %7 = load i8** %dst.i49, align 8, !tbaa !42
  %8 = load i8** %end.i51, align 8, !tbaa !44
  %call.i45 = call i8* @halide_string_to_string(i8* %7, i8* %8, i8* %call28) #5
  store i8* %call.i45, i8** %dst.i49, align 8, !tbaa !42
  %9 = load i8** %user_context.i52, align 8, !tbaa !45
  call void @halide_error(i8* %9, i8* %arraydecay.i50) #5
  br label %cleanup

cleanup:                                          ; preds = %if.then26, %if.end14, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %retval.0 = phi i32 [ %call23, %if.then26 ], [ %4, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit ], [ 0, %if.end14 ]
  %10 = load i8** %user_context2.i, align 8, !tbaa !46
  %call.i = call i32 @halide_release_cl_context(i8* %10) #5
  br label %return

return:                                           ; preds = %cleanup, %entry
  %retval.1 = phi i32 [ %retval.0, %cleanup ], [ 0, %entry ]
  ret i32 %retval.1
}

declare i32 @clReleaseMemObject(%struct._cl_mem*) #0

; Function Attrs: nounwind uwtable
define linkonce i32 @halide_init_kernels(i8* %user_context, i8** %state_ptr, i8* %src, i32 %size) #1 {
entry:
  %ctx = alloca %"class.Halide::Runtime::Internal::ClContext", align 8
  %err = alloca i32, align 4
  %dev = alloca %struct._cl_device_id*, align 8
  %temp.lvalue = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %devices = alloca [1 x %struct._cl_device_id*], align 8
  %max_constant_buffer_size = alloca i64, align 8
  %temp.lvalue36 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %max_constant_args = alloca i32, align 4
  %temp.lvalue44 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %options = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %sources = alloca [1 x i8*], align 8
  %temp.lvalue66 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %buffer = alloca [8192 x i8], align 16
  %temp.lvalue95 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %temp.lvalue103 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %user_context2.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 0
  store i8* %user_context, i8** %user_context2.i, align 8, !tbaa !46
  %context.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 1
  %cmd_queue.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 2
  %error.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 3
  %0 = bitcast %struct._cl_context** %context.i to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 20, i32 8, i1 false)
  %call.i164 = call i32 @halide_acquire_cl_context(i8* %user_context, %struct._cl_context** %context.i, %struct._cl_command_queue** %cmd_queue.i) #5
  store i32 %call.i164, i32* %error.i, align 8, !tbaa !48
  %1 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %cmp.i = icmp eq %struct._cl_context* %1, null
  %2 = load %struct._cl_command_queue** %cmd_queue.i, align 8
  %cmp8.i = icmp eq %struct._cl_command_queue* %2, null
  %or.cond233 = or i1 %cmp.i, %cmp8.i
  br i1 %or.cond233, label %if.then.i, label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

if.then.i:                                        ; preds = %entry
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([37 x i8]* @.str151, i64 0, i64 0)) #5
  %.pre = load i32* %error.i, align 8, !tbaa !48
  br label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit:  ; preds = %if.then.i, %entry
  %3 = phi i32 [ %call.i164, %entry ], [ %.pre, %if.then.i ]
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.end, label %cleanup109

if.end:                                           ; preds = %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %4 = bitcast i8** %state_ptr to %"struct.Halide::Runtime::Internal::module_state"**
  %5 = load %"struct.Halide::Runtime::Internal::module_state"** %4, align 8, !tbaa !18
  %tobool = icmp eq %"struct.Halide::Runtime::Internal::module_state"* %5, null
  br i1 %tobool, label %if.end19, label %land.lhs.true

if.end19:                                         ; preds = %if.end
  %call = call i8* @malloc(i64 16) #5
  store i8* %call, i8** %state_ptr, align 8, !tbaa !18
  %program = bitcast i8* %call to %struct._cl_program**
  store %struct._cl_program* null, %struct._cl_program** %program, align 8, !tbaa !50
  %6 = load %"struct.Halide::Runtime::Internal::module_state"** @_ZN6Halide7Runtime8Internal10state_listE, align 8, !tbaa !18
  %next = getelementptr inbounds i8* %call, i64 8
  %7 = bitcast i8* %next to %"struct.Halide::Runtime::Internal::module_state"**
  store %"struct.Halide::Runtime::Internal::module_state"* %6, %"struct.Halide::Runtime::Internal::module_state"** %7, align 8, !tbaa !52
  store i8* %call, i8** bitcast (%"struct.Halide::Runtime::Internal::module_state"** @_ZN6Halide7Runtime8Internal10state_listE to i8**), align 8, !tbaa !18
  %.pr = load %"struct.Halide::Runtime::Internal::module_state"** %4, align 8, !tbaa !18
  %tobool20 = icmp eq %"struct.Halide::Runtime::Internal::module_state"* %.pr, null
  br i1 %tobool20, label %land.lhs.true23, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end19, %if.end
  %8 = phi %"struct.Halide::Runtime::Internal::module_state"* [ %.pr, %if.end19 ], [ %5, %if.end ]
  %program21 = getelementptr inbounds %"struct.Halide::Runtime::Internal::module_state"* %8, i64 0, i32 0
  %9 = load %struct._cl_program** %program21, align 8, !tbaa !50
  %tobool22 = icmp eq %struct._cl_program* %9, null
  %cmp24 = icmp sgt i32 %size, 1
  %or.cond = and i1 %cmp24, %tobool22
  br i1 %or.cond, label %if.then25, label %cleanup109

land.lhs.true23:                                  ; preds = %if.end19
  %cmp24.old = icmp sgt i32 %size, 1
  br i1 %cmp24.old, label %if.then25, label %cleanup109

if.then25:                                        ; preds = %land.lhs.true23, %land.lhs.true
  %10 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %11 = bitcast %struct._cl_device_id** %dev to i8*
  %call26 = call i32 @clGetContextInfo(%struct._cl_context* %10, i32 4225, i64 8, i8* %11, i64* null) #5
  store i32 %call26, i32* %err, align 4, !tbaa !15
  %cmp27 = icmp eq i32 %call26, 0
  br i1 %cmp27, label %if.end32, label %if.then28

if.then28:                                        ; preds = %if.then25
  %dst.i165 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 1
  %arraydecay.i166 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 0
  store i8* %arraydecay.i166, i8** %dst.i165, align 8, !tbaa !42
  %end.i167 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 2
  %add.ptr.i168 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i168, i8** %end.i167, align 8, !tbaa !44
  %user_context.i169 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i169, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i168, align 1, !tbaa !19
  %call.i172 = call i8* @halide_string_to_string(i8* %arraydecay.i166, i8* %add.ptr.i168, i8* getelementptr inbounds ([50 x i8]* @.str37, i64 0, i64 0)) #5
  store i8* %call.i172, i8** %dst.i165, align 8, !tbaa !42
  %12 = load i32* %err, align 4, !tbaa !15
  %call30 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %12) #6
  %13 = load i8** %dst.i165, align 8, !tbaa !42
  %14 = load i8** %end.i167, align 8, !tbaa !44
  %call.i175 = call i8* @halide_string_to_string(i8* %13, i8* %14, i8* %call30) #5
  store i8* %call.i175, i8** %dst.i165, align 8, !tbaa !42
  %15 = load i8** %user_context.i169, align 8, !tbaa !45
  call void @halide_error(i8* %15, i8* %arraydecay.i166) #5
  %16 = load i32* %err, align 4, !tbaa !15
  br label %cleanup109

if.end32:                                         ; preds = %if.then25
  %arrayinit.begin = getelementptr inbounds [1 x %struct._cl_device_id*]* %devices, i64 0, i64 0
  %17 = load %struct._cl_device_id** %dev, align 8, !tbaa !18
  store %struct._cl_device_id* %17, %struct._cl_device_id** %arrayinit.begin, align 8, !tbaa !18
  store i64 0, i64* %max_constant_buffer_size, align 8, !tbaa !17
  %18 = bitcast i64* %max_constant_buffer_size to i8*
  %call33 = call i32 @clGetDeviceInfo(%struct._cl_device_id* %17, i32 4128, i64 8, i8* %18, i64* null) #5
  store i32 %call33, i32* %err, align 4, !tbaa !15
  %cmp34 = icmp eq i32 %call33, 0
  br i1 %cmp34, label %if.end40, label %if.then35

if.then35:                                        ; preds = %if.end32
  %dst.i178 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue36, i64 0, i32 1
  %arraydecay.i179 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue36, i64 0, i32 0, i64 0
  store i8* %arraydecay.i179, i8** %dst.i178, align 8, !tbaa !42
  %end.i180 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue36, i64 0, i32 2
  %add.ptr.i181 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue36, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i181, i8** %end.i180, align 8, !tbaa !44
  %user_context.i182 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue36, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i182, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i181, align 1, !tbaa !19
  %call.i188 = call i8* @halide_string_to_string(i8* %arraydecay.i179, i8* %add.ptr.i181, i8* getelementptr inbounds ([66 x i8]* @.str38, i64 0, i64 0)) #5
  store i8* %call.i188, i8** %dst.i178, align 8, !tbaa !42
  %19 = load i32* %err, align 4, !tbaa !15
  %call38 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %19) #6
  %20 = load i8** %dst.i178, align 8, !tbaa !42
  %21 = load i8** %end.i180, align 8, !tbaa !44
  %call.i191 = call i8* @halide_string_to_string(i8* %20, i8* %21, i8* %call38) #5
  store i8* %call.i191, i8** %dst.i178, align 8, !tbaa !42
  %22 = load i8** %user_context.i182, align 8, !tbaa !45
  call void @halide_error(i8* %22, i8* %arraydecay.i179) #5
  %23 = load i32* %err, align 4, !tbaa !15
  br label %cleanup109

if.end40:                                         ; preds = %if.end32
  store i32 0, i32* %max_constant_args, align 4, !tbaa !15
  %24 = load %struct._cl_device_id** %dev, align 8, !tbaa !18
  %25 = bitcast i32* %max_constant_args to i8*
  %call41 = call i32 @clGetDeviceInfo(%struct._cl_device_id* %24, i32 4129, i64 4, i8* %25, i64* null) #5
  store i32 %call41, i32* %err, align 4, !tbaa !15
  %cmp42 = icmp eq i32 %call41, 0
  br i1 %cmp42, label %if.end48, label %if.then43

if.then43:                                        ; preds = %if.end40
  %dst.i194 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue44, i64 0, i32 1
  %arraydecay.i195 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue44, i64 0, i32 0, i64 0
  store i8* %arraydecay.i195, i8** %dst.i194, align 8, !tbaa !42
  %end.i196 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue44, i64 0, i32 2
  %add.ptr.i197 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue44, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i197, i8** %end.i196, align 8, !tbaa !44
  %user_context.i198 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue44, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i198, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i197, align 1, !tbaa !19
  %call.i201 = call i8* @halide_string_to_string(i8* %arraydecay.i195, i8* %add.ptr.i197, i8* getelementptr inbounds ([59 x i8]* @.str39, i64 0, i64 0)) #5
  store i8* %call.i201, i8** %dst.i194, align 8, !tbaa !42
  %26 = load i32* %err, align 4, !tbaa !15
  %call46 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %26) #6
  %27 = load i8** %dst.i194, align 8, !tbaa !42
  %28 = load i8** %end.i196, align 8, !tbaa !44
  %call.i204 = call i8* @halide_string_to_string(i8* %27, i8* %28, i8* %call46) #5
  store i8* %call.i204, i8** %dst.i194, align 8, !tbaa !42
  %29 = load i8** %user_context.i198, align 8, !tbaa !45
  call void @halide_error(i8* %29, i8* %arraydecay.i195) #5
  %30 = load i32* %err, align 4, !tbaa !15
  br label %cleanup109

if.end48:                                         ; preds = %if.end40
  %31 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %options, i64 0, i32 0, i64 0
  call void @llvm.lifetime.start(i64 1048, i8* %31) #3
  %dst.i207 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %options, i64 0, i32 1
  store i8* %31, i8** %dst.i207, align 8, !tbaa !53
  %end.i209 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %options, i64 0, i32 2
  %add.ptr.i210 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %options, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i210, i8** %end.i209, align 8, !tbaa !55
  %user_context.i211 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %options, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i211, align 8, !tbaa !56
  store i8 0, i8* %add.ptr.i210, align 1, !tbaa !19
  %call.i217 = call i8* @halide_string_to_string(i8* %31, i8* %add.ptr.i210, i8* getelementptr inbounds ([29 x i8]* @.str40, i64 0, i64 0)) #5
  store i8* %call.i217, i8** %dst.i207, align 8, !tbaa !53
  %32 = load i64* %max_constant_buffer_size, align 8, !tbaa !17
  %33 = load i8** %end.i209, align 8, !tbaa !55
  %call.i220 = call i8* @halide_uint64_to_string(i8* %call.i217, i8* %33, i64 %32, i32 1) #5
  store i8* %call.i220, i8** %dst.i207, align 8, !tbaa !53
  %34 = load i8** %end.i209, align 8, !tbaa !55
  %call.i223 = call i8* @halide_string_to_string(i8* %call.i220, i8* %34, i8* getelementptr inbounds ([23 x i8]* @.str41, i64 0, i64 0)) #5
  store i8* %call.i223, i8** %dst.i207, align 8, !tbaa !53
  %35 = load i32* %max_constant_args, align 4, !tbaa !15
  %36 = load i8** %end.i209, align 8, !tbaa !55
  %conv.i = zext i32 %35 to i64
  %call.i226 = call i8* @halide_uint64_to_string(i8* %call.i223, i8* %36, i64 %conv.i, i32 1) #5
  store i8* %call.i226, i8** %dst.i207, align 8, !tbaa !53
  %arrayinit.begin53 = getelementptr inbounds [1 x i8*]* %sources, i64 0, i64 0
  store i8* %src, i8** %arrayinit.begin53, align 8, !tbaa !18
  %37 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %call58 = call %struct._cl_program* @clCreateProgramWithSource(%struct._cl_context* %37, i32 1, i8** %arrayinit.begin53, i64* null, i32* %err) #5
  %38 = load i32* %err, align 4, !tbaa !15
  %cmp59 = icmp eq i32 %38, 0
  br i1 %cmp59, label %if.else, label %if.then60

if.then60:                                        ; preds = %if.end48
  %call63 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %38) #6
  %dst.i227 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue66, i64 0, i32 1
  %arraydecay.i228 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue66, i64 0, i32 0, i64 0
  store i8* %arraydecay.i228, i8** %dst.i227, align 8, !tbaa !42
  %end.i229 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue66, i64 0, i32 2
  %add.ptr.i230 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue66, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i230, i8** %end.i229, align 8, !tbaa !44
  %user_context.i231 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue66, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i231, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i230, align 1, !tbaa !19
  %call.i214 = call i8* @halide_string_to_string(i8* %arraydecay.i228, i8* %add.ptr.i230, i8* getelementptr inbounds ([39 x i8]* @.str43, i64 0, i64 0)) #5
  store i8* %call.i214, i8** %dst.i227, align 8, !tbaa !42
  %39 = load i32* %err, align 4, !tbaa !15
  %call68 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %39) #6
  %40 = load i8** %dst.i227, align 8, !tbaa !42
  %41 = load i8** %end.i229, align 8, !tbaa !44
  %call.i185 = call i8* @halide_string_to_string(i8* %40, i8* %41, i8* %call68) #5
  store i8* %call.i185, i8** %dst.i227, align 8, !tbaa !42
  %42 = load i8** %user_context.i231, align 8, !tbaa !45
  call void @halide_error(i8* %42, i8* %arraydecay.i228) #5
  %43 = load i32* %err, align 4, !tbaa !15
  br label %cleanup.thread

if.else:                                          ; preds = %if.end48
  %44 = load %"struct.Halide::Runtime::Internal::module_state"** %4, align 8, !tbaa !18
  %program75 = getelementptr inbounds %"struct.Halide::Runtime::Internal::module_state"* %44, i64 0, i32 0
  store %struct._cl_program* %call58, %struct._cl_program** %program75, align 8, !tbaa !50
  %call88 = call i32 @clBuildProgram(%struct._cl_program* %call58, i32 1, %struct._cl_device_id** %arrayinit.begin, i8* %31, void (%struct._cl_program*, i8*)* null, i8* null) #5
  store i32 %call88, i32* %err, align 4, !tbaa !15
  %cmp89 = icmp eq i32 %call88, 0
  br i1 %cmp89, label %cleanup, label %if.then90

if.then90:                                        ; preds = %if.else
  %45 = getelementptr inbounds [8192 x i8]* %buffer, i64 0, i64 0
  call void @llvm.lifetime.start(i64 8192, i8* %45) #3
  %46 = load %struct._cl_device_id** %dev, align 8, !tbaa !18
  %call92 = call i32 @clGetProgramBuildInfo(%struct._cl_program* %call58, %struct._cl_device_id* %46, i32 4483, i64 8192, i8* %45, i64* null) #5
  %cmp93 = icmp eq i32 %call92, 0
  br i1 %cmp93, label %if.then94, label %if.else102

if.then94:                                        ; preds = %if.then90
  %dst.i156 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 1
  %arraydecay.i157 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 0, i64 0
  store i8* %arraydecay.i157, i8** %dst.i156, align 8, !tbaa !42
  %end.i158 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 2
  %add.ptr.i159 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i159, i8** %end.i158, align 8, !tbaa !44
  %user_context.i160 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue95, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i160, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i159, align 1, !tbaa !19
  %call.i155 = call i8* @halide_string_to_string(i8* %arraydecay.i157, i8* %add.ptr.i159, i8* getelementptr inbounds ([28 x i8]* @.str46, i64 0, i64 0)) #5
  store i8* %call.i155, i8** %dst.i156, align 8, !tbaa !42
  %47 = load i32* %err, align 4, !tbaa !15
  %call97 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %47) #6
  %48 = load i8** %dst.i156, align 8, !tbaa !42
  %49 = load i8** %end.i158, align 8, !tbaa !44
  %call.i152 = call i8* @halide_string_to_string(i8* %48, i8* %49, i8* %call97) #5
  store i8* %call.i152, i8** %dst.i156, align 8, !tbaa !42
  %50 = load i8** %end.i158, align 8, !tbaa !44
  %call.i149 = call i8* @halide_string_to_string(i8* %call.i152, i8* %50, i8* getelementptr inbounds ([14 x i8]* @.str47, i64 0, i64 0)) #5
  store i8* %call.i149, i8** %dst.i156, align 8, !tbaa !42
  %51 = load i8** %end.i158, align 8, !tbaa !44
  %call.i146 = call i8* @halide_string_to_string(i8* %call.i149, i8* %51, i8* %45) #5
  store i8* %call.i146, i8** %dst.i156, align 8, !tbaa !42
  %52 = load i8** %user_context.i160, align 8, !tbaa !45
  call void @halide_error(i8* %52, i8* %arraydecay.i157) #5
  br label %if.end105

if.else102:                                       ; preds = %if.then90
  %dst.i138 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue103, i64 0, i32 1
  %arraydecay.i139 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue103, i64 0, i32 0, i64 0
  store i8* %arraydecay.i139, i8** %dst.i138, align 8, !tbaa !42
  %end.i140 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue103, i64 0, i32 2
  %add.ptr.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue103, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i, i8** %end.i140, align 8, !tbaa !44
  %user_context.i141 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue103, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i141, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i, align 1, !tbaa !19
  %call.i137 = call i8* @halide_string_to_string(i8* %arraydecay.i139, i8* %add.ptr.i, i8* getelementptr inbounds ([29 x i8]* @.str48, i64 0, i64 0)) #5
  store i8* %call.i137, i8** %dst.i138, align 8, !tbaa !42
  %53 = load i8** %user_context.i141, align 8, !tbaa !45
  call void @halide_error(i8* %53, i8* %arraydecay.i139) #5
  br label %if.end105

if.end105:                                        ; preds = %if.else102, %if.then94
  %54 = load i32* %err, align 4, !tbaa !15
  call void @llvm.lifetime.end(i64 8192, i8* %45) #3
  br label %cleanup.thread

cleanup.thread:                                   ; preds = %if.end105, %if.then60
  %retval.0.ph = phi i32 [ %54, %if.end105 ], [ %43, %if.then60 ]
  call void @llvm.lifetime.end(i64 1048, i8* %31) #3
  br label %cleanup109

cleanup:                                          ; preds = %if.else
  call void @llvm.lifetime.end(i64 1048, i8* %31) #3
  br label %cleanup109

cleanup109:                                       ; preds = %cleanup, %cleanup.thread, %if.then43, %if.then35, %if.then28, %land.lhs.true23, %land.lhs.true, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %retval.1 = phi i32 [ %16, %if.then28 ], [ %23, %if.then35 ], [ %30, %if.then43 ], [ %3, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit ], [ %retval.0.ph, %cleanup.thread ], [ 0, %cleanup ], [ 0, %land.lhs.true ], [ 0, %land.lhs.true23 ]
  %55 = load i8** %user_context2.i, align 8, !tbaa !46
  %call.i = call i32 @halide_release_cl_context(i8* %55) #5
  ret i32 %retval.1
}

declare i32 @clGetContextInfo(%struct._cl_context*, i32, i64, i8*, i64*) #0

declare i32 @clGetDeviceInfo(%struct._cl_device_id*, i32, i64, i8*, i64*) #0

declare %struct._cl_program* @clCreateProgramWithSource(%struct._cl_context*, i32, i8**, i64*, i32*) #0

declare i32 @clBuildProgram(%struct._cl_program*, i32, %struct._cl_device_id**, i8*, void (%struct._cl_program*, i8*)*, i8*) #0

declare i32 @clGetProgramBuildInfo(%struct._cl_program*, %struct._cl_device_id*, i32, i64, i8*, i64*) #0

; Function Attrs: nounwind uwtable
define weak i32 @halide_dev_sync(i8* %user_context) #1 {
entry:
  %ctx = alloca %"class.Halide::Runtime::Internal::ClContext", align 8
  %temp.lvalue = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %user_context2.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 0
  store i8* %user_context, i8** %user_context2.i, align 8, !tbaa !46
  %context.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 1
  %cmd_queue.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 2
  %error.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 3
  %0 = bitcast %struct._cl_context** %context.i to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 20, i32 8, i1 false)
  %call.i19 = call i32 @halide_acquire_cl_context(i8* %user_context, %struct._cl_context** %context.i, %struct._cl_command_queue** %cmd_queue.i) #5
  store i32 %call.i19, i32* %error.i, align 8, !tbaa !48
  %1 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %cmp.i = icmp eq %struct._cl_context* %1, null
  %2 = load %struct._cl_command_queue** %cmd_queue.i, align 8
  %cmp8.i = icmp eq %struct._cl_command_queue* %2, null
  %or.cond = or i1 %cmp.i, %cmp8.i
  br i1 %or.cond, label %if.then.i, label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

if.then.i:                                        ; preds = %entry
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([37 x i8]* @.str151, i64 0, i64 0)) #5
  %.pre = load i32* %error.i, align 8, !tbaa !48
  br label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit:  ; preds = %if.then.i, %entry
  %3 = phi i32 [ %call.i19, %entry ], [ %.pre, %if.then.i ]
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([24 x i8]* @.str50, i64 0, i64 0)) #5
  br label %if.end

if.end:                                           ; preds = %if.then, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %4 = load %struct._cl_command_queue** %cmd_queue.i, align 8, !tbaa !57
  %call = call i32 @clFinish(%struct._cl_command_queue* %4) #5
  %cmp5 = icmp eq i32 %call, 0
  br i1 %cmp5, label %cleanup, label %if.then6

if.then6:                                         ; preds = %if.end
  %dst.i20 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 1
  %arraydecay.i21 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 0
  store i8* %arraydecay.i21, i8** %dst.i20, align 8, !tbaa !42
  %end.i22 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 2
  %add.ptr.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i, i8** %end.i22, align 8, !tbaa !44
  %user_context.i23 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i23, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i, align 1, !tbaa !19
  %call.i26 = call i8* @halide_string_to_string(i8* %arraydecay.i21, i8* %add.ptr.i, i8* getelementptr inbounds ([22 x i8]* @.str51, i64 0, i64 0)) #5
  store i8* %call.i26, i8** %dst.i20, align 8, !tbaa !42
  %call8 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %call) #6
  %5 = load i8** %dst.i20, align 8, !tbaa !42
  %6 = load i8** %end.i22, align 8, !tbaa !44
  %call.i18 = call i8* @halide_string_to_string(i8* %5, i8* %6, i8* %call8) #5
  store i8* %call.i18, i8** %dst.i20, align 8, !tbaa !42
  %7 = load i8** %user_context.i23, align 8, !tbaa !45
  call void @halide_error(i8* %7, i8* %arraydecay.i21) #5
  br label %cleanup

cleanup:                                          ; preds = %if.then6, %if.end
  %retval.0 = phi i32 [ %call, %if.then6 ], [ 0, %if.end ]
  %8 = load i8** %user_context2.i, align 8, !tbaa !46
  %call.i = call i32 @halide_release_cl_context(i8* %8) #5
  ret i32 %retval.0
}

declare i32 @clFinish(%struct._cl_command_queue*) #0

; Function Attrs: nounwind uwtable
define weak void @halide_release(i8* %user_context) #1 {
entry:
  %ctx = alloca %struct._cl_context*, align 8
  %q = alloca %struct._cl_command_queue*, align 8
  %call = call i32 @halide_acquire_cl_context(i8* %user_context, %struct._cl_context** %ctx, %struct._cl_command_queue** %q) #6
  %cmp = icmp eq i32 %call, 0
  %0 = load %struct._cl_context** %ctx, align 8
  %tobool = icmp ne %struct._cl_context* %0, null
  %or.cond = and i1 %cmp, %tobool
  br i1 %or.cond, label %if.end, label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._cl_command_queue** %q, align 8, !tbaa !18
  %call5 = call i32 @clFinish(%struct._cl_command_queue* %1) #5
  %cmp6 = icmp eq i32 %call5, 0
  br i1 %cmp6, label %while.cond.preheader, label %if.then7

if.then7:                                         ; preds = %if.end
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([18 x i8]* @.str53, i64 0, i64 0)) #5
  br label %while.cond.preheader

while.cond.preheader:                             ; preds = %if.then7, %if.end
  %state.069 = load %"struct.Halide::Runtime::Internal::module_state"** @_ZN6Halide7Runtime8Internal10state_listE, align 8
  %tobool970 = icmp eq %"struct.Halide::Runtime::Internal::module_state"* %state.069, null
  br i1 %tobool970, label %while.end, label %while.body.preheader

while.body.preheader:                             ; preds = %while.cond.preheader
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %if.end25
  %state.071 = phi %"struct.Halide::Runtime::Internal::module_state"* [ %state.0, %if.end25 ], [ %state.069, %while.body.preheader ]
  %program = getelementptr inbounds %"struct.Halide::Runtime::Internal::module_state"* %state.071, i64 0, i32 0
  %2 = load %struct._cl_program** %program, align 8, !tbaa !50
  %tobool10 = icmp eq %struct._cl_program* %2, null
  br i1 %tobool10, label %if.end25, label %if.then11

if.then11:                                        ; preds = %while.body
  %call20 = call i32 @clReleaseProgram(%struct._cl_program* %2) #5
  %cmp21 = icmp eq i32 %call20, 0
  br i1 %cmp21, label %if.end23, label %if.then22

if.then22:                                        ; preds = %if.then11
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([18 x i8]* @.str53, i64 0, i64 0)) #5
  br label %if.end23

if.end23:                                         ; preds = %if.then22, %if.then11
  store %struct._cl_program* null, %struct._cl_program** %program, align 8, !tbaa !50
  br label %if.end25

if.end25:                                         ; preds = %if.end23, %while.body
  %next = getelementptr inbounds %"struct.Halide::Runtime::Internal::module_state"* %state.071, i64 0, i32 1
  %state.0 = load %"struct.Halide::Runtime::Internal::module_state"** %next, align 8
  %tobool9 = icmp eq %"struct.Halide::Runtime::Internal::module_state"* %state.0, null
  br i1 %tobool9, label %while.end.loopexit, label %while.body

while.end.loopexit:                               ; preds = %if.end25
  br label %while.end

while.end:                                        ; preds = %while.end.loopexit, %while.cond.preheader
  %3 = load %struct._cl_context** %ctx, align 8, !tbaa !18
  %4 = load %struct._cl_context** @_ZN6Halide7Runtime8Internal11weak_cl_ctxE, align 8, !tbaa !18
  %cmp26 = icmp eq %struct._cl_context* %3, %4
  br i1 %cmp26, label %if.then27, label %if.end48

if.then27:                                        ; preds = %while.end
  %5 = load %struct._cl_command_queue** @_ZN6Halide7Runtime8Internal9weak_cl_qE, align 8, !tbaa !18
  %call34 = call i32 @clReleaseCommandQueue(%struct._cl_command_queue* %5) #5
  %cmp35 = icmp eq i32 %call34, 0
  br i1 %cmp35, label %if.end37, label %if.then36

if.then36:                                        ; preds = %if.then27
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([18 x i8]* @.str53, i64 0, i64 0)) #5
  br label %if.end37

if.end37:                                         ; preds = %if.then36, %if.then27
  store %struct._cl_command_queue* null, %struct._cl_command_queue** @_ZN6Halide7Runtime8Internal9weak_cl_qE, align 8, !tbaa !18
  %6 = load %struct._cl_context** @_ZN6Halide7Runtime8Internal11weak_cl_ctxE, align 8, !tbaa !18
  %call44 = call i32 @clReleaseContext(%struct._cl_context* %6) #5
  %cmp45 = icmp eq i32 %call44, 0
  br i1 %cmp45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.end37
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([18 x i8]* @.str53, i64 0, i64 0)) #5
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %if.end37
  store %struct._cl_context* null, %struct._cl_context** @_ZN6Halide7Runtime8Internal11weak_cl_ctxE, align 8, !tbaa !18
  br label %if.end48

if.end48:                                         ; preds = %if.end47, %while.end
  %call49 = call i32 @halide_release_cl_context(i8* %user_context) #6
  br label %return

return:                                           ; preds = %if.end48, %entry
  ret void
}

declare i32 @clReleaseProgram(%struct._cl_program*) #0

declare i32 @clReleaseCommandQueue(%struct._cl_command_queue*) #0

declare i32 @clReleaseContext(%struct._cl_context*) #0

; Function Attrs: nounwind uwtable
define weak i32 @halide_dev_malloc(i8* %user_context, %struct.buffer_t* %buf) #1 {
entry:
  %ctx = alloca %"class.Halide::Runtime::Internal::ClContext", align 8
  %err = alloca i32, align 4
  %temp.lvalue = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %user_context2.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 0
  store i8* %user_context, i8** %user_context2.i, align 8, !tbaa !46
  %context.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 1
  %cmd_queue.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 2
  %error.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 3
  %0 = bitcast %struct._cl_context** %context.i to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 20, i32 8, i1 false)
  %call.i170 = call i32 @halide_acquire_cl_context(i8* %user_context, %struct._cl_context** %context.i, %struct._cl_command_queue** %cmd_queue.i) #5
  store i32 %call.i170, i32* %error.i, align 8, !tbaa !48
  %1 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %cmp.i = icmp eq %struct._cl_context* %1, null
  %2 = load %struct._cl_command_queue** %cmd_queue.i, align 8
  %cmp8.i = icmp eq %struct._cl_command_queue* %2, null
  %or.cond171 = or i1 %cmp.i, %cmp8.i
  br i1 %or.cond171, label %if.then.i, label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

if.then.i:                                        ; preds = %entry
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([37 x i8]* @.str151, i64 0, i64 0)) #5
  %.pre = load i32* %error.i, align 8, !tbaa !48
  br label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit:  ; preds = %if.then.i, %entry
  %3 = phi i32 [ %call.i170, %entry ], [ %.pre, %if.then.i ]
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.end, label %cleanup

if.end:                                           ; preds = %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %call = call i64 @_ZN6Halide7Runtime8Internal8buf_sizeEPvP8buffer_t(i8* %user_context, %struct.buffer_t* %buf) #6
  %dev = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 0
  %4 = load i64* %dev, align 8, !tbaa !37
  %tobool = icmp eq i64 %4, 0
  br i1 %tobool, label %if.end14, label %if.then10

if.then10:                                        ; preds = %if.end
  %call11 = call zeroext i1 @_ZN6Halide7Runtime8Internal20validate_dev_pointerEPvP8buffer_tm(i8* %user_context, %struct.buffer_t* %buf, i64 %call) #6
  br i1 %call11, label %cleanup, label %if.then12

if.then12:                                        ; preds = %if.then10
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([46 x i8]* @.str58, i64 0, i64 0)) #5
  br label %cleanup

if.end14:                                         ; preds = %if.end
  %arrayidx = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 0
  %5 = load i32* %arrayidx, align 4, !tbaa !15
  %cmp15 = icmp sgt i32 %5, -1
  br i1 %cmp15, label %land.lhs.true, label %if.then27

land.lhs.true:                                    ; preds = %if.end14
  %arrayidx17 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 1
  %6 = load i32* %arrayidx17, align 4, !tbaa !15
  %cmp18 = icmp sgt i32 %6, -1
  br i1 %cmp18, label %land.lhs.true19, label %if.then27

land.lhs.true19:                                  ; preds = %land.lhs.true
  %arrayidx21 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 2
  %7 = load i32* %arrayidx21, align 4, !tbaa !15
  %cmp22 = icmp sgt i32 %7, -1
  br i1 %cmp22, label %land.lhs.true23, label %if.then27

land.lhs.true23:                                  ; preds = %land.lhs.true19
  %arrayidx25 = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 3, i64 3
  %8 = load i32* %arrayidx25, align 4, !tbaa !15
  %cmp26 = icmp sgt i32 %8, -1
  br i1 %cmp26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %land.lhs.true23, %land.lhs.true19, %land.lhs.true, %if.end14
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([89 x i8]* @.str59, i64 0, i64 0)) #5
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %land.lhs.true23
  %9 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %call94 = call %struct._cl_mem* @clCreateBuffer(%struct._cl_context* %9, i64 1, i64 %call, i8* null, i32* %err) #5
  %10 = ptrtoint %struct._cl_mem* %call94 to i64
  store i64 %10, i64* %dev, align 8, !tbaa !37
  %11 = load i32* %err, align 4, !tbaa !15
  %cmp96 = icmp ne i32 %11, 0
  %cmp98 = icmp eq %struct._cl_mem* %call94, null
  %or.cond = or i1 %cmp98, %cmp96
  br i1 %or.cond, label %if.then99, label %cleanup

if.then99:                                        ; preds = %if.end28
  %call102 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %11) #6
  %dst.i166 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 1
  %arraydecay.i167 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 0
  store i8* %arraydecay.i167, i8** %dst.i166, align 8, !tbaa !42
  %end.i168 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 2
  %add.ptr.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i, i8** %end.i168, align 8, !tbaa !44
  %user_context.i169 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i169, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i, align 1, !tbaa !19
  %call.i165 = call i8* @halide_string_to_string(i8* %arraydecay.i167, i8* %add.ptr.i, i8* getelementptr inbounds ([28 x i8]* @.str68, i64 0, i64 0)) #5
  store i8* %call.i165, i8** %dst.i166, align 8, !tbaa !42
  %12 = load i32* %err, align 4, !tbaa !15
  %call106 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %12) #6
  %13 = load i8** %dst.i166, align 8, !tbaa !42
  %14 = load i8** %end.i168, align 8, !tbaa !44
  %call.i162 = call i8* @halide_string_to_string(i8* %13, i8* %14, i8* %call106) #5
  store i8* %call.i162, i8** %dst.i166, align 8, !tbaa !42
  %15 = load i8** %user_context.i169, align 8, !tbaa !45
  call void @halide_error(i8* %15, i8* %arraydecay.i167) #5
  %16 = load i32* %err, align 4, !tbaa !15
  br label %cleanup

cleanup:                                          ; preds = %if.then99, %if.end28, %if.then12, %if.then10, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %retval.0 = phi i32 [ %16, %if.then99 ], [ %3, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit ], [ 0, %if.then12 ], [ 0, %if.then10 ], [ 0, %if.end28 ]
  %17 = load i8** %user_context2.i, align 8, !tbaa !46
  %call.i = call i32 @halide_release_cl_context(i8* %17) #5
  ret i32 %retval.0
}

declare %struct._cl_mem* @clCreateBuffer(%struct._cl_context*, i64, i64, i8*, i32*) #0

; Function Attrs: nounwind uwtable
define weak i32 @halide_copy_to_dev(i8* %user_context, %struct.buffer_t* %buf) #1 {
entry:
  %ctx = alloca %"class.Halide::Runtime::Internal::ClContext", align 8
  %c = alloca %"struct.Halide::Runtime::Internal::dev_copy", align 8
  %offset = alloca [3 x i64], align 16
  %region = alloca [3 x i64], align 16
  %temp.lvalue = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %call = tail call i32 @halide_dev_malloc(i8* %user_context, %struct.buffer_t* %buf) #6
  %tobool = icmp eq i32 %call, 0
  br i1 %tobool, label %if.end, label %return

if.end:                                           ; preds = %entry
  %user_context2.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 0
  store i8* %user_context, i8** %user_context2.i, align 8, !tbaa !46
  %context.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 1
  %cmd_queue.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 2
  %error.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 3
  %0 = bitcast %struct._cl_context** %context.i to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 20, i32 8, i1 false)
  %call.i155 = call i32 @halide_acquire_cl_context(i8* %user_context, %struct._cl_context** %context.i, %struct._cl_command_queue** %cmd_queue.i) #5
  store i32 %call.i155, i32* %error.i, align 8, !tbaa !48
  %1 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %cmp.i = icmp eq %struct._cl_context* %1, null
  %2 = load %struct._cl_command_queue** %cmd_queue.i, align 8
  %cmp8.i = icmp eq %struct._cl_command_queue* %2, null
  %or.cond = or i1 %cmp.i, %cmp8.i
  br i1 %or.cond, label %if.then.i, label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

if.then.i:                                        ; preds = %if.end
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([37 x i8]* @.str151, i64 0, i64 0)) #5
  %.pre = load i32* %error.i, align 8, !tbaa !48
  br label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit:  ; preds = %if.then.i, %if.end
  %3 = phi i32 [ %call.i155, %if.end ], [ %.pre, %if.then.i ]
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.end11, label %cleanup120

if.end11:                                         ; preds = %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %host_dirty = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 6
  %4 = load i8* %host_dirty, align 1, !tbaa !58, !range !9
  %tobool12 = icmp eq i8 %4, 0
  br i1 %tobool12, label %if.end118, label %if.then13

if.then13:                                        ; preds = %if.end11
  %host = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 1
  %5 = load i8** %host, align 8, !tbaa !22
  %tobool14 = icmp eq i8* %5, null
  br i1 %tobool14, label %if.then16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then13
  %dev = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 0
  %6 = load i64* %dev, align 8, !tbaa !37
  %tobool15 = icmp eq i64 %6, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %land.lhs.true, %if.then13
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([22 x i8]* @.str72, i64 0, i64 0)) #5
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %land.lhs.true
  %call18 = call zeroext i1 @_ZN6Halide7Runtime8Internal20validate_dev_pointerEPvP8buffer_tm(i8* %user_context, %struct.buffer_t* %buf, i64 0) #6
  br i1 %call18, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end17
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([40 x i8]* @.str30, i64 0, i64 0)) #5
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.end17
  %7 = bitcast %"struct.Halide::Runtime::Internal::dev_copy"* %c to i8*
  call void @llvm.lifetime.start(i64 88, i8* %7) #3
  call void @_ZN6Halide7Runtime8Internal21make_host_to_dev_copyEPK8buffer_t(%"struct.Halide::Runtime::Internal::dev_copy"* sret %c, %struct.buffer_t* %buf) #6
  %arrayidx = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 3
  %8 = load i64* %arrayidx, align 8, !tbaa !17
  %cmp21159 = icmp eq i64 %8, 0
  br i1 %cmp21159, label %cleanup.thread, label %for.cond22.preheader.lr.ph

for.cond22.preheader.lr.ph:                       ; preds = %if.end20
  %arrayidx25 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 2
  %arrayidx29 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 2
  %arrayidx32 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 3
  %arrayinit.begin = getelementptr inbounds [3 x i64]* %offset, i64 0, i64 0
  %arrayinit.element = getelementptr inbounds [3 x i64]* %offset, i64 0, i64 1
  %arrayinit.begin35 = getelementptr inbounds [3 x i64]* %region, i64 0, i64 0
  %chunk_size = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 4
  %arrayinit.element36 = getelementptr inbounds [3 x i64]* %region, i64 0, i64 1
  %arrayidx38 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 0
  %src = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 0
  %dst = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 1
  %arrayidx86 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 0
  %arrayidx90 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 1
  %.pre165 = load i64* %arrayidx25, align 8, !tbaa !17
  %9 = bitcast i64* %arrayinit.element to <2 x i64>*
  %10 = bitcast i64* %arrayidx38 to <2 x i64>*
  %11 = bitcast i64* %arrayinit.element36 to <2 x i64>*
  br label %for.cond22.preheader

for.cond22.preheader:                             ; preds = %for.inc113, %for.cond22.preheader.lr.ph
  %12 = phi i64 [ %8, %for.cond22.preheader.lr.ph ], [ %26, %for.inc113 ]
  %13 = phi i64 [ %.pre165, %for.cond22.preheader.lr.ph ], [ %27, %for.inc113 ]
  %indvars.iv163 = phi i64 [ 0, %for.cond22.preheader.lr.ph ], [ %indvars.iv.next164, %for.inc113 ]
  %cmp26156 = icmp eq i64 %13, 0
  br i1 %cmp26156, label %for.inc113, label %for.body27.preheader

for.body27.preheader:                             ; preds = %for.cond22.preheader
  br label %for.body27

for.cond22:                                       ; preds = %for.body27
  %14 = load i64* %arrayidx25, align 8, !tbaa !17
  %cmp26 = icmp ult i64 %indvars.iv.next, %14
  br i1 %cmp26, label %for.body27, label %for.cond22.for.inc113_crit_edge

for.body27:                                       ; preds = %for.body27.preheader, %for.cond22
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond22 ], [ 0, %for.body27.preheader ]
  %15 = load i64* %arrayidx29, align 8, !tbaa !17
  %mul = mul i64 %15, %indvars.iv
  %16 = load i64* %arrayidx32, align 8, !tbaa !17
  %mul33 = mul i64 %16, %indvars.iv163
  %add = add i64 %mul33, %mul
  store i64 %add, i64* %arrayinit.begin, align 16, !tbaa !17
  store <2 x i64> zeroinitializer, <2 x i64>* %9, align 8, !tbaa !17
  %17 = load i64* %chunk_size, align 8, !tbaa !39
  store i64 %17, i64* %arrayinit.begin35, align 16, !tbaa !17
  %18 = load <2 x i64>* %10, align 8, !tbaa !17
  store <2 x i64> %18, <2 x i64>* %11, align 8, !tbaa !17
  %19 = load i64* %src, align 8, !tbaa !35
  %20 = load %struct._cl_command_queue** %cmd_queue.i, align 8, !tbaa !57
  %21 = load i64* %dst, align 8, !tbaa !38
  %22 = inttoptr i64 %21 to %struct._cl_mem*
  %23 = load i64* %arrayidx86, align 8, !tbaa !17
  %24 = load i64* %arrayidx90, align 8, !tbaa !17
  %25 = inttoptr i64 %19 to i8*
  %call106 = call i32 @clEnqueueWriteBufferRect(%struct._cl_command_queue* %20, %struct._cl_mem* %22, i32 0, i64* %arrayinit.begin, i64* %arrayinit.begin, i64* %arrayinit.begin35, i64 %23, i64 %24, i64 %23, i64 %24, i8* %25, i32 0, %struct._cl_event** null, %struct._cl_event** null) #5
  %cmp107 = icmp eq i32 %call106, 0
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br i1 %cmp107, label %for.cond22, label %cleanup

for.cond22.for.inc113_crit_edge:                  ; preds = %for.cond22
  %.lcssa = phi i64 [ %14, %for.cond22 ]
  %.pre166 = load i64* %arrayidx, align 8, !tbaa !17
  br label %for.inc113

for.inc113:                                       ; preds = %for.cond22.for.inc113_crit_edge, %for.cond22.preheader
  %26 = phi i64 [ %12, %for.cond22.preheader ], [ %.pre166, %for.cond22.for.inc113_crit_edge ]
  %27 = phi i64 [ 0, %for.cond22.preheader ], [ %.lcssa, %for.cond22.for.inc113_crit_edge ]
  %indvars.iv.next164 = add nuw nsw i64 %indvars.iv163, 1
  %cmp21 = icmp ult i64 %indvars.iv.next164, %26
  br i1 %cmp21, label %for.cond22.preheader, label %cleanup.thread.loopexit

cleanup.thread.loopexit:                          ; preds = %for.inc113
  br label %cleanup.thread

cleanup.thread:                                   ; preds = %cleanup.thread.loopexit, %if.end20
  %28 = load %struct._cl_command_queue** %cmd_queue.i, align 8, !tbaa !57
  %call117 = call i32 @clFinish(%struct._cl_command_queue* %28) #5
  call void @llvm.lifetime.end(i64 88, i8* %7) #3
  br label %if.end118

cleanup:                                          ; preds = %for.body27
  %call106.lcssa = phi i32 [ %call106, %for.body27 ]
  %dst.i151 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 1
  %arraydecay.i152 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 0
  store i8* %arraydecay.i152, i8** %dst.i151, align 8, !tbaa !42
  %end.i153 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 2
  %add.ptr.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i, i8** %end.i153, align 8, !tbaa !44
  %user_context.i154 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i154, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i, align 1, !tbaa !19
  %call.i150 = call i8* @halide_string_to_string(i8* %arraydecay.i152, i8* %add.ptr.i, i8* getelementptr inbounds ([38 x i8]* @.str80, i64 0, i64 0)) #5
  store i8* %call.i150, i8** %dst.i151, align 8, !tbaa !42
  %call110 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %call106.lcssa) #6
  %29 = load i8** %dst.i151, align 8, !tbaa !42
  %30 = load i8** %end.i153, align 8, !tbaa !44
  %call.i147 = call i8* @halide_string_to_string(i8* %29, i8* %30, i8* %call110) #5
  store i8* %call.i147, i8** %dst.i151, align 8, !tbaa !42
  %31 = load i8** %user_context.i154, align 8, !tbaa !45
  call void @halide_error(i8* %31, i8* %arraydecay.i152) #5
  call void @llvm.lifetime.end(i64 88, i8* %7) #3
  br label %cleanup120

if.end118:                                        ; preds = %cleanup.thread, %if.end11
  store i8 0, i8* %host_dirty, align 1, !tbaa !58
  br label %cleanup120

cleanup120:                                       ; preds = %if.end118, %cleanup, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %retval.1 = phi i32 [ 0, %if.end118 ], [ %call106.lcssa, %cleanup ], [ %3, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit ]
  %32 = load i8** %user_context2.i, align 8, !tbaa !46
  %call.i = call i32 @halide_release_cl_context(i8* %32) #5
  br label %return

return:                                           ; preds = %cleanup120, %entry
  %retval.2 = phi i32 [ %retval.1, %cleanup120 ], [ %call, %entry ]
  ret i32 %retval.2
}

declare i32 @clEnqueueWriteBufferRect(%struct._cl_command_queue*, %struct._cl_mem*, i32, i64*, i64*, i64*, i64, i64, i64, i64, i8*, i32, %struct._cl_event**, %struct._cl_event**) #0

; Function Attrs: nounwind uwtable
define weak i32 @halide_copy_to_host(i8* %user_context, %struct.buffer_t* %buf) #1 {
entry:
  %ctx = alloca %"class.Halide::Runtime::Internal::ClContext", align 8
  %c = alloca %"struct.Halide::Runtime::Internal::dev_copy", align 8
  %offset = alloca [3 x i64], align 16
  %region = alloca [3 x i64], align 16
  %temp.lvalue = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %dev_dirty = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 7
  %0 = load i8* %dev_dirty, align 1, !tbaa !59, !range !9
  %tobool = icmp eq i8 %0, 0
  br i1 %tobool, label %return, label %if.end

if.end:                                           ; preds = %entry
  %user_context2.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 0
  store i8* %user_context, i8** %user_context2.i, align 8, !tbaa !46
  %context.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 1
  %cmd_queue.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 2
  %error.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 3
  %1 = bitcast %struct._cl_context** %context.i to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 20, i32 8, i1 false)
  %call.i152 = call i32 @halide_acquire_cl_context(i8* %user_context, %struct._cl_context** %context.i, %struct._cl_command_queue** %cmd_queue.i) #5
  store i32 %call.i152, i32* %error.i, align 8, !tbaa !48
  %2 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %cmp.i = icmp eq %struct._cl_context* %2, null
  %3 = load %struct._cl_command_queue** %cmd_queue.i, align 8
  %cmp8.i = icmp eq %struct._cl_command_queue* %3, null
  %or.cond = or i1 %cmp.i, %cmp8.i
  br i1 %or.cond, label %if.then.i, label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

if.then.i:                                        ; preds = %if.end
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([37 x i8]* @.str151, i64 0, i64 0)) #5
  %.pre = load i32* %error.i, align 8, !tbaa !48
  br label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit:  ; preds = %if.then.i, %if.end
  %4 = phi i32 [ %call.i152, %if.end ], [ %.pre, %if.then.i ]
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.end11, label %cleanup119

if.end11:                                         ; preds = %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %5 = load i8* %dev_dirty, align 1, !tbaa !59, !range !9
  %tobool13 = icmp eq i8 %5, 0
  br i1 %tobool13, label %if.end117, label %if.then14

if.then14:                                        ; preds = %if.end11
  %host = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 1
  %6 = load i8** %host, align 8, !tbaa !22
  %tobool15 = icmp eq i8* %6, null
  br i1 %tobool15, label %if.then17, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then14
  %dev = getelementptr inbounds %struct.buffer_t* %buf, i64 0, i32 0
  %7 = load i64* %dev, align 8, !tbaa !37
  %tobool16 = icmp eq i64 %7, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %land.lhs.true, %if.then14
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([22 x i8]* @.str72, i64 0, i64 0)) #5
  br label %if.end18

if.end18:                                         ; preds = %if.then17, %land.lhs.true
  %call = call zeroext i1 @_ZN6Halide7Runtime8Internal20validate_dev_pointerEPvP8buffer_tm(i8* %user_context, %struct.buffer_t* %buf, i64 0) #6
  br i1 %call, label %if.end20, label %if.then19

if.then19:                                        ; preds = %if.end18
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([40 x i8]* @.str30, i64 0, i64 0)) #5
  br label %if.end20

if.end20:                                         ; preds = %if.then19, %if.end18
  %8 = bitcast %"struct.Halide::Runtime::Internal::dev_copy"* %c to i8*
  call void @llvm.lifetime.start(i64 88, i8* %8) #3
  call void @_ZN6Halide7Runtime8Internal21make_dev_to_host_copyEPK8buffer_t(%"struct.Halide::Runtime::Internal::dev_copy"* sret %c, %struct.buffer_t* %buf) #6
  %arrayidx = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 3
  %9 = load i64* %arrayidx, align 8, !tbaa !17
  %cmp21156 = icmp eq i64 %9, 0
  br i1 %cmp21156, label %cleanup.thread, label %for.cond22.preheader.lr.ph

for.cond22.preheader.lr.ph:                       ; preds = %if.end20
  %arrayidx25 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 2
  %arrayidx29 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 2
  %arrayidx32 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 3
  %arrayinit.begin = getelementptr inbounds [3 x i64]* %offset, i64 0, i64 0
  %arrayinit.element = getelementptr inbounds [3 x i64]* %offset, i64 0, i64 1
  %arrayinit.begin35 = getelementptr inbounds [3 x i64]* %region, i64 0, i64 0
  %chunk_size = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 4
  %arrayinit.element36 = getelementptr inbounds [3 x i64]* %region, i64 0, i64 1
  %arrayidx38 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 2, i64 0
  %src = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 0
  %dst = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 1
  %arrayidx86 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 0
  %arrayidx90 = getelementptr inbounds %"struct.Halide::Runtime::Internal::dev_copy"* %c, i64 0, i32 3, i64 1
  %.pre162 = load i64* %arrayidx25, align 8, !tbaa !17
  %10 = bitcast i64* %arrayinit.element to <2 x i64>*
  %11 = bitcast i64* %arrayidx38 to <2 x i64>*
  %12 = bitcast i64* %arrayinit.element36 to <2 x i64>*
  br label %for.cond22.preheader

for.cond22.preheader:                             ; preds = %for.inc112, %for.cond22.preheader.lr.ph
  %13 = phi i64 [ %9, %for.cond22.preheader.lr.ph ], [ %27, %for.inc112 ]
  %14 = phi i64 [ %.pre162, %for.cond22.preheader.lr.ph ], [ %28, %for.inc112 ]
  %indvars.iv160 = phi i64 [ 0, %for.cond22.preheader.lr.ph ], [ %indvars.iv.next161, %for.inc112 ]
  %cmp26153 = icmp eq i64 %14, 0
  br i1 %cmp26153, label %for.inc112, label %for.body27.preheader

for.body27.preheader:                             ; preds = %for.cond22.preheader
  br label %for.body27

for.cond22:                                       ; preds = %for.body27
  %15 = load i64* %arrayidx25, align 8, !tbaa !17
  %cmp26 = icmp ult i64 %indvars.iv.next, %15
  br i1 %cmp26, label %for.body27, label %for.cond22.for.inc112_crit_edge

for.body27:                                       ; preds = %for.body27.preheader, %for.cond22
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.cond22 ], [ 0, %for.body27.preheader ]
  %16 = load i64* %arrayidx29, align 8, !tbaa !17
  %mul = mul i64 %16, %indvars.iv
  %17 = load i64* %arrayidx32, align 8, !tbaa !17
  %mul33 = mul i64 %17, %indvars.iv160
  %add = add i64 %mul33, %mul
  store i64 %add, i64* %arrayinit.begin, align 16, !tbaa !17
  store <2 x i64> zeroinitializer, <2 x i64>* %10, align 8, !tbaa !17
  %18 = load i64* %chunk_size, align 8, !tbaa !39
  store i64 %18, i64* %arrayinit.begin35, align 16, !tbaa !17
  %19 = load <2 x i64>* %11, align 8, !tbaa !17
  store <2 x i64> %19, <2 x i64>* %12, align 8, !tbaa !17
  %20 = load i64* %src, align 8, !tbaa !35
  %21 = load i64* %dst, align 8, !tbaa !38
  %22 = load %struct._cl_command_queue** %cmd_queue.i, align 8, !tbaa !57
  %23 = inttoptr i64 %20 to %struct._cl_mem*
  %24 = load i64* %arrayidx86, align 8, !tbaa !17
  %25 = load i64* %arrayidx90, align 8, !tbaa !17
  %26 = inttoptr i64 %21 to i8*
  %call105 = call i32 @clEnqueueReadBufferRect(%struct._cl_command_queue* %22, %struct._cl_mem* %23, i32 0, i64* %arrayinit.begin, i64* %arrayinit.begin, i64* %arrayinit.begin35, i64 %24, i64 %25, i64 %24, i64 %25, i8* %26, i32 0, %struct._cl_event** null, %struct._cl_event** null) #5
  %cmp106 = icmp eq i32 %call105, 0
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  br i1 %cmp106, label %for.cond22, label %cleanup

for.cond22.for.inc112_crit_edge:                  ; preds = %for.cond22
  %.lcssa = phi i64 [ %15, %for.cond22 ]
  %.pre163 = load i64* %arrayidx, align 8, !tbaa !17
  br label %for.inc112

for.inc112:                                       ; preds = %for.cond22.for.inc112_crit_edge, %for.cond22.preheader
  %27 = phi i64 [ %13, %for.cond22.preheader ], [ %.pre163, %for.cond22.for.inc112_crit_edge ]
  %28 = phi i64 [ 0, %for.cond22.preheader ], [ %.lcssa, %for.cond22.for.inc112_crit_edge ]
  %indvars.iv.next161 = add nuw nsw i64 %indvars.iv160, 1
  %cmp21 = icmp ult i64 %indvars.iv.next161, %27
  br i1 %cmp21, label %for.cond22.preheader, label %cleanup.thread.loopexit

cleanup.thread.loopexit:                          ; preds = %for.inc112
  br label %cleanup.thread

cleanup.thread:                                   ; preds = %cleanup.thread.loopexit, %if.end20
  %29 = load %struct._cl_command_queue** %cmd_queue.i, align 8, !tbaa !57
  %call116 = call i32 @clFinish(%struct._cl_command_queue* %29) #5
  call void @llvm.lifetime.end(i64 88, i8* %8) #3
  br label %if.end117

cleanup:                                          ; preds = %for.body27
  %call105.lcssa = phi i32 [ %call105, %for.body27 ]
  %dst.i148 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 1
  %arraydecay.i149 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 0
  store i8* %arraydecay.i149, i8** %dst.i148, align 8, !tbaa !42
  %end.i150 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 2
  %add.ptr.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i, i8** %end.i150, align 8, !tbaa !44
  %user_context.i151 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i151, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i, align 1, !tbaa !19
  %call.i147 = call i8* @halide_string_to_string(i8* %arraydecay.i149, i8* %add.ptr.i, i8* getelementptr inbounds ([37 x i8]* @.str83, i64 0, i64 0)) #5
  store i8* %call.i147, i8** %dst.i148, align 8, !tbaa !42
  %call109 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %call105.lcssa) #6
  %30 = load i8** %dst.i148, align 8, !tbaa !42
  %31 = load i8** %end.i150, align 8, !tbaa !44
  %call.i144 = call i8* @halide_string_to_string(i8* %30, i8* %31, i8* %call109) #5
  store i8* %call.i144, i8** %dst.i148, align 8, !tbaa !42
  %32 = load i8** %user_context.i151, align 8, !tbaa !45
  call void @halide_error(i8* %32, i8* %arraydecay.i149) #5
  call void @llvm.lifetime.end(i64 88, i8* %8) #3
  br label %cleanup119

if.end117:                                        ; preds = %cleanup.thread, %if.end11
  store i8 0, i8* %dev_dirty, align 1, !tbaa !59
  br label %cleanup119

cleanup119:                                       ; preds = %if.end117, %cleanup, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %retval.1 = phi i32 [ 0, %if.end117 ], [ %call105.lcssa, %cleanup ], [ %4, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit ]
  %33 = load i8** %user_context2.i, align 8, !tbaa !46
  %call.i = call i32 @halide_release_cl_context(i8* %33) #5
  br label %return

return:                                           ; preds = %cleanup119, %entry
  %retval.2 = phi i32 [ %retval.1, %cleanup119 ], [ 0, %entry ]
  ret i32 %retval.2
}

declare i32 @clEnqueueReadBufferRect(%struct._cl_command_queue*, %struct._cl_mem*, i32, i64*, i64*, i64*, i64, i64, i64, i64, i8*, i32, %struct._cl_event**, %struct._cl_event**) #0

; Function Attrs: nounwind uwtable
define linkonce i32 @halide_dev_run(i8* %user_context, i8* %state_ptr, i8* %entry_name, i32 %blocksX, i32 %blocksY, i32 %blocksZ, i32 %threadsX, i32 %threadsY, i32 %threadsZ, i32 %shared_mem_bytes, i64* %arg_sizes, i8** %args, i32 %num_attributes, float* %vertex_buffer, i32 %num_coords_dim0, i32 %num_coords_dim1) #1 {
entry:
  %err = alloca i32, align 4
  %ctx = alloca %"class.Halide::Runtime::Internal::ClContext", align 8
  %temp.lvalue = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %global_dim = alloca [3 x i64], align 16
  %local_dim = alloca [3 x i64], align 16
  %temp.lvalue110 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %temp.lvalue130 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %temp.lvalue170 = alloca %"class.Halide::Runtime::Internal::Printer", align 8
  %user_context2.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 0
  store i8* %user_context, i8** %user_context2.i, align 8, !tbaa !46
  %context.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 1
  %cmd_queue.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 2
  %error.i = getelementptr inbounds %"class.Halide::Runtime::Internal::ClContext"* %ctx, i64 0, i32 3
  %0 = bitcast %struct._cl_context** %context.i to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 20, i32 8, i1 false)
  %call.i296 = call i32 @halide_acquire_cl_context(i8* %user_context, %struct._cl_context** %context.i, %struct._cl_command_queue** %cmd_queue.i) #5
  store i32 %call.i296, i32* %error.i, align 8, !tbaa !48
  %1 = load %struct._cl_context** %context.i, align 8, !tbaa !49
  %cmp.i = icmp eq %struct._cl_context* %1, null
  %2 = load %struct._cl_command_queue** %cmd_queue.i, align 8
  %cmp8.i = icmp eq %struct._cl_command_queue* %2, null
  %or.cond = or i1 %cmp.i, %cmp8.i
  br i1 %or.cond, label %if.then.i, label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

if.then.i:                                        ; preds = %entry
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([37 x i8]* @.str151, i64 0, i64 0)) #5
  %.pre = load i32* %error.i, align 8, !tbaa !48
  br label %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit

_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit:  ; preds = %if.then.i, %entry
  %3 = phi i32 [ %call.i296, %entry ], [ %.pre, %if.then.i ]
  %cmp = icmp eq i32 %3, 0
  br i1 %cmp, label %if.end, label %cleanup

if.end:                                           ; preds = %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %tobool = icmp eq i8* %state_ptr, null
  br i1 %tobool, label %if.then46, label %if.end47

if.then46:                                        ; preds = %if.end
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([10 x i8]* @.str89, i64 0, i64 0)) #5
  br label %if.end47

if.end47:                                         ; preds = %if.then46, %if.end
  %program48 = bitcast i8* %state_ptr to %struct._cl_program**
  %4 = load %struct._cl_program** %program48, align 8, !tbaa !50
  %tobool49 = icmp eq %struct._cl_program* %4, null
  br i1 %tobool49, label %if.then50, label %if.end51

if.then50:                                        ; preds = %if.end47
  call void @halide_error(i8* %user_context, i8* getelementptr inbounds ([8 x i8]* @.str90, i64 0, i64 0)) #5
  br label %if.end51

if.end51:                                         ; preds = %if.then50, %if.end47
  %call = call %struct._cl_kernel* @clCreateKernel(%struct._cl_program* %4, i8* %entry_name, i32* %err) #5
  %5 = load i32* %err, align 4, !tbaa !15
  %cmp58 = icmp eq i32 %5, 0
  br i1 %cmp58, label %if.end71, label %if.then59

if.then59:                                        ; preds = %if.end51
  %call62 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %5) #6
  %dst.i291 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 1
  %arraydecay.i292 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 0
  store i8* %arraydecay.i292, i8** %dst.i291, align 8, !tbaa !42
  %end.i293 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 2
  %add.ptr.i294 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i294, i8** %end.i293, align 8, !tbaa !44
  %user_context.i295 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i295, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i294, align 1, !tbaa !19
  %call.i290 = call i8* @halide_string_to_string(i8* %arraydecay.i292, i8* %add.ptr.i294, i8* getelementptr inbounds ([20 x i8]* @.str92, i64 0, i64 0)) #5
  store i8* %call.i290, i8** %dst.i291, align 8, !tbaa !42
  %6 = load i8** %end.i293, align 8, !tbaa !44
  %call.i287 = call i8* @halide_string_to_string(i8* %call.i290, i8* %6, i8* %entry_name) #5
  store i8* %call.i287, i8** %dst.i291, align 8, !tbaa !42
  %7 = load i8** %end.i293, align 8, !tbaa !44
  %call.i284 = call i8* @halide_string_to_string(i8* %call.i287, i8* %7, i8* getelementptr inbounds ([10 x i8]* @.str93, i64 0, i64 0)) #5
  store i8* %call.i284, i8** %dst.i291, align 8, !tbaa !42
  %8 = load i32* %err, align 4, !tbaa !15
  %call68 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %8) #6
  %9 = load i8** %dst.i291, align 8, !tbaa !42
  %10 = load i8** %end.i293, align 8, !tbaa !44
  %call.i281 = call i8* @halide_string_to_string(i8* %9, i8* %10, i8* %call68) #5
  store i8* %call.i281, i8** %dst.i291, align 8, !tbaa !42
  %11 = load i8** %end.i293, align 8, !tbaa !44
  %call.i278 = call i8* @halide_string_to_string(i8* %call.i281, i8* %11, i8* getelementptr inbounds ([2 x i8]* @.str1187, i64 0, i64 0)) #5
  store i8* %call.i278, i8** %dst.i291, align 8, !tbaa !42
  %12 = load i8** %user_context.i295, align 8, !tbaa !45
  call void @halide_error(i8* %12, i8* %arraydecay.i292) #5
  %13 = load i32* %err, align 4, !tbaa !15
  br label %cleanup

if.end71:                                         ; preds = %if.end51
  %arrayinit.begin = getelementptr inbounds [3 x i64]* %global_dim, i64 0, i64 0
  %mul = mul nsw i32 %threadsX, %blocksX
  %conv = sext i32 %mul to i64
  store i64 %conv, i64* %arrayinit.begin, align 16, !tbaa !17
  %arrayinit.element = getelementptr inbounds [3 x i64]* %global_dim, i64 0, i64 1
  %mul72 = mul nsw i32 %threadsY, %blocksY
  %conv73 = sext i32 %mul72 to i64
  store i64 %conv73, i64* %arrayinit.element, align 8, !tbaa !17
  %arrayinit.element74 = getelementptr inbounds [3 x i64]* %global_dim, i64 0, i64 2
  %mul75 = mul nsw i32 %threadsZ, %blocksZ
  %conv76 = sext i32 %mul75 to i64
  store i64 %conv76, i64* %arrayinit.element74, align 16, !tbaa !17
  %arrayinit.begin77 = getelementptr inbounds [3 x i64]* %local_dim, i64 0, i64 0
  %conv78 = sext i32 %threadsX to i64
  store i64 %conv78, i64* %arrayinit.begin77, align 16, !tbaa !17
  %arrayinit.element79 = getelementptr inbounds [3 x i64]* %local_dim, i64 0, i64 1
  %conv80 = sext i32 %threadsY to i64
  store i64 %conv80, i64* %arrayinit.element79, align 8, !tbaa !17
  %arrayinit.element81 = getelementptr inbounds [3 x i64]* %local_dim, i64 0, i64 2
  %conv82 = sext i32 %threadsZ to i64
  store i64 %conv82, i64* %arrayinit.element81, align 16, !tbaa !17
  %14 = load i64* %arg_sizes, align 8, !tbaa !17
  %cmp83298 = icmp eq i64 %14, 0
  br i1 %cmp83298, label %while.end, label %while.body.preheader

while.body.preheader:                             ; preds = %if.end71
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %if.end114
  %indvars.iv = phi i64 [ %indvars.iv.next, %if.end114 ], [ 0, %while.body.preheader ]
  %15 = phi i64 [ %21, %if.end114 ], [ %14, %while.body.preheader ]
  %arrayidx99 = getelementptr inbounds i8** %args, i64 %indvars.iv
  %16 = load i8** %arrayidx99, align 8, !tbaa !18
  %17 = trunc i64 %indvars.iv to i32
  %call107 = call i32 @clSetKernelArg(%struct._cl_kernel* %call, i32 %17, i64 %15, i8* %16) #5
  %cmp108 = icmp eq i32 %call107, 0
  br i1 %cmp108, label %if.end114, label %if.then109

if.then109:                                       ; preds = %while.body
  %call107.lcssa = phi i32 [ %call107, %while.body ]
  %dst.i269 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue110, i64 0, i32 1
  %arraydecay.i270 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue110, i64 0, i32 0, i64 0
  store i8* %arraydecay.i270, i8** %dst.i269, align 8, !tbaa !42
  %end.i271 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue110, i64 0, i32 2
  %add.ptr.i272 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue110, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i272, i8** %end.i271, align 8, !tbaa !44
  %user_context.i273 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue110, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i273, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i272, align 1, !tbaa !19
  %call.i268 = call i8* @halide_string_to_string(i8* %arraydecay.i270, i8* %add.ptr.i272, i8* getelementptr inbounds ([28 x i8]* @.str97, i64 0, i64 0)) #5
  store i8* %call.i268, i8** %dst.i269, align 8, !tbaa !42
  %call112 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %call107.lcssa) #6
  %18 = load i8** %dst.i269, align 8, !tbaa !42
  %19 = load i8** %end.i271, align 8, !tbaa !44
  %call.i265 = call i8* @halide_string_to_string(i8* %18, i8* %19, i8* %call112) #5
  store i8* %call.i265, i8** %dst.i269, align 8, !tbaa !42
  %20 = load i8** %user_context.i273, align 8, !tbaa !45
  call void @halide_error(i8* %20, i8* %arraydecay.i270) #5
  br label %cleanup

if.end114:                                        ; preds = %while.body
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %arrayidx = getelementptr inbounds i64* %arg_sizes, i64 %indvars.iv.next
  %21 = load i64* %arrayidx, align 8, !tbaa !17
  %cmp83 = icmp eq i64 %21, 0
  br i1 %cmp83, label %while.cond.while.end_crit_edge, label %while.body

while.cond.while.end_crit_edge:                   ; preds = %if.end114
  %indvars.iv.next.lcssa = phi i64 [ %indvars.iv.next, %if.end114 ]
  %22 = trunc i64 %indvars.iv.next.lcssa to i32
  br label %while.end

while.end:                                        ; preds = %while.cond.while.end_crit_edge, %if.end71
  %i.0.lcssa = phi i32 [ %22, %while.cond.while.end_crit_edge ], [ 0, %if.end71 ]
  %cmp125 = icmp slt i32 %shared_mem_bytes, 1
  %23 = sext i32 %shared_mem_bytes to i64
  %conv126 = select i1 %cmp125, i64 1, i64 %23
  %call127 = call i32 @clSetKernelArg(%struct._cl_kernel* %call, i32 %i.0.lcssa, i64 %conv126, i8* null) #5
  store i32 %call127, i32* %err, align 4, !tbaa !15
  %cmp128 = icmp eq i32 %call127, 0
  br i1 %cmp128, label %if.end134, label %if.then129

if.then129:                                       ; preds = %while.end
  %dst.i256 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue130, i64 0, i32 1
  %arraydecay.i257 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue130, i64 0, i32 0, i64 0
  store i8* %arraydecay.i257, i8** %dst.i256, align 8, !tbaa !42
  %end.i258 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue130, i64 0, i32 2
  %add.ptr.i259 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue130, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i259, i8** %end.i258, align 8, !tbaa !44
  %user_context.i260 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue130, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i260, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i259, align 1, !tbaa !19
  %call.i255 = call i8* @halide_string_to_string(i8* %arraydecay.i257, i8* %add.ptr.i259, i8* getelementptr inbounds ([27 x i8]* @.str99, i64 0, i64 0)) #5
  store i8* %call.i255, i8** %dst.i256, align 8, !tbaa !42
  %24 = load i32* %err, align 4, !tbaa !15
  %call132 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %24) #6
  %25 = load i8** %dst.i256, align 8, !tbaa !42
  %26 = load i8** %end.i258, align 8, !tbaa !44
  %call.i252 = call i8* @halide_string_to_string(i8* %25, i8* %26, i8* %call132) #5
  store i8* %call.i252, i8** %dst.i256, align 8, !tbaa !42
  %27 = load i8** %user_context.i260, align 8, !tbaa !45
  call void @halide_error(i8* %27, i8* %arraydecay.i257) #5
  %28 = load i32* %err, align 4, !tbaa !15
  br label %cleanup

if.end134:                                        ; preds = %while.end
  %29 = load %struct._cl_command_queue** %cmd_queue.i, align 8, !tbaa !57
  %call162 = call i32 @clEnqueueNDRangeKernel(%struct._cl_command_queue* %29, %struct._cl_kernel* %call, i32 3, i64* null, i64* %arrayinit.begin, i64* %arrayinit.begin77, i32 0, %struct._cl_event** null, %struct._cl_event** null) #5
  store i32 %call162, i32* %err, align 4, !tbaa !15
  %call165 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %call162) #6
  %30 = load i32* %err, align 4, !tbaa !15
  %cmp168 = icmp eq i32 %30, 0
  br i1 %cmp168, label %if.end175, label %if.then169

if.then169:                                       ; preds = %if.end134
  %dst.i244 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue170, i64 0, i32 1
  %arraydecay.i245 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue170, i64 0, i32 0, i64 0
  store i8* %arraydecay.i245, i8** %dst.i244, align 8, !tbaa !42
  %end.i246 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue170, i64 0, i32 2
  %add.ptr.i = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue170, i64 0, i32 0, i64 1023
  store i8* %add.ptr.i, i8** %end.i246, align 8, !tbaa !44
  %user_context.i247 = getelementptr inbounds %"class.Halide::Runtime::Internal::Printer"* %temp.lvalue170, i64 0, i32 3
  store i8* %user_context, i8** %user_context.i247, align 8, !tbaa !45
  store i8 0, i8* %add.ptr.i, align 1, !tbaa !19
  %call.i243 = call i8* @halide_string_to_string(i8* %arraydecay.i245, i8* %add.ptr.i, i8* getelementptr inbounds ([36 x i8]* @.str101, i64 0, i64 0)) #5
  store i8* %call.i243, i8** %dst.i244, align 8, !tbaa !42
  %31 = load i32* %err, align 4, !tbaa !15
  %call172 = call i8* @_ZN6Halide7Runtime8Internal21get_opencl_error_nameEi(i32 %31) #6
  %32 = load i8** %dst.i244, align 8, !tbaa !42
  %33 = load i8** %end.i246, align 8, !tbaa !44
  %call.i240 = call i8* @halide_string_to_string(i8* %32, i8* %33, i8* %call172) #5
  store i8* %call.i240, i8** %dst.i244, align 8, !tbaa !42
  %34 = load i8** %end.i246, align 8, !tbaa !44
  %call.i237 = call i8* @halide_string_to_string(i8* %call.i240, i8* %34, i8* getelementptr inbounds ([2 x i8]* @.str1187, i64 0, i64 0)) #5
  store i8* %call.i237, i8** %dst.i244, align 8, !tbaa !42
  %35 = load i8** %user_context.i247, align 8, !tbaa !45
  call void @halide_error(i8* %35, i8* %arraydecay.i245) #5
  %36 = load i32* %err, align 4, !tbaa !15
  br label %cleanup

if.end175:                                        ; preds = %if.end134
  %call182 = call i32 @clReleaseKernel(%struct._cl_kernel* %call) #5
  br label %cleanup

cleanup:                                          ; preds = %if.end175, %if.then169, %if.then129, %if.then109, %if.then59, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit
  %retval.0 = phi i32 [ %13, %if.then59 ], [ %call107.lcssa, %if.then109 ], [ %28, %if.then129 ], [ %36, %if.then169 ], [ 0, %if.end175 ], [ %3, %_ZN6Halide7Runtime8Internal9ClContextC2EPv.exit ]
  %37 = load i8** %user_context2.i, align 8, !tbaa !46
  %call.i = call i32 @halide_release_cl_context(i8* %37) #5
  ret i32 %retval.0
}

declare %struct._cl_kernel* @clCreateKernel(%struct._cl_program*, i8*, i32*) #0

declare i32 @clSetKernelArg(%struct._cl_kernel*, i32, i64, i8*) #0

declare i32 @clEnqueueNDRangeKernel(%struct._cl_command_queue*, %struct._cl_kernel*, i32, i64*, i64*, i64*, i32, %struct._cl_event**, %struct._cl_event**) #0

declare i32 @clReleaseKernel(%struct._cl_kernel*) #0

; Function Attrs: nounwind
define i32 @gaussinBlur_gpu(%struct.buffer_t* noalias %input.buffer, %struct.buffer_t* noalias %output.buffer) #3 {
init_kernels:
  %0 = tail call i32 @halide_init_kernels(i8* null, i8** @module_state, i8* getelementptr inbounds ([5325 x i8]* @halide_kernel_src, i64 0, i64 0), i32 5325)
  %1 = icmp eq i32 %0, 0
  br i1 %1, label %"assert succeeded200", label %"assert failed199", !prof !60

"assert failed":                                  ; preds = %"assert succeeded200"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([30 x i8]* @str, i64 0, i64 0))
  ret i32 -1

"assert succeeded":                               ; preds = %"assert succeeded200"
  %buf_dev = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 0
  %input.dev = load i64* %buf_dev, align 8
  %2 = icmp eq i64 %input.dev, 0
  %3 = icmp eq i8* %input.host, null
  %input.host_and_dev_are_null = and i1 %3, %2
  %buf_extent = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 2, i64 0
  %input.extent.0 = load i32* %buf_extent, align 4
  %buf_extent1 = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 2, i64 1
  %input.extent.1 = load i32* %buf_extent1, align 4
  %buf_stride = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 3, i64 0
  %input.stride.0 = load i32* %buf_stride, align 4
  %buf_stride4 = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 3, i64 1
  %input.stride.1 = load i32* %buf_stride4, align 4
  %buf_min = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 4, i64 0
  %input.min.0 = load i32* %buf_min, align 4
  %buf_min7 = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 4, i64 1
  %input.min.1 = load i32* %buf_min7, align 4
  %buf_elem_size = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 5
  %input.elem_size = load i32* %buf_elem_size, align 4
  %4 = icmp eq %struct.buffer_t* %output.buffer, null
  br i1 %4, label %"assert failed12", label %"assert succeeded13", !prof !61

"assert failed12":                                ; preds = %"assert succeeded"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([31 x i8]* @str90, i64 0, i64 0))
  ret i32 -1

"assert succeeded13":                             ; preds = %"assert succeeded"
  %buf_dev11 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 0
  %output.dev = load i64* %buf_dev11, align 8
  %buf_host10 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 1
  %output.host = load i8** %buf_host10, align 8
  %5 = icmp eq i64 %output.dev, 0
  %6 = icmp eq i8* %output.host, null
  %output.host_and_dev_are_null = and i1 %5, %6
  %buf_extent16 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 2, i64 0
  %output.extent.0 = load i32* %buf_extent16, align 4
  %buf_extent17 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 2, i64 1
  %output.extent.1 = load i32* %buf_extent17, align 4
  %buf_stride20 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 3, i64 0
  %output.stride.0 = load i32* %buf_stride20, align 4
  %buf_stride21 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 3, i64 1
  %output.stride.1 = load i32* %buf_stride21, align 4
  %buf_min24 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 4, i64 0
  %output.min.0 = load i32* %buf_min24, align 4
  %buf_min25 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 4, i64 1
  %output.min.1 = load i32* %buf_min25, align 4
  %buf_elem_size28 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 5
  %output.elem_size = load i32* %buf_elem_size28, align 4
  %i0.host = load i8** getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 1), align 8
  %i0.dev = load i64* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 0), align 16
  %7 = icmp eq i64 %i0.dev, 0
  %8 = icmp eq i8* %i0.host, null
  %i0.host_and_dev_are_null = and i1 %8, %7
  %i0.extent.0 = load i64* bitcast (i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 2, i64 0) to i64*), align 16
  %9 = trunc i64 %i0.extent.0 to i32
  %10 = lshr i64 %i0.extent.0, 32
  %11 = trunc i64 %10 to i32
  %i0.stride.0 = load i64* bitcast (i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 3, i64 0) to i64*), align 16
  %12 = trunc i64 %i0.stride.0 to i32
  %i0.min.0 = load i64* bitcast (i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 4, i64 0) to i64*), align 16
  %13 = trunc i64 %i0.min.0 to i32
  %14 = lshr i64 %i0.min.0, 32
  %15 = trunc i64 %14 to i32
  %i0.elem_size = load i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 5), align 16
  %16 = add nsw i32 %output.min.0, -2
  %17 = add i32 %input.extent.0, -1
  %18 = icmp slt i32 %16, %17
  %19 = select i1 %18, i32 %16, i32 %17
  %20 = icmp slt i32 %19, 0
  %21 = select i1 %20, i32 0, i32 %19
  %22 = add nsw i32 %output.min.0, %output.extent.0
  %23 = add nsw i32 %22, 1
  %24 = icmp slt i32 %23, %17
  %25 = select i1 %24, i32 %23, i32 %17
  %26 = icmp slt i32 %25, 0
  %27 = select i1 %26, i32 0, i32 %25
  %input.extent.0.required.s = sub nsw i32 %27, %21
  %28 = add nsw i32 %output.min.1, -2
  %29 = add i32 %input.extent.1, -1
  %30 = icmp slt i32 %28, %29
  %31 = select i1 %30, i32 %28, i32 %29
  %32 = icmp slt i32 %31, 0
  %33 = select i1 %32, i32 0, i32 %31
  %34 = add nsw i32 %output.min.1, %output.extent.1
  %35 = add nsw i32 %34, 1
  %36 = icmp slt i32 %35, %29
  %37 = select i1 %36, i32 %35, i32 %29
  %38 = icmp slt i32 %37, 0
  %39 = select i1 %38, i32 0, i32 %37
  %40 = add nsw i32 %22, -16
  %41 = icmp slt i32 %output.min.0, %40
  %42 = select i1 %41, i32 %output.min.0, i32 %40
  %43 = add nsw i32 %output.extent.0, -1
  %44 = or i32 %43, 15
  %45 = add i32 %44, %output.min.0
  %46 = add nsw i32 %22, -1
  %47 = icmp slt i32 %45, %46
  %48 = select i1 %47, i32 %45, i32 %46
  %output.extent.0.required.s = sub nsw i32 %48, %42
  %49 = add nsw i32 %34, -16
  %50 = icmp slt i32 %output.min.1, %49
  %51 = select i1 %50, i32 %output.min.1, i32 %49
  %52 = add nsw i32 %output.extent.1, -1
  %53 = or i32 %52, 15
  %54 = add i32 %53, %output.min.1
  %55 = add nsw i32 %34, -1
  %56 = icmp slt i32 %54, %55
  %57 = select i1 %56, i32 %54, i32 %55
  br i1 %i0.host_and_dev_are_null, label %true_bb, label %after_bb

true_bb:                                          ; preds = %"assert succeeded13"
  store i32 2, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 5), align 16
  store i32 0, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 4, i64 0), align 16
  store i32 5, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 2, i64 0), align 16
  store i32 1, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 3, i64 0), align 16
  store i32 0, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 4, i64 1), align 4
  store i32 5, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 2, i64 1), align 4
  store i32 5, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 3, i64 1), align 4
  store i32 0, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 4, i64 2), align 8
  store i32 0, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 2, i64 2), align 8
  store i32 0, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 3, i64 2), align 8
  store i32 0, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 4, i64 3), align 4
  store i32 0, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 2, i64 3), align 4
  store i32 0, i32* getelementptr inbounds (%struct.buffer_t* @i0.buffer, i64 0, i32 3, i64 3), align 4
  br label %after_bb

after_bb:                                         ; preds = %"assert succeeded13", %true_bb
  br i1 %input.host_and_dev_are_null, label %true_bb43, label %after_bb45

true_bb43:                                        ; preds = %after_bb
  store i32 2, i32* %buf_elem_size, align 4
  store i32 %21, i32* %buf_min, align 4
  %58 = add nsw i32 %input.extent.0.required.s, 1
  store i32 %58, i32* %buf_extent, align 4
  store i32 1, i32* %buf_stride, align 4
  store i32 %33, i32* %buf_min7, align 4
  %input.extent.1.required.s = sub i32 1, %33
  %59 = add i32 %input.extent.1.required.s, %39
  store i32 %59, i32* %buf_extent1, align 4
  store i32 %58, i32* %buf_stride4, align 4
  %buf_min53 = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 4, i64 2
  store i32 0, i32* %buf_min53, align 4
  %buf_extent54 = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 2, i64 2
  store i32 0, i32* %buf_extent54, align 4
  %buf_stride55 = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 3, i64 2
  store i32 0, i32* %buf_stride55, align 4
  %buf_min56 = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 4, i64 3
  store i32 0, i32* %buf_min56, align 4
  %buf_extent57 = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 2, i64 3
  store i32 0, i32* %buf_extent57, align 4
  %buf_stride58 = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 3, i64 3
  store i32 0, i32* %buf_stride58, align 4
  br label %after_bb45

after_bb45:                                       ; preds = %after_bb, %true_bb43
  br i1 %output.host_and_dev_are_null, label %after_bb61.thread, label %after_bb61

after_bb61.thread:                                ; preds = %after_bb45
  store i32 2, i32* %buf_elem_size28, align 4
  store i32 %42, i32* %buf_min24, align 4
  %60 = add nsw i32 %output.extent.0.required.s, 1
  store i32 %60, i32* %buf_extent16, align 4
  store i32 1, i32* %buf_stride20, align 4
  store i32 %51, i32* %buf_min25, align 4
  %output.extent.1.required.s = sub i32 1, %51
  %61 = add i32 %output.extent.1.required.s, %57
  store i32 %61, i32* %buf_extent17, align 4
  store i32 %60, i32* %buf_stride21, align 4
  %buf_min69 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 4, i64 2
  store i32 0, i32* %buf_min69, align 4
  %buf_extent70 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 2, i64 2
  store i32 0, i32* %buf_extent70, align 4
  %buf_stride71 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 3, i64 2
  store i32 0, i32* %buf_stride71, align 4
  %buf_min72 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 4, i64 3
  store i32 0, i32* %buf_min72, align 4
  %buf_extent73 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 2, i64 3
  store i32 0, i32* %buf_extent73, align 4
  %buf_stride74 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 3, i64 3
  store i32 0, i32* %buf_stride74, align 4
  br label %after_bb77

after_bb61:                                       ; preds = %after_bb45
  %62 = or i1 %input.host_and_dev_are_null, %i0.host_and_dev_are_null
  br i1 %62, label %after_bb77, label %true_bb75

true_bb75:                                        ; preds = %after_bb61
  %63 = icmp eq i32 %i0.elem_size, 2
  br i1 %63, label %"assert succeeded79", label %"assert failed78", !prof !60

after_bb77:                                       ; preds = %after_bb61.thread, %after_bb61, %"assert succeeded197"
  ret i32 0

"assert failed78":                                ; preds = %true_bb75
  %64 = getelementptr [112 x i8]* %449, i64 0, i64 112
  %65 = call i8* @halide_string_to_string(i8* %.sub218, i8* %64, i8* getelementptr inbounds ([77 x i8]* @str93, i64 0, i64 0))
  %66 = sext i32 %i0.elem_size to i64
  %67 = call i8* @halide_int64_to_string(i8* %65, i8* %64, i64 %66, i32 1)
  %68 = call i8* @halide_string_to_string(i8* %67, i8* %64, i8* getelementptr inbounds ([14 x i8]* @str94, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub218)
  ret i32 -1

"assert succeeded79":                             ; preds = %true_bb75
  %69 = icmp eq i32 %input.elem_size, 2
  br i1 %69, label %"assert succeeded81", label %"assert failed80", !prof !60

"assert failed80":                                ; preds = %"assert succeeded79"
  %70 = getelementptr [112 x i8]* %448, i64 0, i64 112
  %71 = call i8* @halide_string_to_string(i8* %.sub217, i8* %70, i8* getelementptr inbounds ([80 x i8]* @str95, i64 0, i64 0))
  %72 = sext i32 %input.elem_size to i64
  %73 = call i8* @halide_int64_to_string(i8* %71, i8* %70, i64 %72, i32 1)
  %74 = call i8* @halide_string_to_string(i8* %73, i8* %70, i8* getelementptr inbounds ([14 x i8]* @str94, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub217)
  ret i32 -1

"assert succeeded81":                             ; preds = %"assert succeeded79"
  %75 = icmp eq i32 %output.elem_size, 2
  br i1 %75, label %"assert succeeded83", label %"assert failed82", !prof !60

"assert failed82":                                ; preds = %"assert succeeded81"
  %76 = getelementptr [128 x i8]* %447, i64 0, i64 128
  %77 = call i8* @halide_string_to_string(i8* %.sub216, i8* %76, i8* getelementptr inbounds ([82 x i8]* @str96, i64 0, i64 0))
  %78 = sext i32 %output.elem_size to i64
  %79 = call i8* @halide_int64_to_string(i8* %77, i8* %76, i64 %78, i32 1)
  %80 = call i8* @halide_string_to_string(i8* %79, i8* %76, i8* getelementptr inbounds ([14 x i8]* @str94, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub216)
  ret i32 -1

"assert succeeded83":                             ; preds = %"assert succeeded81"
  %81 = icmp slt i32 %13, 1
  br i1 %81, label %"assert succeeded85", label %"assert failed84", !prof !60

"assert failed84":                                ; preds = %"assert succeeded83"
  %82 = getelementptr [96 x i8]* %446, i64 0, i64 96
  %83 = call i8* @halide_string_to_string(i8* %.sub215, i8* %82, i8* getelementptr inbounds ([60 x i8]* @str97, i64 0, i64 0))
  %sext = shl i64 %i0.min.0, 32
  %84 = ashr exact i64 %sext, 32
  %85 = call i8* @halide_int64_to_string(i8* %83, i8* %82, i64 %84, i32 1)
  %86 = call i8* @halide_string_to_string(i8* %85, i8* %82, i8* getelementptr inbounds ([17 x i8]* @str98, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub215)
  ret i32 -1

"assert succeeded85":                             ; preds = %"assert succeeded83"
  %87 = sub nsw i32 5, %9
  %88 = icmp sgt i32 %87, %13
  br i1 %88, label %"assert failed86", label %"assert succeeded87", !prof !61

"assert failed86":                                ; preds = %"assert succeeded85"
  %89 = getelementptr [96 x i8]* %445, i64 0, i64 96
  %90 = call i8* @halide_string_to_string(i8* %.sub214, i8* %89, i8* getelementptr inbounds ([60 x i8]* @str99, i64 0, i64 0))
  %91 = add i64 %i0.extent.0, 4294967295
  %92 = add i64 %91, %i0.min.0
  %sext235 = shl i64 %92, 32
  %93 = ashr exact i64 %sext235, 32
  %94 = call i8* @halide_int64_to_string(i8* %90, i8* %89, i64 %93, i32 1)
  %95 = call i8* @halide_string_to_string(i8* %94, i8* %89, i8* getelementptr inbounds ([17 x i8]* @str98, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub214)
  ret i32 -1

"assert succeeded87":                             ; preds = %"assert succeeded85"
  %96 = icmp slt i32 %15, 1
  br i1 %96, label %"assert succeeded89", label %"assert failed88", !prof !60

"assert failed88":                                ; preds = %"assert succeeded87"
  %97 = getelementptr [96 x i8]* %444, i64 0, i64 96
  %98 = call i8* @halide_string_to_string(i8* %.sub213, i8* %97, i8* getelementptr inbounds ([60 x i8]* @str97, i64 0, i64 0))
  %99 = ashr i64 %i0.min.0, 32
  %100 = call i8* @halide_int64_to_string(i8* %98, i8* %97, i64 %99, i32 1)
  %101 = call i8* @halide_string_to_string(i8* %100, i8* %97, i8* getelementptr inbounds ([17 x i8]* @str100, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub213)
  ret i32 -1

"assert succeeded89":                             ; preds = %"assert succeeded87"
  %102 = sub nsw i32 5, %11
  %103 = icmp sgt i32 %102, %15
  br i1 %103, label %"assert failed90", label %"assert succeeded91", !prof !61

"assert failed90":                                ; preds = %"assert succeeded89"
  %104 = getelementptr [96 x i8]* %443, i64 0, i64 96
  %105 = call i8* @halide_string_to_string(i8* %.sub212, i8* %104, i8* getelementptr inbounds ([60 x i8]* @str99, i64 0, i64 0))
  %106 = add nuw nsw i64 %10, 4294967295
  %107 = add nuw nsw i64 %106, %14
  %sext234 = shl i64 %107, 32
  %108 = ashr exact i64 %sext234, 32
  %109 = call i8* @halide_int64_to_string(i8* %105, i8* %104, i64 %108, i32 1)
  %110 = call i8* @halide_string_to_string(i8* %109, i8* %104, i8* getelementptr inbounds ([17 x i8]* @str100, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub212)
  ret i32 -1

"assert succeeded91":                             ; preds = %"assert succeeded89"
  %111 = icmp sgt i32 %input.min.0, %21
  br i1 %111, label %"assert failed92", label %"assert succeeded93", !prof !61

"assert failed92":                                ; preds = %"assert succeeded91"
  %112 = getelementptr [128 x i8]* %442, i64 0, i64 128
  %113 = call i8* @halide_string_to_string(i8* %.sub211, i8* %112, i8* getelementptr inbounds ([35 x i8]* @str101, i64 0, i64 0))
  %114 = sext i32 %19 to i64
  %115 = select i1 %20, i64 0, i64 %114
  %116 = call i8* @halide_int64_to_string(i8* %113, i8* %112, i64 %115, i32 1)
  %117 = call i8* @halide_string_to_string(i8* %116, i8* %112, i8* getelementptr inbounds ([28 x i8]* @str102, i64 0, i64 0))
  %118 = sext i32 %input.min.0 to i64
  %119 = call i8* @halide_int64_to_string(i8* %117, i8* %112, i64 %118, i32 1)
  %120 = call i8* @halide_string_to_string(i8* %119, i8* %112, i8* getelementptr inbounds ([17 x i8]* @str98, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub211)
  ret i32 -1

"assert succeeded93":                             ; preds = %"assert succeeded91"
  %121 = sub nsw i32 %27, %input.extent.0
  %122 = icmp slt i32 %121, %input.min.0
  br i1 %122, label %"assert succeeded95", label %"assert failed94", !prof !60

"assert failed94":                                ; preds = %"assert succeeded93"
  %123 = getelementptr [128 x i8]* %441, i64 0, i64 128
  %124 = call i8* @halide_string_to_string(i8* %.sub210, i8* %123, i8* getelementptr inbounds ([35 x i8]* @str101, i64 0, i64 0))
  %125 = sext i32 %27 to i64
  %126 = call i8* @halide_int64_to_string(i8* %124, i8* %123, i64 %125, i32 1)
  %127 = call i8* @halide_string_to_string(i8* %126, i8* %123, i8* getelementptr inbounds ([28 x i8]* @str103, i64 0, i64 0))
  %128 = add i32 %17, %input.min.0
  %129 = sext i32 %128 to i64
  %130 = call i8* @halide_int64_to_string(i8* %127, i8* %123, i64 %129, i32 1)
  %131 = call i8* @halide_string_to_string(i8* %130, i8* %123, i8* getelementptr inbounds ([17 x i8]* @str98, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub210)
  ret i32 -1

"assert succeeded95":                             ; preds = %"assert succeeded93"
  %132 = icmp sgt i32 %input.min.1, %33
  br i1 %132, label %"assert failed96", label %"assert succeeded97", !prof !61

"assert failed96":                                ; preds = %"assert succeeded95"
  %133 = getelementptr [128 x i8]* %440, i64 0, i64 128
  %134 = call i8* @halide_string_to_string(i8* %.sub209, i8* %133, i8* getelementptr inbounds ([35 x i8]* @str101, i64 0, i64 0))
  %135 = sext i32 %31 to i64
  %136 = select i1 %32, i64 0, i64 %135
  %137 = call i8* @halide_int64_to_string(i8* %134, i8* %133, i64 %136, i32 1)
  %138 = call i8* @halide_string_to_string(i8* %137, i8* %133, i8* getelementptr inbounds ([28 x i8]* @str102, i64 0, i64 0))
  %139 = sext i32 %input.min.1 to i64
  %140 = call i8* @halide_int64_to_string(i8* %138, i8* %133, i64 %139, i32 1)
  %141 = call i8* @halide_string_to_string(i8* %140, i8* %133, i8* getelementptr inbounds ([17 x i8]* @str100, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub209)
  ret i32 -1

"assert succeeded97":                             ; preds = %"assert succeeded95"
  %142 = sub nsw i32 %39, %input.extent.1
  %143 = icmp slt i32 %142, %input.min.1
  br i1 %143, label %"assert succeeded99", label %"assert failed98", !prof !60

"assert failed98":                                ; preds = %"assert succeeded97"
  %144 = getelementptr [128 x i8]* %439, i64 0, i64 128
  %145 = call i8* @halide_string_to_string(i8* %.sub208, i8* %144, i8* getelementptr inbounds ([35 x i8]* @str101, i64 0, i64 0))
  %146 = sext i32 %39 to i64
  %147 = call i8* @halide_int64_to_string(i8* %145, i8* %144, i64 %146, i32 1)
  %148 = call i8* @halide_string_to_string(i8* %147, i8* %144, i8* getelementptr inbounds ([28 x i8]* @str103, i64 0, i64 0))
  %149 = add i32 %29, %input.min.1
  %150 = sext i32 %149 to i64
  %151 = call i8* @halide_int64_to_string(i8* %148, i8* %144, i64 %150, i32 1)
  %152 = call i8* @halide_string_to_string(i8* %151, i8* %144, i8* getelementptr inbounds ([17 x i8]* @str100, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub208)
  ret i32 -1

"assert succeeded99":                             ; preds = %"assert succeeded97"
  %153 = icmp sgt i32 %output.min.0, %42
  br i1 %153, label %"assert failed100", label %"assert succeeded101", !prof !61

"assert failed100":                               ; preds = %"assert succeeded99"
  %154 = getelementptr [128 x i8]* %438, i64 0, i64 128
  %155 = call i8* @halide_string_to_string(i8* %.sub207, i8* %154, i8* getelementptr inbounds ([37 x i8]* @str104, i64 0, i64 0))
  %156 = sext i32 %42 to i64
  %157 = call i8* @halide_int64_to_string(i8* %155, i8* %154, i64 %156, i32 1)
  %158 = call i8* @halide_string_to_string(i8* %157, i8* %154, i8* getelementptr inbounds ([28 x i8]* @str102, i64 0, i64 0))
  %159 = sext i32 %output.min.0 to i64
  %160 = call i8* @halide_int64_to_string(i8* %158, i8* %154, i64 %159, i32 1)
  %161 = call i8* @halide_string_to_string(i8* %160, i8* %154, i8* getelementptr inbounds ([17 x i8]* @str98, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub207)
  ret i32 -1

"assert succeeded101":                            ; preds = %"assert succeeded99"
  %162 = sub nsw i32 %48, %output.extent.0
  %163 = icmp slt i32 %162, %output.min.0
  br i1 %163, label %"assert succeeded103", label %"assert failed102", !prof !60

"assert failed102":                               ; preds = %"assert succeeded101"
  %164 = getelementptr [128 x i8]* %437, i64 0, i64 128
  %165 = call i8* @halide_string_to_string(i8* %.sub206, i8* %164, i8* getelementptr inbounds ([37 x i8]* @str104, i64 0, i64 0))
  %166 = sext i32 %48 to i64
  %167 = call i8* @halide_int64_to_string(i8* %165, i8* %164, i64 %166, i32 1)
  %168 = call i8* @halide_string_to_string(i8* %167, i8* %164, i8* getelementptr inbounds ([28 x i8]* @str103, i64 0, i64 0))
  %169 = sext i32 %46 to i64
  %170 = call i8* @halide_int64_to_string(i8* %168, i8* %164, i64 %169, i32 1)
  %171 = call i8* @halide_string_to_string(i8* %170, i8* %164, i8* getelementptr inbounds ([17 x i8]* @str98, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub206)
  ret i32 -1

"assert succeeded103":                            ; preds = %"assert succeeded101"
  %172 = icmp sgt i32 %output.min.1, %51
  br i1 %172, label %"assert failed104", label %"assert succeeded105", !prof !61

"assert failed104":                               ; preds = %"assert succeeded103"
  %173 = getelementptr [128 x i8]* %436, i64 0, i64 128
  %174 = call i8* @halide_string_to_string(i8* %.sub205, i8* %173, i8* getelementptr inbounds ([37 x i8]* @str104, i64 0, i64 0))
  %175 = sext i32 %51 to i64
  %176 = call i8* @halide_int64_to_string(i8* %174, i8* %173, i64 %175, i32 1)
  %177 = call i8* @halide_string_to_string(i8* %176, i8* %173, i8* getelementptr inbounds ([28 x i8]* @str102, i64 0, i64 0))
  %178 = sext i32 %output.min.1 to i64
  %179 = call i8* @halide_int64_to_string(i8* %177, i8* %173, i64 %178, i32 1)
  %180 = call i8* @halide_string_to_string(i8* %179, i8* %173, i8* getelementptr inbounds ([17 x i8]* @str100, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub205)
  ret i32 -1

"assert succeeded105":                            ; preds = %"assert succeeded103"
  %181 = sub nsw i32 %57, %output.extent.1
  %182 = icmp slt i32 %181, %output.min.1
  br i1 %182, label %"assert succeeded107", label %"assert failed106", !prof !60

"assert failed106":                               ; preds = %"assert succeeded105"
  %183 = getelementptr [128 x i8]* %435, i64 0, i64 128
  %184 = call i8* @halide_string_to_string(i8* %.sub, i8* %183, i8* getelementptr inbounds ([37 x i8]* @str104, i64 0, i64 0))
  %185 = sext i32 %57 to i64
  %186 = call i8* @halide_int64_to_string(i8* %184, i8* %183, i64 %185, i32 1)
  %187 = call i8* @halide_string_to_string(i8* %186, i8* %183, i8* getelementptr inbounds ([28 x i8]* @str103, i64 0, i64 0))
  %188 = sext i32 %55 to i64
  %189 = call i8* @halide_int64_to_string(i8* %187, i8* %183, i64 %188, i32 1)
  %190 = call i8* @halide_string_to_string(i8* %189, i8* %183, i8* getelementptr inbounds ([17 x i8]* @str100, i64 0, i64 0))
  call void @halide_error(i8* null, i8* %.sub)
  ret i32 -1

"assert succeeded107":                            ; preds = %"assert succeeded105"
  %191 = icmp eq i32 %12, 1
  br i1 %191, label %"assert succeeded109", label %"assert failed108", !prof !60

"assert failed108":                               ; preds = %"assert succeeded107"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([45 x i8]* @str105, i64 0, i64 0))
  ret i32 -1

"assert succeeded109":                            ; preds = %"assert succeeded107"
  %192 = icmp eq i32 %13, 0
  br i1 %192, label %"assert succeeded111", label %"assert failed110", !prof !60

"assert failed110":                               ; preds = %"assert succeeded109"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([42 x i8]* @str106, i64 0, i64 0))
  ret i32 -1

"assert succeeded111":                            ; preds = %"assert succeeded109"
  %193 = icmp eq i32 %9, 5
  br i1 %193, label %"assert succeeded113", label %"assert failed112", !prof !60

"assert failed112":                               ; preds = %"assert succeeded111"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([45 x i8]* @str107, i64 0, i64 0))
  ret i32 -1

"assert succeeded113":                            ; preds = %"assert succeeded111"
  %.mask = and i64 %i0.stride.0, -4294967296
  %194 = icmp eq i64 %.mask, 21474836480
  br i1 %194, label %"assert succeeded115", label %"assert failed114", !prof !60

"assert failed114":                               ; preds = %"assert succeeded113"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([45 x i8]* @str108, i64 0, i64 0))
  ret i32 -1

"assert succeeded115":                            ; preds = %"assert succeeded113"
  %195 = icmp eq i32 %15, 0
  br i1 %195, label %"assert succeeded117", label %"assert failed116", !prof !60

"assert failed116":                               ; preds = %"assert succeeded115"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([42 x i8]* @str109, i64 0, i64 0))
  ret i32 -1

"assert succeeded117":                            ; preds = %"assert succeeded115"
  %196 = icmp eq i32 %11, 5
  br i1 %196, label %"assert succeeded119", label %"assert failed118", !prof !60

"assert failed118":                               ; preds = %"assert succeeded117"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([45 x i8]* @str110, i64 0, i64 0))
  ret i32 -1

"assert succeeded119":                            ; preds = %"assert succeeded117"
  %197 = icmp eq i32 %input.stride.0, 1
  br i1 %197, label %"assert succeeded121", label %"assert failed120", !prof !60

"assert failed120":                               ; preds = %"assert succeeded119"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([48 x i8]* @str111, i64 0, i64 0))
  ret i32 -1

"assert succeeded121":                            ; preds = %"assert succeeded119"
  %198 = icmp eq i32 %output.stride.0, 1
  br i1 %198, label %"assert succeeded123", label %"assert failed122", !prof !60

"assert failed122":                               ; preds = %"assert succeeded121"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([49 x i8]* @str112, i64 0, i64 0))
  ret i32 -1

"assert succeeded123":                            ; preds = %"assert succeeded121"
  %199 = sext i32 %input.extent.0 to i64
  %200 = sext i32 %input.extent.1 to i64
  %201 = sext i32 %output.extent.0 to i64
  %202 = sext i32 %output.extent.1 to i64
  %output.total_extent.1 = mul nsw i64 %202, %201
  %203 = sext i32 %input.stride.1 to i64
  %204 = mul nsw i64 %203, %200
  %205 = icmp slt i64 %204, 2147483648
  br i1 %205, label %"assert succeeded133", label %"assert failed132", !prof !60

"assert failed132":                               ; preds = %"assert succeeded123"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([51 x i8]* @str115, i64 0, i64 0))
  ret i32 -1

"assert succeeded133":                            ; preds = %"assert succeeded123"
  %input.total_extent.1 = mul nsw i64 %200, %199
  %206 = icmp slt i64 %input.total_extent.1, 2147483648
  br i1 %206, label %"assert succeeded137", label %"assert failed134", !prof !60

"assert failed134":                               ; preds = %"assert succeeded133"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([53 x i8]* @str116, i64 0, i64 0))
  ret i32 -1

"assert succeeded137":                            ; preds = %"assert succeeded133"
  %207 = sext i32 %output.stride.1 to i64
  %208 = mul nsw i64 %207, %202
  %209 = icmp slt i64 %208, 2147483648
  br i1 %209, label %"assert succeeded139", label %"assert failed138", !prof !60

"assert failed138":                               ; preds = %"assert succeeded137"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([52 x i8]* @str117, i64 0, i64 0))
  ret i32 -1

"assert succeeded139":                            ; preds = %"assert succeeded137"
  %210 = icmp slt i64 %output.total_extent.1, 2147483648
  br i1 %210, label %"assert succeeded141", label %"assert failed140", !prof !60

"assert failed140":                               ; preds = %"assert succeeded139"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([54 x i8]* @str118, i64 0, i64 0))
  ret i32 -1

"assert succeeded141":                            ; preds = %"assert succeeded139"
  %211 = icmp slt i32 %49, %output.min.1
  %blur.y.min_realized = select i1 %211, i32 %49, i32 %output.min.1
  %212 = add nsw i32 %22, -128
  %213 = icmp slt i32 %212, %output.min.0
  %blur.x.min_realized = select i1 %213, i32 %212, i32 %output.min.0
  %214 = sub nsw i32 %46, %blur.x.min_realized
  %215 = add nsw i32 %214, 1
  %216 = sext i32 %215 to i64
  %217 = shl nsw i64 %216, 2
  %218 = sub nsw i32 %55, %blur.y.min_realized
  %219 = add nsw i32 %218, 1
  %220 = sext i32 %219 to i64
  %221 = mul i64 %217, %220
  %222 = or i64 %221, %217
  %223 = icmp ult i64 %222, 2147483648
  br i1 %223, label %"assert succeeded143", label %"assert failed142", !prof !60

"assert failed142":                               ; preds = %"assert succeeded141"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([57 x i8]* @str119, i64 0, i64 0))
  ret i32 -1

"assert succeeded143":                            ; preds = %"assert succeeded141"
  %224 = and i64 %221, 4294967292
  %blur.host = tail call i8* @halide_malloc(i8* null, i64 %224)
  %225 = icmp ne i8* %blur.host, null
  %226 = icmp eq i64 %224, 0
  %227 = or i1 %226, %225
  br i1 %227, label %"assert succeeded145", label %"assert failed144", !prof !60

"assert failed144":                               ; preds = %"assert succeeded143"
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([37 x i8]* @str120, i64 0, i64 0))
  ret i32 -1

"assert succeeded145":                            ; preds = %"assert succeeded143"
  %buf_host146 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 1
  store i8* %blur.host, i8** %buf_host146, align 8
  %buf_elem_size147 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 5
  store i32 4, i32* %buf_elem_size147, align 8
  %buf_min148 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 4, i64 0
  store i32 %blur.x.min_realized, i32* %buf_min148, align 8
  %buf_extent149 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 2, i64 0
  store i32 %215, i32* %buf_extent149, align 8
  %buf_stride150 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 3, i64 0
  store i32 1, i32* %buf_stride150, align 8
  %buf_min151 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 4, i64 1
  store i32 %blur.y.min_realized, i32* %buf_min151, align 4
  %buf_extent152 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 2, i64 1
  store i32 %219, i32* %buf_extent152, align 4
  %buf_stride153 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 3, i64 1
  store i32 %215, i32* %buf_stride153, align 4
  %buf_min154 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 4, i64 2
  store i32 0, i32* %buf_min154, align 8
  %buf_extent155 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 2, i64 2
  store i32 0, i32* %buf_extent155, align 8
  %buf_stride156 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 3, i64 2
  store i32 0, i32* %buf_stride156, align 8
  %buf_min157 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 4, i64 3
  store i32 0, i32* %buf_min157, align 4
  %buf_extent158 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 2, i64 3
  store i32 0, i32* %buf_extent158, align 4
  %buf_stride159 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 3, i64 3
  store i32 0, i32* %buf_stride159, align 4
  %buffer_host_dirty160 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 6
  store i8 0, i8* %buffer_host_dirty160, align 4
  %buffer_dev_dirty161 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 7
  store i8 0, i8* %buffer_dev_dirty161, align 1
  %buf_dev162 = getelementptr inbounds %struct.buffer_t* %blur.buffer, i64 0, i32 0
  store i64 0, i64* %buf_dev162, align 8
  %228 = call i32 @halide_dev_malloc(i8* null, %struct.buffer_t* %blur.buffer) #3
  %229 = icmp eq i32 %228, 0
  br i1 %229, label %"produce blur", label %"assert failed163", !prof !60

"assert failed163":                               ; preds = %"assert succeeded145"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([42 x i8]* @str121, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"produce blur":                                   ; preds = %"assert succeeded145"
  %blur.x.extent_realized.s.s.stack = alloca i32, align 4
  store i32 %46, i32* %blur.x.extent_realized.s.s.stack, align 4
  %230 = bitcast [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204 to i32**
  store i32* %blur.x.extent_realized.s.s.stack, i32** %230, align 8
  %231 = getelementptr [9 x [9 x i64]]* %kernel_blur_s0_y___block_id_y_arg_sizes203, i64 0, i64 0, i64 0
  store i64 4, i64* %231, align 8
  %blur.x.min_realized.stack = alloca i32, align 4
  store i32 %blur.x.min_realized, i32* %blur.x.min_realized.stack, align 4
  %232 = getelementptr [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204, i64 0, i64 0, i64 1
  %233 = bitcast i8** %232 to i32**
  store i32* %blur.x.min_realized.stack, i32** %233, align 8
  %234 = getelementptr [9 x [9 x i64]]* %kernel_blur_s0_y___block_id_y_arg_sizes203, i64 0, i64 0, i64 1
  store i64 4, i64* %234, align 8
  %blur.y.min_realized.stack = alloca i32, align 4
  store i32 %blur.y.min_realized, i32* %blur.y.min_realized.stack, align 4
  %235 = getelementptr [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204, i64 0, i64 0, i64 2
  %236 = bitcast i8** %235 to i32**
  store i32* %blur.y.min_realized.stack, i32** %236, align 8
  %237 = getelementptr [9 x [9 x i64]]* %kernel_blur_s0_y___block_id_y_arg_sizes203, i64 0, i64 0, i64 2
  store i64 4, i64* %237, align 8
  %output.extent.0.stack = alloca i32, align 4
  store i32 %output.extent.0, i32* %output.extent.0.stack, align 4
  %238 = getelementptr [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204, i64 0, i64 0, i64 3
  %239 = bitcast i8** %238 to i32**
  store i32* %output.extent.0.stack, i32** %239, align 8
  %240 = getelementptr [9 x [9 x i64]]* %kernel_blur_s0_y___block_id_y_arg_sizes203, i64 0, i64 0, i64 3
  store i64 4, i64* %240, align 8
  %output.extent.1.stack = alloca i32, align 4
  store i32 %output.extent.1, i32* %output.extent.1.stack, align 4
  %241 = getelementptr [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204, i64 0, i64 0, i64 4
  %242 = bitcast i8** %241 to i32**
  store i32* %output.extent.1.stack, i32** %242, align 8
  %243 = getelementptr [9 x [9 x i64]]* %kernel_blur_s0_y___block_id_y_arg_sizes203, i64 0, i64 0, i64 4
  store i64 4, i64* %243, align 8
  %output.min.0.stack = alloca i32, align 4
  store i32 %output.min.0, i32* %output.min.0.stack, align 4
  %244 = getelementptr [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204, i64 0, i64 0, i64 5
  %245 = bitcast i8** %244 to i32**
  store i32* %output.min.0.stack, i32** %245, align 8
  %246 = getelementptr [9 x [9 x i64]]* %kernel_blur_s0_y___block_id_y_arg_sizes203, i64 0, i64 0, i64 5
  store i64 4, i64* %246, align 8
  %output.min.1.stack = alloca i32, align 4
  store i32 %output.min.1, i32* %output.min.1.stack, align 4
  %247 = getelementptr [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204, i64 0, i64 0, i64 6
  %248 = bitcast i8** %247 to i32**
  store i32* %output.min.1.stack, i32** %248, align 8
  %249 = getelementptr [9 x [9 x i64]]* %kernel_blur_s0_y___block_id_y_arg_sizes203, i64 0, i64 0, i64 6
  store i64 4, i64* %249, align 8
  %250 = load i64* %buf_dev162, align 8
  %blur.stack = alloca i64, align 8
  store i64 %250, i64* %blur.stack, align 8
  %251 = getelementptr [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204, i64 0, i64 0, i64 7
  %252 = bitcast i8** %251 to i64**
  store i64* %blur.stack, i64** %252, align 8
  %253 = getelementptr [9 x [9 x i64]]* %kernel_blur_s0_y___block_id_y_arg_sizes203, i64 0, i64 0, i64 7
  store i64 8, i64* %253, align 8
  %254 = getelementptr [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204, i64 0, i64 0, i64 8
  store i8* null, i8** %254, align 8
  %255 = getelementptr [9 x [9 x i64]]* %kernel_blur_s0_y___block_id_y_arg_sizes203, i64 0, i64 0, i64 8
  store i64 0, i64* %255, align 8
  %256 = load i8** @module_state, align 8
  %257 = add nsw i32 %output.extent.0, 127
  %258 = ashr i32 %257, 7
  %259 = add nsw i32 %output.extent.1, 7
  %260 = ashr i32 %259, 3
  %gpu_args_arr_ref = getelementptr [9 x [9 x i8*]]* %kernel_blur_s0_y___block_id_y_args204, i64 0, i64 0, i64 0
  %261 = call i32 @halide_dev_run(i8* null, i8* %256, i8* getelementptr inbounds ([30 x i8]* @entry_name, i64 0, i64 0), i32 %258, i32 %260, i32 1, i32 16, i32 8, i32 1, i32 0, i64* %231, i8** %gpu_args_arr_ref, i32 0, float* null, i32 0, i32 0)
  %262 = icmp eq i32 %261, 0
  br i1 %262, label %"assert succeeded167", label %"assert failed166", !prof !60

"assert failed166":                               ; preds = %"produce blur"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([30 x i8]* @str122, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"assert succeeded167":                            ; preds = %"produce blur"
  store i8 1, i8* %buffer_dev_dirty161, align 1
  %263 = call i32 @halide_copy_to_host(i8* null, %struct.buffer_t* %input.buffer) #3
  %264 = icmp eq i32 %263, 0
  br i1 %264, label %"assert succeeded170", label %"assert failed169", !prof !60

"assert failed169":                               ; preds = %"assert succeeded167"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([37 x i8]* @str123, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"assert succeeded170":                            ; preds = %"assert succeeded167"
  %265 = call i32 @halide_copy_to_host(i8* null, %struct.buffer_t* @i0.buffer) #3
  %266 = icmp eq i32 %265, 0
  br i1 %266, label %"assert succeeded172", label %"assert failed171", !prof !60

"assert failed171":                               ; preds = %"assert succeeded170"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([34 x i8]* @str124, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"assert succeeded172":                            ; preds = %"assert succeeded170"
  %267 = call i32 @halide_copy_to_host(i8* null, %struct.buffer_t* %blur.buffer) #3
  %268 = icmp eq i32 %267, 0
  br i1 %268, label %"assert succeeded174", label %"assert failed173", !prof !60

"assert failed173":                               ; preds = %"assert succeeded172"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([36 x i8]* @str125, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"assert succeeded174":                            ; preds = %"assert succeeded172"
  %269 = icmp sgt i32 %output.extent.1, 0
  br i1 %269, label %"for blur.s1.y.preheader", label %"end for blur.s1.y", !prof !60

"for blur.s1.y.preheader":                        ; preds = %"assert succeeded174"
  %270 = icmp sgt i32 %output.extent.0, 0
  %271 = sext i32 %input.min.1 to i64
  %272 = mul nsw i64 %271, %203
  %273 = sext i32 %input.min.0 to i64
  %274 = add nsw i64 %200, -1
  %275 = add nsw i64 %199, -1
  %sum = add i64 %272, %273
  %276 = bitcast i8* %input.host to i16*
  %277 = bitcast i8* %i0.host to i16*
  %278 = sext i32 %blur.x.min_realized to i64
  %279 = sext i32 %46 to i64
  %280 = add nsw i64 %279, 1
  %281 = sub nsw i64 %280, %278
  %282 = sext i32 %blur.y.min_realized to i64
  %283 = bitcast i8* %blur.host to float*
  br i1 %270, label %"for blur.s1.y.preheader.split.us", label %"end for blur.s1.y"

"for blur.s1.y.preheader.split.us":               ; preds = %"for blur.s1.y.preheader"
  %284 = sext i32 %output.min.0 to i64
  %285 = sext i32 %output.min.1 to i64
  br label %"for blur.s1.x.preheader.us"

"for blur.s1.x.us":                               ; preds = %"for blur.s1.x.preheader.us", %"end for blur.s1.i0.y$r.us"
  %indvars.iv229 = phi i64 [ %284, %"for blur.s1.x.preheader.us" ], [ %345, %"end for blur.s1.i0.y$r.us" ]
  %286 = add nsw i64 %indvars.iv229, -2
  %287 = add i64 %386, %indvars.iv229
  %288 = getelementptr inbounds float* %283, i64 %287
  %.promoted224.us = load float* %288, align 4, !tbaa !62
  %289 = icmp slt i64 %286, %275
  %290 = select i1 %289, i64 %286, i64 %275
  %291 = icmp slt i64 %290, 0
  %292 = select i1 %291, i64 0, i64 %290
  br label %"for blur.s1.i0.y$r.us"

"for blur.s1.i0.y$r.us":                          ; preds = %"for blur.s1.i0.y$r.us", %"for blur.s1.x.us"
  %indvars.iv226 = phi i64 [ %indvars.iv.next227, %"for blur.s1.i0.y$r.us" ], [ 0, %"for blur.s1.x.us" ]
  %.lcssa225.us = phi float [ %378, %"for blur.s1.i0.y$r.us" ], [ %.promoted224.us, %"for blur.s1.x.us" ]
  %293 = add nsw i64 %383, %indvars.iv226
  %294 = icmp slt i64 %293, %274
  %295 = select i1 %294, i64 %293, i64 %274
  %296 = icmp slt i64 %295, 0
  %297 = select i1 %296, i64 0, i64 %295
  %298 = mul nsw i64 %297, %203
  %299 = sub i64 %298, %sum
  %300 = mul nsw i64 %indvars.iv226, 5
  %301 = add i64 %299, %292
  %302 = getelementptr inbounds i16* %276, i64 %301
  %303 = load i16* %302, align 2, !tbaa !64
  %304 = uitofp i16 %303 to float
  %305 = fmul float %304, 0x3EF0001000000000
  %306 = getelementptr inbounds i16* %277, i64 %300
  %307 = load i16* %306, align 2, !tbaa !65
  %308 = uitofp i16 %307 to float
  %309 = fmul float %308, %305
  %310 = fmul float %309, 0x3F6E01E020000000
  %311 = fadd float %.lcssa225.us, %310
  %312 = add nsw i64 %indvars.iv229, -1
  %313 = icmp slt i64 %312, %275
  %314 = select i1 %313, i64 %312, i64 %275
  %315 = icmp slt i64 %314, 0
  %316 = select i1 %315, i64 0, i64 %314
  %317 = add i64 %299, %316
  %318 = getelementptr inbounds i16* %276, i64 %317
  %319 = load i16* %318, align 2, !tbaa !64
  %320 = uitofp i16 %319 to float
  %321 = fmul float %320, 0x3EF0001000000000
  %322 = add nuw nsw i64 %300, 1
  %323 = getelementptr inbounds i16* %277, i64 %322
  %324 = load i16* %323, align 2, !tbaa !65
  %325 = uitofp i16 %324 to float
  %326 = fmul float %325, %321
  %327 = fmul float %326, 0x3F6E01E020000000
  %328 = fadd float %311, %327
  %329 = icmp slt i64 %indvars.iv229, %275
  %330 = select i1 %329, i64 %indvars.iv229, i64 %275
  %331 = icmp slt i64 %330, 0
  %332 = select i1 %331, i64 0, i64 %330
  %333 = add i64 %299, %332
  %334 = getelementptr inbounds i16* %276, i64 %333
  %335 = load i16* %334, align 2, !tbaa !64
  %336 = uitofp i16 %335 to float
  %337 = fmul float %336, 0x3EF0001000000000
  %338 = add nuw nsw i64 %300, 2
  %339 = getelementptr inbounds i16* %277, i64 %338
  %340 = load i16* %339, align 2, !tbaa !65
  %341 = uitofp i16 %340 to float
  %342 = fmul float %341, %337
  %343 = fmul float %342, 0x3F6E01E020000000
  %344 = fadd float %328, %343
  %345 = add nsw i64 %indvars.iv229, 1
  %346 = icmp slt i64 %345, %275
  %347 = select i1 %346, i64 %345, i64 %275
  %348 = icmp slt i64 %347, 0
  %349 = select i1 %348, i64 0, i64 %347
  %350 = add i64 %299, %349
  %351 = getelementptr inbounds i16* %276, i64 %350
  %352 = load i16* %351, align 2, !tbaa !64
  %353 = uitofp i16 %352 to float
  %354 = fmul float %353, 0x3EF0001000000000
  %355 = add nuw nsw i64 %300, 3
  %356 = getelementptr inbounds i16* %277, i64 %355
  %357 = load i16* %356, align 2, !tbaa !65
  %358 = uitofp i16 %357 to float
  %359 = fmul float %358, %354
  %360 = fmul float %359, 0x3F6E01E020000000
  %361 = fadd float %344, %360
  %362 = add nsw i64 %indvars.iv229, 2
  %363 = icmp slt i64 %362, %275
  %364 = select i1 %363, i64 %362, i64 %275
  %365 = icmp slt i64 %364, 0
  %366 = select i1 %365, i64 0, i64 %364
  %367 = add i64 %299, %366
  %368 = getelementptr inbounds i16* %276, i64 %367
  %369 = load i16* %368, align 2, !tbaa !64
  %370 = uitofp i16 %369 to float
  %371 = fmul float %370, 0x3EF0001000000000
  %372 = add nuw nsw i64 %300, 4
  %373 = getelementptr inbounds i16* %277, i64 %372
  %374 = load i16* %373, align 2, !tbaa !65
  %375 = uitofp i16 %374 to float
  %376 = fmul float %375, %371
  %377 = fmul float %376, 0x3F6E01E020000000
  %378 = fadd float %361, %377
  %indvars.iv.next227 = add nuw nsw i64 %indvars.iv226, 1
  %exitcond228 = icmp eq i64 %indvars.iv.next227, 5
  br i1 %exitcond228, label %"end for blur.s1.i0.y$r.us", label %"for blur.s1.i0.y$r.us"

"end for blur.s1.i0.y$r.us":                      ; preds = %"for blur.s1.i0.y$r.us"
  store float %378, float* %288, align 4, !tbaa !62
  %379 = trunc i64 %345 to i32
  %380 = icmp eq i32 %379, %22
  br i1 %380, label %"end for blur.s1.x.us", label %"for blur.s1.x.us"

"end for blur.s1.x.us":                           ; preds = %"end for blur.s1.i0.y$r.us"
  %indvars.iv.next232 = add nsw i64 %indvars.iv231, 1
  %381 = trunc i64 %indvars.iv.next232 to i32
  %382 = icmp eq i32 %381, %34
  br i1 %382, label %"end for blur.s1.y", label %"for blur.s1.x.preheader.us"

"for blur.s1.x.preheader.us":                     ; preds = %"for blur.s1.y.preheader.split.us", %"end for blur.s1.x.us"
  %indvars.iv231 = phi i64 [ %indvars.iv.next232, %"end for blur.s1.x.us" ], [ %285, %"for blur.s1.y.preheader.split.us" ]
  %383 = add nsw i64 %indvars.iv231, -2
  %384 = sub nsw i64 %indvars.iv231, %282
  %385 = mul nsw i64 %384, %281
  %386 = sub i64 %385, %278
  br label %"for blur.s1.x.us"

"end for blur.s1.y":                              ; preds = %"end for blur.s1.x.us", %"for blur.s1.y.preheader", %"assert succeeded174"
  store i8 1, i8* %buffer_host_dirty160, align 4
  %387 = call i32 @halide_dev_malloc(i8* null, %struct.buffer_t* %output.buffer) #3
  %388 = icmp eq i32 %387, 0
  br i1 %388, label %"produce output", label %"assert failed176", !prof !60

"assert failed176":                               ; preds = %"end for blur.s1.y"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([44 x i8]* @str126, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"produce output":                                 ; preds = %"end for blur.s1.y"
  %389 = call i32 @halide_copy_to_dev(i8* null, %struct.buffer_t* %output.buffer) #3
  %390 = icmp eq i32 %389, 0
  br i1 %390, label %"assert succeeded179", label %"assert failed178", !prof !60

"assert failed178":                               ; preds = %"produce output"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([37 x i8]* @str127, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"assert succeeded179":                            ; preds = %"produce output"
  %391 = call i32 @halide_copy_to_dev(i8* null, %struct.buffer_t* %blur.buffer) #3
  %392 = icmp eq i32 %391, 0
  br i1 %392, label %"assert succeeded181", label %"assert failed180", !prof !60

"assert failed180":                               ; preds = %"assert succeeded179"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([35 x i8]* @str128, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"assert succeeded181":                            ; preds = %"assert succeeded179"
  %blur.x.extent_realized.s.s.stack182 = alloca i32, align 4
  store i32 %46, i32* %blur.x.extent_realized.s.s.stack182, align 4
  %393 = bitcast [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202 to i32**
  store i32* %blur.x.extent_realized.s.s.stack182, i32** %393, align 8
  %394 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 0
  store i64 4, i64* %394, align 8
  %blur.x.min_realized.stack183 = alloca i32, align 4
  store i32 %blur.x.min_realized, i32* %blur.x.min_realized.stack183, align 4
  %395 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 1
  %396 = bitcast i8** %395 to i32**
  store i32* %blur.x.min_realized.stack183, i32** %396, align 8
  %397 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 1
  store i64 4, i64* %397, align 8
  %blur.y.min_realized.stack184 = alloca i32, align 4
  store i32 %blur.y.min_realized, i32* %blur.y.min_realized.stack184, align 4
  %398 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 2
  %399 = bitcast i8** %398 to i32**
  store i32* %blur.y.min_realized.stack184, i32** %399, align 8
  %400 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 2
  store i64 4, i64* %400, align 8
  %output.extent.0.stack185 = alloca i32, align 4
  store i32 %output.extent.0, i32* %output.extent.0.stack185, align 4
  %401 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 3
  %402 = bitcast i8** %401 to i32**
  store i32* %output.extent.0.stack185, i32** %402, align 8
  %403 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 3
  store i64 4, i64* %403, align 8
  %output.extent.1.stack186 = alloca i32, align 4
  store i32 %output.extent.1, i32* %output.extent.1.stack186, align 4
  %404 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 4
  %405 = bitcast i8** %404 to i32**
  store i32* %output.extent.1.stack186, i32** %405, align 8
  %406 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 4
  store i64 4, i64* %406, align 8
  %output.min.0.stack187 = alloca i32, align 4
  store i32 %output.min.0, i32* %output.min.0.stack187, align 4
  %407 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 5
  %408 = bitcast i8** %407 to i32**
  store i32* %output.min.0.stack187, i32** %408, align 8
  %409 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 5
  store i64 4, i64* %409, align 8
  %output.min.1.stack188 = alloca i32, align 4
  store i32 %output.min.1, i32* %output.min.1.stack188, align 4
  %410 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 6
  %411 = bitcast i8** %410 to i32**
  store i32* %output.min.1.stack188, i32** %411, align 8
  %412 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 6
  store i64 4, i64* %412, align 8
  %output.stride.1.stack = alloca i32, align 4
  store i32 %output.stride.1, i32* %output.stride.1.stack, align 4
  %413 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 7
  %414 = bitcast i8** %413 to i32**
  store i32* %output.stride.1.stack, i32** %414, align 8
  %415 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 7
  store i64 4, i64* %415, align 8
  %416 = load i64* %buf_dev162, align 8
  %blur.stack190 = alloca i64, align 8
  store i64 %416, i64* %blur.stack190, align 8
  %417 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 8
  %418 = bitcast i8** %417 to i64**
  store i64* %blur.stack190, i64** %418, align 8
  %419 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 8
  store i64 8, i64* %419, align 8
  %420 = load i64* %buf_dev11, align 8
  %output.stack = alloca i64, align 8
  store i64 %420, i64* %output.stack, align 8
  %421 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 9
  %422 = bitcast i8** %421 to i64**
  store i64* %output.stack, i64** %422, align 8
  %423 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 9
  store i64 8, i64* %423, align 8
  %424 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 10
  store i8* null, i8** %424, align 8
  %425 = getelementptr [11 x [11 x i64]]* %kernel_output_s0_y___block_id_y_arg_sizes201, i64 0, i64 0, i64 10
  store i64 0, i64* %425, align 8
  %426 = load i8** @module_state, align 8
  %427 = add nsw i32 %output.extent.0, 15
  %428 = ashr i32 %427, 4
  %429 = add nsw i32 %output.extent.1, 15
  %430 = ashr i32 %429, 4
  %gpu_args_arr_ref193 = getelementptr [11 x [11 x i8*]]* %kernel_output_s0_y___block_id_y_args202, i64 0, i64 0, i64 0
  %431 = call i32 @halide_dev_run(i8* null, i8* %426, i8* getelementptr inbounds ([32 x i8]* @entry_name129, i64 0, i64 0), i32 %428, i32 %430, i32 1, i32 2, i32 16, i32 1, i32 0, i64* %394, i8** %gpu_args_arr_ref193, i32 0, float* null, i32 0, i32 0)
  %432 = icmp eq i32 %431, 0
  br i1 %432, label %"assert succeeded195", label %"assert failed194", !prof !60

"assert failed194":                               ; preds = %"assert succeeded181"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([30 x i8]* @str122, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"assert succeeded195":                            ; preds = %"assert succeeded181"
  %433 = call i32 @halide_dev_free(i8* null, %struct.buffer_t* %blur.buffer) #3
  %434 = icmp eq i32 %433, 0
  br i1 %434, label %"assert succeeded197", label %"assert failed196", !prof !60

"assert failed196":                               ; preds = %"assert succeeded195"
  call void @halide_error(i8* null, i8* getelementptr inbounds ([38 x i8]* @str130, i64 0, i64 0))
  call void @halide_free(i8* null, i8* %blur.host)
  ret i32 -1

"assert succeeded197":                            ; preds = %"assert succeeded195"
  call void @halide_free(i8* null, i8* %blur.host)
  %buffer_dev_dirty198 = getelementptr inbounds %struct.buffer_t* %output.buffer, i64 0, i32 7
  store i8 1, i8* %buffer_dev_dirty198, align 1
  br label %after_bb77

"assert failed199":                               ; preds = %init_kernels
  tail call void @halide_error(i8* null, i8* getelementptr inbounds ([35 x i8]* @str131, i64 0, i64 0))
  ret i32 -1

"assert succeeded200":                            ; preds = %init_kernels
  %kernel_output_s0_y___block_id_y_arg_sizes201 = alloca [11 x [11 x i64]], align 8
  %kernel_output_s0_y___block_id_y_args202 = alloca [11 x [11 x i8*]], align 8
  %kernel_blur_s0_y___block_id_y_arg_sizes203 = alloca [9 x [9 x i64]], align 8
  %kernel_blur_s0_y___block_id_y_args204 = alloca [9 x [9 x i8*]], align 8
  %blur.buffer = alloca %struct.buffer_t, align 8
  %435 = alloca [128 x i8], align 1
  %436 = alloca [128 x i8], align 1
  %437 = alloca [128 x i8], align 1
  %438 = alloca [128 x i8], align 1
  %439 = alloca [128 x i8], align 1
  %440 = alloca [128 x i8], align 1
  %441 = alloca [128 x i8], align 1
  %442 = alloca [128 x i8], align 1
  %443 = alloca [96 x i8], align 1
  %444 = alloca [96 x i8], align 1
  %445 = alloca [96 x i8], align 1
  %446 = alloca [96 x i8], align 1
  %447 = alloca [128 x i8], align 1
  %448 = alloca [112 x i8], align 1
  %449 = alloca [112 x i8], align 1
  %.sub218 = getelementptr inbounds [112 x i8]* %449, i64 0, i64 0
  %.sub217 = getelementptr inbounds [112 x i8]* %448, i64 0, i64 0
  %.sub216 = getelementptr inbounds [128 x i8]* %447, i64 0, i64 0
  %.sub215 = getelementptr inbounds [96 x i8]* %446, i64 0, i64 0
  %.sub214 = getelementptr inbounds [96 x i8]* %445, i64 0, i64 0
  %.sub213 = getelementptr inbounds [96 x i8]* %444, i64 0, i64 0
  %.sub212 = getelementptr inbounds [96 x i8]* %443, i64 0, i64 0
  %.sub211 = getelementptr inbounds [128 x i8]* %442, i64 0, i64 0
  %.sub210 = getelementptr inbounds [128 x i8]* %441, i64 0, i64 0
  %.sub209 = getelementptr inbounds [128 x i8]* %440, i64 0, i64 0
  %.sub208 = getelementptr inbounds [128 x i8]* %439, i64 0, i64 0
  %.sub207 = getelementptr inbounds [128 x i8]* %438, i64 0, i64 0
  %.sub206 = getelementptr inbounds [128 x i8]* %437, i64 0, i64 0
  %.sub205 = getelementptr inbounds [128 x i8]* %436, i64 0, i64 0
  %.sub = getelementptr inbounds [128 x i8]* %435, i64 0, i64 0
  %buf_host = getelementptr inbounds %struct.buffer_t* %input.buffer, i64 0, i32 1
  %input.host = load i8** %buf_host, align 8
  %450 = icmp eq %struct.buffer_t* %input.buffer, null
  br i1 %450, label %"assert failed", label %"assert succeeded", !prof !61
}

; Function Attrs: nounwind
define i32 @gaussinBlur_gpu_jit_wrapper(i8** nocapture readonly) #3 {
entry:
  %1 = bitcast i8** %0 to %struct.buffer_t**
  %2 = load %struct.buffer_t** %1, align 8
  %3 = getelementptr i8** %0, i64 1
  %4 = bitcast i8** %3 to %struct.buffer_t**
  %5 = load %struct.buffer_t** %4, align 8
  %6 = tail call i32 @gaussinBlur_gpu(%struct.buffer_t* %2, %struct.buffer_t* %5)
  ret i32 %6
}

attributes #0 = { "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readonly "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind }
attributes #4 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nobuiltin nounwind }
attributes #6 = { nobuiltin }

!llvm.ident = !{!0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0, !0}

!0 = !{!"clang version 3.6.0 (http://llvm.org/git/clang.git 71c1f3b6570c651f5fd16ee5711ae385bc7dd79e) (http://llvm.org/git/llvm.git 870f78a5841b17616a6cc9f1e3f676045dd5b5d1)"}
!1 = !{!2, !3, i64 0}
!2 = !{!"_ZTS8timespec", !3, i64 0, !3, i64 8}
!3 = !{!"long", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!2, !3, i64 8}
!7 = !{!8, !8, i64 0}
!8 = !{!"bool", !4, i64 0}
!9 = !{i8 0, i8 2}
!10 = !{!11, !8, i64 632}
!11 = !{!"_ZTSN6Halide7Runtime8Internal19halide_work_queue_tE", !12, i64 0, !13, i64 64, !14, i64 72, !4, i64 120, !8, i64 632}
!12 = !{!"_ZTS15pthread_mutex_t", !4, i64 0}
!13 = !{!"any pointer", !4, i64 0}
!14 = !{!"_ZTS14pthread_cond_t", !4, i64 0}
!15 = !{!16, !16, i64 0}
!16 = !{!"int", !4, i64 0}
!17 = !{!3, !3, i64 0}
!18 = !{!13, !13, i64 0}
!19 = !{!4, !4, i64 0}
!20 = !{!21, !16, i64 64}
!21 = !{!"_ZTS8buffer_t", !3, i64 0, !13, i64 8, !4, i64 16, !4, i64 32, !4, i64 48, !16, i64 64, !8, i64 68, !8, i64 69}
!22 = !{!21, !13, i64 8}
!23 = !{i64 0, i64 8, !17, i64 8, i64 8, !18, i64 16, i64 16, !19, i64 32, i64 16, !19, i64 48, i64 16, !19, i64 64, i64 4, !15, i64 68, i64 1, !7, i64 69, i64 1, !7}
!24 = !{!25, !13, i64 0}
!25 = !{!"_ZTSN6Halide7Runtime8Internal10CacheEntryE", !13, i64 0, !13, i64 8, !13, i64 16, !13, i64 24, !3, i64 32, !13, i64 40, !16, i64 48, !16, i64 52, !21, i64 56, !4, i64 128}
!26 = !{!25, !3, i64 32}
!27 = !{!25, !16, i64 48}
!28 = !{!25, !16, i64 52}
!29 = !{!25, !13, i64 40}
!30 = distinct !{!30, !31}
!31 = !{!"llvm.loop.unroll.disable"}
!32 = !{!25, !13, i64 8}
!33 = !{!25, !13, i64 16}
!34 = !{!25, !13, i64 24}
!35 = !{!36, !3, i64 0}
!36 = !{!"_ZTSN6Halide7Runtime8Internal8dev_copyE", !3, i64 0, !3, i64 8, !4, i64 16, !4, i64 48, !3, i64 80}
!37 = !{!21, !3, i64 0}
!38 = !{!36, !3, i64 8}
!39 = !{!36, !3, i64 80}
!40 = distinct !{!40, !31}
!41 = !{i64 0, i64 8, !17, i64 8, i64 8, !17, i64 16, i64 32, !19, i64 48, i64 32, !19, i64 80, i64 8, !17}
!42 = !{!43, !13, i64 1024}
!43 = !{!"_ZTSN6Halide7Runtime8Internal7PrinterILi1ELm1024EEE", !4, i64 0, !13, i64 1024, !13, i64 1032, !13, i64 1040}
!44 = !{!43, !13, i64 1032}
!45 = !{!43, !13, i64 1040}
!46 = !{!47, !13, i64 0}
!47 = !{!"_ZTSN6Halide7Runtime8Internal9ClContextE", !13, i64 0, !13, i64 8, !13, i64 16, !16, i64 24}
!48 = !{!47, !16, i64 24}
!49 = !{!47, !13, i64 8}
!50 = !{!51, !13, i64 0}
!51 = !{!"_ZTSN6Halide7Runtime8Internal12module_stateE", !13, i64 0, !13, i64 8}
!52 = !{!51, !13, i64 8}
!53 = !{!54, !13, i64 1024}
!54 = !{!"_ZTSN6Halide7Runtime8Internal7PrinterILi2ELm1024EEE", !4, i64 0, !13, i64 1024, !13, i64 1032, !13, i64 1040}
!55 = !{!54, !13, i64 1032}
!56 = !{!54, !13, i64 1040}
!57 = !{!47, !13, i64 16}
!58 = !{!21, !8, i64 68}
!59 = !{!21, !8, i64 69}
!60 = !{!"branch_weights", i32 1073741824, i32 0}
!61 = !{!"branch_weights", i32 0, i32 1073741824}
!62 = !{!"blur", !63}
!63 = !{!"Halide buffer"}
!64 = !{!"input", !63}
!65 = !{!"i0", !63}
Compiling to native code...
Target triple: x86_64--linux-gnu
Selected target: x86-64
